/* automatically generated by rust-bindgen */

pub type std_string = [u64; 4usize];
pub type std_istream = [u64; 35usize];
pub type std_ostream = [u64; 34usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_pair {
    pub _address: u8,
}
pub type std_pair_first_type = u8;
pub type std_pair_second_type = u8;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
pub type std_allocator_value_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_hash {
    pub _address: u8,
}
pub type std_array_value_type = u8;
pub type std_array_pointer = u8;
pub type std_array_const_pointer = u8;
pub type std_array_reference = u8;
pub type std_array_const_reference = u8;
pub type std_array_iterator = u8;
pub type std_array_const_iterator = u8;
pub type std_array_size_type = u64;
pub type std_array_difference_type = u64;
pub type std_array_reverse_iterator = u8;
pub type std_array_const_reverse_iterator = u8;
pub type std_array__AT_Type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__Inherited = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_tuple__TC2 {
    pub _address: u8,
}
pub type std_tuple__TCC = u8;
pub type std_tuple__TMC = u8;
pub type std_tuple__TMCT = u8;
pub type std_tuple__TNTC = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr__DeleterConstraint = u8;
pub type std_unique_ptr_pointer = u8;
pub type std_unique_ptr_element_type = u8;
pub type std_unique_ptr_deleter_type = u8;
pub type std_unique_ptr___safe_conversion_up = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
pub type std_shared_ptr_weak_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_unordered_map {
    pub _address: u8,
}
pub type std_unordered_map__Hashtable = u8;
pub type std_unordered_map_key_type = u8;
pub type std_unordered_map_value_type = u8;
pub type std_unordered_map_mapped_type = u8;
pub type std_unordered_map_hasher = u8;
pub type std_unordered_map_key_equal = u8;
pub type std_unordered_map_allocator_type = u8;
pub type std_unordered_map_pointer = u8;
pub type std_unordered_map_const_pointer = u8;
pub type std_unordered_map_reference = u8;
pub type std_unordered_map_const_reference = u8;
pub type std_unordered_map_iterator = u8;
pub type std_unordered_map_const_iterator = u8;
pub type std_unordered_map_local_iterator = u8;
pub type std_unordered_map_const_local_iterator = u8;
pub type std_unordered_map_size_type = u8;
pub type std_unordered_map_difference_type = u8;
pub type std_unordered_map_node_type = u8;
pub type std_unordered_map_insert_return_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u64;
pub type std_vector_difference_type = u64;
pub type std_vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_vector__Temporary_value {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_map {
    pub _address: u8,
}
pub type std_map_key_type = u8;
pub type std_map_mapped_type = u8;
pub type std_map_value_type = u8;
pub type std_map_key_compare = u8;
pub type std_map_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_map_value_compare {
    pub _address: u8,
}
pub type std_map__Pair_alloc_type = u8;
pub type std_map__Rep_type = u8;
pub type std_map__Alloc_traits = u8;
pub type std_map_pointer = u8;
pub type std_map_const_pointer = u8;
pub type std_map_reference = u8;
pub type std_map_const_reference = u8;
pub type std_map_iterator = u8;
pub type std_map_const_iterator = u8;
pub type std_map_size_type = u8;
pub type std_map_difference_type = u8;
pub type std_map_reverse_iterator = u8;
pub type std_map_const_reverse_iterator = u8;
pub type std_map_node_type = u8;
pub type std_map_insert_return_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_mutex {
    pub _bindgen_opaque_blob: [u64; 5usize],
}
pub type std_mutex_native_handle_type = u64;
#[test]
fn bindgen_test_layout_std_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_mutex>(),
        40usize,
        concat!("Size of: ", stringify!(std_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_mutex))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex4lockEv"]
    pub fn std_mutex_lock(this: *mut std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex8try_lockEv"]
    pub fn std_mutex_try_lock(this: *mut std_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex6unlockEv"]
    pub fn std_mutex_unlock(this: *mut std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutex13native_handleEv"]
    pub fn std_mutex_native_handle(this: *mut std_mutex) -> std_mutex_native_handle_type;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutexC1Ev"]
    pub fn std_mutex_mutex(this: *mut std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutexC1ERKS_"]
    pub fn std_mutex_mutex1(this: *mut std_mutex, arg1: *const std_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt5mutexD1Ev"]
    pub fn std_mutex_mutex_destructor(this: *mut std_mutex);
}
impl std_mutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std_mutex_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        std_mutex_try_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std_mutex_unlock(self)
    }
    #[inline]
    pub unsafe fn native_handle(&mut self) -> std_mutex_native_handle_type {
        std_mutex_native_handle(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_mutex_mutex(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_mutex) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_mutex_mutex1(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_mutex_mutex_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_unique_lock {
    pub _address: u8,
}
pub type std_unique_lock_mutex_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_shared_mutex {
    pub _bindgen_opaque_blob: [u64; 7usize],
}
pub type std_shared_mutex_native_handle_type = u64;
#[test]
fn bindgen_test_layout_std_shared_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_shared_mutex>(),
        56usize,
        concat!("Size of: ", stringify!(std_shared_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_shared_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(std_shared_mutex))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex4lockEv"]
    pub fn std_shared_mutex_lock(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex8try_lockEv"]
    pub fn std_shared_mutex_try_lock(this: *mut std_shared_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex6unlockEv"]
    pub fn std_shared_mutex_unlock(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex11lock_sharedEv"]
    pub fn std_shared_mutex_lock_shared(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex15try_lock_sharedEv"]
    pub fn std_shared_mutex_try_lock_shared(this: *mut std_shared_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex13unlock_sharedEv"]
    pub fn std_shared_mutex_unlock_shared(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutex13native_handleEv"]
    pub fn std_shared_mutex_native_handle(
        this: *mut std_shared_mutex,
    ) -> std_shared_mutex_native_handle_type;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutexC1Ev"]
    pub fn std_shared_mutex_shared_mutex(this: *mut std_shared_mutex);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutexC1ERKS_"]
    pub fn std_shared_mutex_shared_mutex1(
        this: *mut std_shared_mutex,
        arg1: *const std_shared_mutex,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12shared_mutexD1Ev"]
    pub fn std_shared_mutex_shared_mutex_destructor(this: *mut std_shared_mutex);
}
impl std_shared_mutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std_shared_mutex_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        std_shared_mutex_try_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std_shared_mutex_unlock(self)
    }
    #[inline]
    pub unsafe fn lock_shared(&mut self) {
        std_shared_mutex_lock_shared(self)
    }
    #[inline]
    pub unsafe fn try_lock_shared(&mut self) -> bool {
        std_shared_mutex_try_lock_shared(self)
    }
    #[inline]
    pub unsafe fn unlock_shared(&mut self) {
        std_shared_mutex_unlock_shared(self)
    }
    #[inline]
    pub unsafe fn native_handle(&mut self) -> std_shared_mutex_native_handle_type {
        std_shared_mutex_native_handle(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_shared_mutex_shared_mutex(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_shared_mutex) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_shared_mutex_shared_mutex1(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_shared_mutex_shared_mutex_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_shared_lock {
    pub _address: u8,
}
pub type std_shared_lock_mutex_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_complex {
    pub _address: u8,
}
pub type std_complex_value_type = u8;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type seal_SEAL_BYTE = u8;
///Represent an integer modulus of up to 62 bits. An instance of the SmallModulus
///class represents a non-negative integer modulus up to 62 bits. In particular,
///the encryption parameter plain_modulus, and the primes in coeff_modulus, are
///represented by instances of SmallModulus. The purpose of this class is to
///perform and store the pre-computation required by Barrett reduction.
///
///@par Thread Safety
///In general, reading from SmallModulus is thread-safe as long as no other thread
///is concurrently mutating it.
///
///@see EncryptionParameters for a description of the encryption parameters.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_util_global_variables_internal_mods_SmallModulus {
    pub value_: u64,
    pub const_ratio_: [u64; 3usize],
    pub bit_count_: ::std::os::raw::c_int,
    pub uint64_count_: usize,
}
#[test]
fn bindgen_test_layout_seal_util_global_variables_internal_mods_SmallModulus() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_global_variables_internal_mods_SmallModulus>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_global_variables_internal_mods_SmallModulus>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_global_variables_internal_mods_SmallModulus>())).value_
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus),
            "::",
            stringify!(value_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_global_variables_internal_mods_SmallModulus>()))
                .const_ratio_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus),
            "::",
            stringify!(const_ratio_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_global_variables_internal_mods_SmallModulus>()))
                .bit_count_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus),
            "::",
            stringify!(bit_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_global_variables_internal_mods_SmallModulus>()))
                .uint64_count_ as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_global_variables_internal_mods_SmallModulus),
            "::",
            stringify!(uint64_count_)
        )
    );
}
extern "C" {
    ///Returns the significant bit count of the value of the current SmallModulus.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus9bit_countEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_bit_count(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///Returns the size (in 64-bit words) of the value of the current SmallModulus.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus12uint64_countEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_uint64_count(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> usize;
}
extern "C" {
    ///Returns a const pointer to the value of the current SmallModulus.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus4dataEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_data(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> *const u64;
}
extern "C" {
    ///Returns the value of the current SmallModulus.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus5valueEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_value(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> u64;
}
extern "C" {
    ///Returns the Barrett ratio computed for the value of the current SmallModulus.
    ///The first two components of the Barrett ratio are the floor of 2^128/value,
    ///and the third component is the remainder.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus11const_ratioEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_const_ratio(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> *mut [u64; 3usize];
}
extern "C" {
    ///Returns whether the value of the current SmallModulus is zero.
    #[link_name = "\u{1}_ZNK4seal12SmallModulus7is_zeroEv"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_is_zero(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> bool;
}
extern "C" {
    ///Saves the SmallModulus to an output stream. The full state of the modulus is
    ///serialized. The output is in binary format and not human-readable. The output
    ///stream must have the "binary" flag set.
    ///
    ///@param[in] stream The stream to save the SmallModulus to
    ///@throws std::exception if the SmallModulus could not be written to stream
    #[link_name = "\u{1}_ZNK4seal12SmallModulus4saveERSo"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_save(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
        stream: *mut std_ostream,
    );
}
extern "C" {
    ///Loads a SmallModulus from an input stream overwriting the current SmallModulus.
    ///
    ///@param[in] stream The stream to load the SmallModulus from
    ///@throws std::exception if a valid SmallModulus could not be read from stream
    #[link_name = "\u{1}_ZN4seal12SmallModulus4loadERSi"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_load(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
        stream: *mut std_istream,
    );
}
extern "C" {
    ///Creates a SmallModulus instance. The value of the SmallModulus is set to
    ///the given value, or to zero by default.
    ///
    ///@param[in] value The integer modulus
    ///@throws std::invalid_argument if value is 1 or more than 62 bits
    #[link_name = "\u{1}_ZN4seal12SmallModulusC1Em"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_SmallModulus(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
        value: u64,
    );
}
extern "C" {
    ///Creates a new SmallModulus by copying a given one.
    ///
    ///@param[in] copy The SmallModulus to copy from
    #[link_name = "\u{1}_ZN4seal12SmallModulusC1ERKS0_"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_SmallModulus1(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
        copy: *const seal_util_global_variables_internal_mods_SmallModulus,
    );
}
extern "C" {
    ///Creates a new SmallModulus by copying a given one.
    ///
    ///@param[in] source The SmallModulus to move from
    #[link_name = "\u{1}_ZN4seal12SmallModulusC1EOS0_"]
    pub fn seal_util_global_variables_internal_mods_SmallModulus_SmallModulus2(
        this: *const seal_util_global_variables_internal_mods_SmallModulus,
        source: *mut seal_util_global_variables_internal_mods_SmallModulus,
    );
}
impl seal_util_global_variables_internal_mods_SmallModulus {
    #[inline]
    pub unsafe fn bit_count(&self) -> ::std::os::raw::c_int {
        seal_util_global_variables_internal_mods_SmallModulus_bit_count(self)
    }
    #[inline]
    pub unsafe fn uint64_count(&self) -> usize {
        seal_util_global_variables_internal_mods_SmallModulus_uint64_count(self)
    }
    #[inline]
    pub unsafe fn data(&self) -> *const u64 {
        seal_util_global_variables_internal_mods_SmallModulus_data(self)
    }
    #[inline]
    pub unsafe fn value(&self) -> u64 {
        seal_util_global_variables_internal_mods_SmallModulus_value(self)
    }
    #[inline]
    pub unsafe fn const_ratio(&self) -> *mut [u64; 3usize] {
        seal_util_global_variables_internal_mods_SmallModulus_const_ratio(self)
    }
    #[inline]
    pub unsafe fn is_zero(&self) -> bool {
        seal_util_global_variables_internal_mods_SmallModulus_is_zero(self)
    }
    #[inline]
    pub unsafe fn save(&self, stream: *mut std_ostream) {
        seal_util_global_variables_internal_mods_SmallModulus_save(self, stream)
    }
    #[inline]
    pub unsafe fn load(&mut self, stream: *mut std_istream) {
        seal_util_global_variables_internal_mods_SmallModulus_load(self, stream)
    }
    #[inline]
    pub unsafe fn new(value: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_global_variables_internal_mods_SmallModulus_SmallModulus(
            &mut __bindgen_tmp,
            value,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_util_global_variables_internal_mods_SmallModulus) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_global_variables_internal_mods_SmallModulus_SmallModulus1(
            &mut __bindgen_tmp,
            copy,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_util_global_variables_internal_mods_SmallModulus) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_global_variables_internal_mods_SmallModulus_SmallModulus2(
            &mut __bindgen_tmp,
            source,
        );
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_util_is_uint64 {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12reverse_bitsEj"]
    pub fn seal_util_reverse_bits(operand: u32) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12reverse_bitsEji"]
    pub fn seal_util_reverse_bits1(operand: u32, bit_count: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util21get_msb_index_genericEPmm"]
    pub fn seal_util_get_msb_index_generic(result: *mut ::std::os::raw::c_ulong, value: u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util25get_significant_bit_countEm"]
    pub fn seal_util_get_significant_bit_count(value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util11is_hex_charEc"]
    pub fn seal_util_is_hex_char(hex: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util19nibble_to_upper_hexEi"]
    pub fn seal_util_nibble_to_upper_hex(nibble: ::std::os::raw::c_int) -> ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13hex_to_nibbleEc"]
    pub fn seal_util_hex_to_nibble(hex: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15get_uint64_byteEPmm"]
    pub fn seal_util_get_uint64_byte(value: *mut u64, byte_index: usize) -> *mut seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15get_uint64_byteEPKmm"]
    pub fn seal_util_get_uint64_byte1(
        value: *const u64,
        byte_index: usize,
    ) -> *const seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util24get_hex_string_bit_countEPKci"]
    pub fn seal_util_get_hex_string_bit_count(
        hex_string: *const ::std::os::raw::c_char,
        char_count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type seal_util_ReaderLock = [u64; 2usize];
pub type seal_util_WriterLock = [u64; 2usize];
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_util_ReaderWriterLocker {
    pub rw_lock_mutex_: std_shared_mutex,
}
#[test]
fn bindgen_test_layout_seal_util_ReaderWriterLocker() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ReaderWriterLocker>(),
        56usize,
        concat!("Size of: ", stringify!(seal_util_ReaderWriterLocker))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ReaderWriterLocker>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_ReaderWriterLocker))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_ReaderWriterLocker>())).rw_lock_mutex_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_ReaderWriterLocker),
            "::",
            stringify!(rw_lock_mutex_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker12acquire_readEv"]
    pub fn seal_util_ReaderWriterLocker_acquire_read(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_ReaderLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker13acquire_writeEv"]
    pub fn seal_util_ReaderWriterLocker_acquire_write(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_WriterLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker16try_acquire_readEv"]
    pub fn seal_util_ReaderWriterLocker_try_acquire_read(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_ReaderLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLocker17try_acquire_writeEv"]
    pub fn seal_util_ReaderWriterLocker_try_acquire_write(
        this: *mut seal_util_ReaderWriterLocker,
    ) -> seal_util_WriterLock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18ReaderWriterLockerC1Ev"]
    pub fn seal_util_ReaderWriterLocker_ReaderWriterLocker(this: *mut seal_util_ReaderWriterLocker);
}
impl seal_util_ReaderWriterLocker {
    #[inline]
    pub unsafe fn acquire_read(&mut self) -> seal_util_ReaderLock {
        seal_util_ReaderWriterLocker_acquire_read(self)
    }
    #[inline]
    pub unsafe fn acquire_write(&mut self) -> seal_util_WriterLock {
        seal_util_ReaderWriterLocker_acquire_write(self)
    }
    #[inline]
    pub unsafe fn try_acquire_read(&mut self) -> seal_util_ReaderLock {
        seal_util_ReaderWriterLocker_try_acquire_read(self)
    }
    #[inline]
    pub unsafe fn try_acquire_write(&mut self) -> seal_util_WriterLock {
        seal_util_ReaderWriterLocker_try_acquire_write(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_ReaderWriterLocker_ReaderWriterLocker(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seal_util_MemoryPoolItem {
    pub data_: *mut seal_SEAL_BYTE,
    pub next_: *mut seal_util_MemoryPoolItem,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolItem() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolItem>(),
        16usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolItem))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolItem>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolItem>())).data_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolItem),
            "::",
            stringify!(data_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolItem>())).next_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolItem),
            "::",
            stringify!(next_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolItem4dataEv"]
    pub fn seal_util_MemoryPoolItem_data(
        this: *mut seal_util_MemoryPoolItem,
    ) -> *mut seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14MemoryPoolItem4dataEv"]
    pub fn seal_util_MemoryPoolItem_data1(
        this: *const seal_util_MemoryPoolItem,
    ) -> *const seal_SEAL_BYTE;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolItem4nextEv"]
    pub fn seal_util_MemoryPoolItem_next(
        this: *mut seal_util_MemoryPoolItem,
    ) -> *mut *mut seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14MemoryPoolItem4nextEv"]
    pub fn seal_util_MemoryPoolItem_next1(
        this: *const seal_util_MemoryPoolItem,
    ) -> *const seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolItemC1EPNS_9SEAL_BYTEE"]
    pub fn seal_util_MemoryPoolItem_MemoryPoolItem(
        this: *mut seal_util_MemoryPoolItem,
        data: *mut seal_SEAL_BYTE,
    );
}
impl Default for seal_util_MemoryPoolItem {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolItem {
    #[inline]
    pub unsafe fn data(&mut self) -> *mut seal_SEAL_BYTE {
        seal_util_MemoryPoolItem_data(self)
    }
    #[inline]
    pub unsafe fn data1(&self) -> *const seal_SEAL_BYTE {
        seal_util_MemoryPoolItem_data1(self)
    }
    #[inline]
    pub unsafe fn next(&mut self) -> *mut *mut seal_util_MemoryPoolItem {
        seal_util_MemoryPoolItem_next(self)
    }
    #[inline]
    pub unsafe fn next1(&self) -> *const seal_util_MemoryPoolItem {
        seal_util_MemoryPoolItem_next1(self)
    }
    #[inline]
    pub unsafe fn new(data: *mut seal_SEAL_BYTE) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolItem_MemoryPoolItem(&mut __bindgen_tmp, data);
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct seal_util_MemoryPoolHead__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolHead {
    pub vtable_: *const seal_util_MemoryPoolHead__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seal_util_MemoryPoolHead_allocation {
    pub size: usize,
    pub data_ptr: *mut seal_SEAL_BYTE,
    pub free: usize,
    pub head_ptr: *mut seal_SEAL_BYTE,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHead_allocation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHead_allocation>(),
        32usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHead_allocation))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHead_allocation>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(seal_util_MemoryPoolHead_allocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).data_ptr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(data_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).free as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHead_allocation>())).head_ptr as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHead_allocation),
            "::",
            stringify!(head_ptr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolHead10allocationC1Ev"]
    pub fn seal_util_MemoryPoolHead_allocation_allocation(
        this: *mut seal_util_MemoryPoolHead_allocation,
    );
}
impl Default for seal_util_MemoryPoolHead_allocation {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolHead_allocation {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolHead_allocation_allocation(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHead() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHead>(),
        8usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHead))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHead>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolHead))
    );
}
impl Default for seal_util_MemoryPoolHead {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14MemoryPoolHeadD1Ev"]
    pub fn seal_util_MemoryPoolHead_MemoryPoolHead_destructor(this: *mut seal_util_MemoryPoolHead);
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolHeadMT {
    pub _base: seal_util_MemoryPoolHead,
    pub clear_on_destruction_: bool,
    pub locked_: u8,
    pub item_byte_count_: usize,
    pub item_count_: usize,
    pub allocs_: [u64; 3usize],
    pub first_item_: *mut seal_util_MemoryPoolItem,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHeadMT() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHeadMT>(),
        64usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHeadMT))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHeadMT>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolHeadMT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).locked_ as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(locked_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).item_byte_count_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(item_byte_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).item_count_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(item_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).allocs_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(allocs_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadMT>())).first_item_ as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadMT),
            "::",
            stringify!(first_item_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMTC1Emb"]
    pub fn seal_util_MemoryPoolHeadMT_MemoryPoolHeadMT(
        this: *mut seal_util_MemoryPoolHeadMT,
        item_byte_count: usize,
        clear_on_destruction: bool,
    );
}
impl Default for seal_util_MemoryPoolHeadMT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolHeadMT {
    #[inline]
    pub unsafe fn new(item_byte_count: usize, clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolHeadMT_MemoryPoolHeadMT(
            &mut __bindgen_tmp,
            item_byte_count,
            clear_on_destruction,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMTD1Ev"]
    pub fn seal_util_MemoryPoolHeadMT_MemoryPoolHeadMT_destructor(
        this: *mut seal_util_MemoryPoolHeadMT,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadMT15item_byte_countEv"]
    pub fn seal_util_MemoryPoolHeadMT_item_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadMT10item_countEv"]
    pub fn seal_util_MemoryPoolHeadMT_item_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMT3getEv"]
    pub fn seal_util_MemoryPoolHeadMT_get(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadMT3addEPNS0_14MemoryPoolItemE"]
    pub fn seal_util_MemoryPoolHeadMT_add(
        this: *mut ::std::os::raw::c_void,
        new_first: *mut seal_util_MemoryPoolItem,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolHeadST {
    pub _base: seal_util_MemoryPoolHead,
    pub clear_on_destruction_: bool,
    pub item_byte_count_: usize,
    pub item_count_: usize,
    pub allocs_: [u64; 3usize],
    pub first_item_: *mut seal_util_MemoryPoolItem,
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolHeadST() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolHeadST>(),
        64usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolHeadST))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolHeadST>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolHeadST))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).item_byte_count_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(item_byte_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).item_count_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(item_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).allocs_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(allocs_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolHeadST>())).first_item_ as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolHeadST),
            "::",
            stringify!(first_item_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadSTC1Emb"]
    pub fn seal_util_MemoryPoolHeadST_MemoryPoolHeadST(
        this: *mut seal_util_MemoryPoolHeadST,
        item_byte_count: usize,
        clear_on_destruction: bool,
    );
}
impl Default for seal_util_MemoryPoolHeadST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolHeadST {
    #[inline]
    pub unsafe fn new(item_byte_count: usize, clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolHeadST_MemoryPoolHeadST(
            &mut __bindgen_tmp,
            item_byte_count,
            clear_on_destruction,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadSTD1Ev"]
    pub fn seal_util_MemoryPoolHeadST_MemoryPoolHeadST_destructor(
        this: *mut seal_util_MemoryPoolHeadST,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadST15item_byte_countEv"]
    pub fn seal_util_MemoryPoolHeadST_item_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util16MemoryPoolHeadST10item_countEv"]
    pub fn seal_util_MemoryPoolHeadST_item_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadST3getEv"]
    pub fn seal_util_MemoryPoolHeadST_get(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut seal_util_MemoryPoolItem;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16MemoryPoolHeadST3addEPNS0_14MemoryPoolItemE"]
    pub fn seal_util_MemoryPoolHeadST_add(
        this: *mut ::std::os::raw::c_void,
        new_first: *mut seal_util_MemoryPoolItem,
    );
}
#[repr(C)]
pub struct seal_util_MemoryPool__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPool {
    pub vtable_: *const seal_util_MemoryPool__bindgen_vtable,
}
pub const seal_util_MemoryPool_alloc_size_multiplier: f64 = 1.05;
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPool27max_single_alloc_byte_countE"]
    pub static mut seal_util_MemoryPool_max_single_alloc_byte_count: usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPool19max_pool_head_countE"]
    pub static mut seal_util_MemoryPool_max_pool_head_count: usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPool26max_batch_alloc_byte_countE"]
    pub static mut seal_util_MemoryPool_max_batch_alloc_byte_count: usize;
}
pub const seal_util_MemoryPool_first_alloc_count: usize = 1;
#[test]
fn bindgen_test_layout_seal_util_MemoryPool() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPool>(),
        8usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPool))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPool>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPool))
    );
}
impl Default for seal_util_MemoryPool {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util10MemoryPoolD1Ev"]
    pub fn seal_util_MemoryPool_MemoryPool_destructor(this: *mut seal_util_MemoryPool);
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolMT {
    pub _base: seal_util_MemoryPool,
    pub clear_on_destruction_: bool,
    pub pools_locker_: seal_util_ReaderWriterLocker,
    pub pools_: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolMT() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolMT>(),
        96usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolMT))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolMT>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolMT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolMT>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolMT),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolMT>())).pools_locker_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolMT),
            "::",
            stringify!(pools_locker_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolMT>())).pools_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolMT),
            "::",
            stringify!(pools_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMTC1Eb"]
    pub fn seal_util_MemoryPoolMT_MemoryPoolMT(
        this: *mut seal_util_MemoryPoolMT,
        clear_on_destruction: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMTC1ERKS1_"]
    pub fn seal_util_MemoryPoolMT_MemoryPoolMT1(
        this: *mut seal_util_MemoryPoolMT,
        copy: *const seal_util_MemoryPoolMT,
    );
}
impl Default for seal_util_MemoryPoolMT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolMT {
    #[inline]
    pub unsafe fn new(clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolMT_MemoryPoolMT(&mut __bindgen_tmp, clear_on_destruction);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_util_MemoryPoolMT) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolMT_MemoryPoolMT1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMTD1Ev"]
    pub fn seal_util_MemoryPoolMT_MemoryPoolMT_destructor(this: *mut seal_util_MemoryPoolMT);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolMT18get_for_byte_countEm"]
    pub fn seal_util_MemoryPoolMT_get_for_byte_count(
        this: *mut ::std::os::raw::c_void,
        byte_count: usize,
    ) -> seal_util_Pointer<seal_SEAL_BYTE>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolMT10pool_countEv"]
    pub fn seal_util_MemoryPoolMT_pool_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolMT16alloc_byte_countEv"]
    pub fn seal_util_MemoryPoolMT_alloc_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_MemoryPoolST {
    pub _base: seal_util_MemoryPool,
    pub clear_on_destruction_: bool,
    pub pools_: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_seal_util_MemoryPoolST() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_MemoryPoolST>(),
        40usize,
        concat!("Size of: ", stringify!(seal_util_MemoryPoolST))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_MemoryPoolST>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_MemoryPoolST))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_MemoryPoolST>())).clear_on_destruction_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolST),
            "::",
            stringify!(clear_on_destruction_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_MemoryPoolST>())).pools_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_MemoryPoolST),
            "::",
            stringify!(pools_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolSTC1Eb"]
    pub fn seal_util_MemoryPoolST_MemoryPoolST(
        this: *mut seal_util_MemoryPoolST,
        clear_on_destruction: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolSTC1ERKS1_"]
    pub fn seal_util_MemoryPoolST_MemoryPoolST1(
        this: *mut seal_util_MemoryPoolST,
        copy: *const seal_util_MemoryPoolST,
    );
}
impl Default for seal_util_MemoryPoolST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_MemoryPoolST {
    #[inline]
    pub unsafe fn new(clear_on_destruction: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolST_MemoryPoolST(&mut __bindgen_tmp, clear_on_destruction);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_util_MemoryPoolST) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_MemoryPoolST_MemoryPoolST1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolSTD1Ev"]
    pub fn seal_util_MemoryPoolST_MemoryPoolST_destructor(this: *mut seal_util_MemoryPoolST);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12MemoryPoolST18get_for_byte_countEm"]
    pub fn seal_util_MemoryPoolST_get_for_byte_count(
        this: *mut ::std::os::raw::c_void,
        byte_count: usize,
    ) -> seal_util_Pointer<seal_SEAL_BYTE>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolST10pool_countEv"]
    pub fn seal_util_MemoryPoolST_pool_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util12MemoryPoolST16alloc_byte_countEv"]
    pub fn seal_util_MemoryPoolST_alloc_byte_count(this: *mut ::std::os::raw::c_void) -> usize;
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_Pointer<T> {
    pub data_: *mut T,
    pub head_: *mut seal_util_MemoryPoolHead,
    pub item_: *mut seal_util_MemoryPoolItem,
    pub alias_: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl<T> Default for seal_util_Pointer<T> {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn __bindgen_test_layout_seal_util_ConstPointer_open0_seal_SEAL_BYTE_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_ConstPointer<T> {
    pub data_: *mut T,
    pub head_: *mut seal_util_MemoryPoolHead,
    pub item_: *mut seal_util_MemoryPoolItem,
    pub alias_: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl<T> Default for seal_util_ConstPointer<T> {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18uint_to_hex_stringB5cxx11EPKmm"]
    pub fn seal_util_uint_to_hex_string(value: *const u64, uint64_count: usize) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18uint_to_dec_stringB5cxx11EPKmmRNS0_10MemoryPoolE"]
    pub fn seal_util_uint_to_dec_string(
        value: *const u64,
        uint64_count: usize,
        pool: *mut seal_util_MemoryPool,
    ) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18hex_string_to_uintEPKcimPm"]
    pub fn seal_util_hex_string_to_uint(
        hex_string: *const ::std::os::raw::c_char,
        char_count: ::std::os::raw::c_int,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13allocate_uintEmRNS0_10MemoryPoolE"]
    pub fn seal_util_allocate_uint(
        uint64_count: usize,
        pool: *mut seal_util_MemoryPool,
    ) -> seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13set_zero_uintEmPm"]
    pub fn seal_util_set_zero_uint(uint64_count: usize, result: *mut u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18allocate_zero_uintEmRNS0_10MemoryPoolE"]
    pub fn seal_util_allocate_zero_uint(
        uint64_count: usize,
        pool: *mut seal_util_MemoryPool,
    ) -> seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util8set_uintEmmPm"]
    pub fn seal_util_set_uint(value: u64, uint64_count: usize, result: *mut u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13set_uint_uintEPKmmPm"]
    pub fn seal_util_set_uint_uint(value: *const u64, uint64_count: usize, result: *mut u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12is_zero_uintEPKmm"]
    pub fn seal_util_is_zero_uint(value: *const u64, uint64_count: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13is_equal_uintEPKmmm"]
    pub fn seal_util_is_equal_uint(value: *const u64, uint64_count: usize, scalar: u64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util20is_high_bit_set_uintEPKmm"]
    pub fn seal_util_is_high_bit_set_uint(value: *const u64, uint64_count: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15is_bit_set_uintEPKmmi"]
    pub fn seal_util_is_bit_set_uint(
        value: *const u64,
        uint64_count: usize,
        bit_index: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12set_bit_uintEPmmi"]
    pub fn seal_util_set_bit_uint(
        value: *mut u64,
        uint64_count: usize,
        bit_index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util30get_significant_bit_count_uintEPKmm"]
    pub fn seal_util_get_significant_bit_count_uint(
        value: *const u64,
        uint64_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util33get_significant_uint64_count_uintEPKmm"]
    pub fn seal_util_get_significant_uint64_count_uint(
        value: *const u64,
        uint64_count: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13set_uint_uintEPKmmmPm"]
    pub fn seal_util_set_uint_uint1(
        value: *const u64,
        value_uint64_count: usize,
        result_uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16get_power_of_twoEm"]
    pub fn seal_util_get_power_of_two(value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util26get_power_of_two_minus_oneEm"]
    pub fn seal_util_get_power_of_two_minus_one(value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util21get_power_of_two_uintEPKmm"]
    pub fn seal_util_get_power_of_two_uint(
        operand: *const u64,
        uint64_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util31get_power_of_two_minus_one_uintEPKmm"]
    pub fn seal_util_get_power_of_two_minus_one_uint(
        operand: *const u64,
        uint64_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util20filter_highbits_uintEPmmi"]
    pub fn seal_util_filter_highbits_uint(
        operand: *mut u64,
        uint64_count: usize,
        bit_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util24duplicate_uint_if_neededEPKmmmbRNS0_10MemoryPoolE"]
    pub fn seal_util_duplicate_uint_if_needed(
        input: *const u64,
        uint64_count: usize,
        new_uint64_count: usize,
        force: bool,
        pool: *mut seal_util_MemoryPool,
    ) -> seal_util_ConstPointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util17compare_uint_uintEPKmS2_m"]
    pub fn seal_util_compare_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util17compare_uint_uintEPKmmS2_m"]
    pub fn seal_util_compare_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util25is_greater_than_uint_uintEPKmS2_m"]
    pub fn seal_util_is_greater_than_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util34is_greater_than_or_equal_uint_uintEPKmS2_m"]
    pub fn seal_util_is_greater_than_or_equal_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util22is_less_than_uint_uintEPKmS2_m"]
    pub fn seal_util_is_less_than_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util31is_less_than_or_equal_uint_uintEPKmS2_m"]
    pub fn seal_util_is_less_than_or_equal_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18is_equal_uint_uintEPKmS2_m"]
    pub fn seal_util_is_equal_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util22is_not_equal_uint_uintEPKmS2_m"]
    pub fn seal_util_is_not_equal_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util25is_greater_than_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_greater_than_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util34is_greater_than_or_equal_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_greater_than_or_equal_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util22is_less_than_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_less_than_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util31is_less_than_or_equal_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_less_than_or_equal_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18is_equal_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_equal_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util22is_not_equal_uint_uintEPKmmS2_m"]
    pub fn seal_util_is_not_equal_uint_uint1(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14hamming_weightEm"]
    pub fn seal_util_hamming_weight(value: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util20hamming_weight_splitEm"]
    pub fn seal_util_hamming_weight_split(value: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13add_uint_uintEPKmmS2_mhmPm"]
    pub fn seal_util_add_uint_uint(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
        carry: ::std::os::raw::c_uchar,
        result_uint64_count: usize,
        result: *mut u64,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13add_uint_uintEPKmS2_mPm"]
    pub fn seal_util_add_uint_uint1(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
        result: *mut u64,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15add_uint_uint64EPKmmmPm"]
    pub fn seal_util_add_uint_uint64(
        operand1: *const u64,
        operand2: u64,
        uint64_count: usize,
        result: *mut u64,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13sub_uint_uintEPKmmS2_mhmPm"]
    pub fn seal_util_sub_uint_uint(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
        borrow: ::std::os::raw::c_uchar,
        result_uint64_count: usize,
        result: *mut u64,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13sub_uint_uintEPKmS2_mPm"]
    pub fn seal_util_sub_uint_uint1(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
        result: *mut u64,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15sub_uint_uint64EPKmmmPm"]
    pub fn seal_util_sub_uint_uint64(
        operand1: *const u64,
        operand2: u64,
        uint64_count: usize,
        result: *mut u64,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14increment_uintEPKmmPm"]
    pub fn seal_util_increment_uint(
        operand: *const u64,
        uint64_count: usize,
        result: *mut u64,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14decrement_uintEPKmmPm"]
    pub fn seal_util_decrement_uint(
        operand: *const u64,
        uint64_count: usize,
        result: *mut u64,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util11negate_uintEPKmmPm"]
    pub fn seal_util_negate_uint(operand: *const u64, uint64_count: usize, result: *mut u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15left_shift_uintEPKmimPm"]
    pub fn seal_util_left_shift_uint(
        operand: *const u64,
        shift_amount: ::std::os::raw::c_int,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16right_shift_uintEPKmimPm"]
    pub fn seal_util_right_shift_uint(
        operand: *const u64,
        shift_amount: ::std::os::raw::c_int,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18half_round_up_uintEPKmmPm"]
    pub fn seal_util_half_round_up_uint(operand: *const u64, uint64_count: usize, result: *mut u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util8not_uintEPKmmPm"]
    pub fn seal_util_not_uint(operand: *const u64, uint64_count: usize, result: *mut u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13and_uint_uintEPKmS2_mPm"]
    pub fn seal_util_and_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12or_uint_uintEPKmS2_mPm"]
    pub fn seal_util_or_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13xor_uint_uintEPKmS2_mPm"]
    pub fn seal_util_xor_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18multiply_uint_uintEPKmmS2_mmPm"]
    pub fn seal_util_multiply_uint_uint(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: *const u64,
        operand2_uint64_count: usize,
        result_uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18multiply_uint_uintEPKmS2_mPm"]
    pub fn seal_util_multiply_uint_uint1(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util20multiply_uint_uint64EPKmmmmPm"]
    pub fn seal_util_multiply_uint_uint64(
        operand1: *const u64,
        operand1_uint64_count: usize,
        operand2: u64,
        result_uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util27multiply_truncate_uint_uintEPKmS2_mPm"]
    pub fn seal_util_multiply_truncate_uint_uint(
        operand1: *const u64,
        operand2: *const u64,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util24divide_uint_uint_inplaceEPmPKmmS1_RNS0_10MemoryPoolE"]
    pub fn seal_util_divide_uint_uint_inplace(
        numerator: *mut u64,
        denominator: *const u64,
        uint64_count: usize,
        quotient: *mut u64,
        pool: *mut seal_util_MemoryPool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util16divide_uint_uintEPKmS2_mPmS3_RNS0_10MemoryPoolE"]
    pub fn seal_util_divide_uint_uint(
        numerator: *const u64,
        denominator: *const u64,
        uint64_count: usize,
        quotient: *mut u64,
        remainder: *mut u64,
        pool: *mut seal_util_MemoryPool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util29divide_uint128_uint64_inplaceEPmmS1_"]
    pub fn seal_util_divide_uint128_uint64_inplace(
        numerator: *mut u64,
        denominator: u64,
        quotient: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util29divide_uint192_uint64_inplaceEPmmS1_"]
    pub fn seal_util_divide_uint192_uint64_inplace(
        numerator: *mut u64,
        denominator: u64,
        quotient: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util17exponentiate_uintEPKmmS2_mmPmRNS0_10MemoryPoolE"]
    pub fn seal_util_exponentiate_uint(
        operand: *const u64,
        operand_uint64_count: usize,
        exponent: *const u64,
        exponent_uint64_count: usize,
        result_uint64_count: usize,
        result: *mut u64,
        pool: *mut seal_util_MemoryPool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util24exponentiate_uint64_safeEmm"]
    pub fn seal_util_exponentiate_uint64_safe(operand: u64, exponent: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util19exponentiate_uint64Emm"]
    pub fn seal_util_exponentiate_uint64(operand: u64, exponent: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18increment_uint_modEPKmS2_mPm"]
    pub fn seal_util_increment_uint_mod(
        operand: *const u64,
        modulus: *const u64,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18decrement_uint_modEPKmS2_mPm"]
    pub fn seal_util_decrement_uint_mod(
        operand: *const u64,
        modulus: *const u64,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15negate_uint_modEPKmS2_mPm"]
    pub fn seal_util_negate_uint_mod(
        operand: *const u64,
        modulus: *const u64,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13div2_uint_modEPKmS2_mPm"]
    pub fn seal_util_div2_uint_mod(
        operand: *const u64,
        modulus: *const u64,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util17add_uint_uint_modEPKmS2_S2_mPm"]
    pub fn seal_util_add_uint_uint_mod(
        operand1: *const u64,
        operand2: *const u64,
        modulus: *const u64,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util17sub_uint_uint_modEPKmS2_S2_mPm"]
    pub fn seal_util_sub_uint_uint_mod(
        operand1: *const u64,
        operand2: *const u64,
        modulus: *const u64,
        uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util19try_invert_uint_modEPKmS2_mPmRNS0_10MemoryPoolE"]
    pub fn seal_util_try_invert_uint_mod(
        operand: *const u64,
        modulus: *const u64,
        uint64_count: usize,
        result: *mut u64,
        pool: *mut seal_util_MemoryPool,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_util_HashFunction {
    pub _address: u8,
}
pub type seal_util_HashFunction_sha3_block_type = [u64; 4usize];
pub type seal_util_HashFunction_sha3_state_type = [[u64; 5usize]; 5usize];
pub const seal_util_HashFunction_sha3_block_uint64_count: usize = 4;
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunction15sha3_zero_blockE"]
    pub static mut seal_util_HashFunction_sha3_zero_block: seal_util_HashFunction_sha3_block_type;
}
pub const seal_util_HashFunction_sha3_round_count: u8 = 24;
pub const seal_util_HashFunction_sha3_rate_uint64_count: u8 = 17;
pub const seal_util_HashFunction_sha3_capacity_uint64_count: u8 = 8;
pub const seal_util_HashFunction_sha3_state_uint64_count: u8 = 25;
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunction8sha3_rhoE"]
    pub static mut seal_util_HashFunction_sha3_rho: [u8; 24usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunction17sha3_round_constsE"]
    pub static mut seal_util_HashFunction_sha3_round_consts: [u64; 24usize];
}
#[test]
fn bindgen_test_layout_seal_util_HashFunction() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_HashFunction>(),
        1usize,
        concat!("Size of: ", stringify!(seal_util_HashFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_HashFunction>(),
        1usize,
        concat!("Alignment of ", stringify!(seal_util_HashFunction))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunction9sha3_hashEPKmmRSt5arrayImLm4EE"]
    pub fn seal_util_HashFunction_sha3_hash(
        input: *const u64,
        uint64_count: usize,
        destination: *mut seal_util_HashFunction_sha3_block_type,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunction9sha3_hashEmRSt5arrayImLm4EE"]
    pub fn seal_util_HashFunction_sha3_hash1(
        input: u64,
        destination: *mut seal_util_HashFunction_sha3_block_type,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12HashFunctionC1Ev"]
    pub fn seal_util_HashFunction_HashFunction(this: *mut seal_util_HashFunction);
}
impl seal_util_HashFunction {
    #[inline]
    pub unsafe fn sha3_hash(
        input: *const u64,
        uint64_count: usize,
        destination: *mut seal_util_HashFunction_sha3_block_type,
    ) {
        seal_util_HashFunction_sha3_hash(input, uint64_count, destination)
    }
    #[inline]
    pub unsafe fn sha3_hash1(input: u64, destination: *mut seal_util_HashFunction_sha3_block_type) {
        seal_util_HashFunction_sha3_hash1(input, destination)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_HashFunction_HashFunction(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_SmallNTTTables {
    pub pool_: seal_MemoryPoolHandle,
    pub generated_: bool,
    pub root_: u64,
    pub root_powers_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub scaled_root_powers_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub inv_root_powers_div_two_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub scaled_inv_root_powers_div_two_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub coeff_count_power_: ::std::os::raw::c_int,
    pub coeff_count_: usize,
    pub modulus_: seal_util_global_variables_internal_mods_SmallModulus,
    pub inv_root_powers_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub scaled_inv_root_powers_: seal_util_Pointer<::std::os::raw::c_ulong>,
    pub inv_degree_modulo_: u64,
}
#[test]
fn bindgen_test_layout_seal_util_SmallNTTTables() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_SmallNTTTables>(),
        296usize,
        concat!("Size of: ", stringify!(seal_util_SmallNTTTables))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_SmallNTTTables>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_SmallNTTTables))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).generated_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(generated_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).root_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(root_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).root_powers_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(root_powers_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).scaled_root_powers_ as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(scaled_root_powers_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).inv_root_powers_div_two_
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(inv_root_powers_div_two_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).scaled_inv_root_powers_div_two_
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(scaled_inv_root_powers_div_two_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).coeff_count_power_ as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(coeff_count_power_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).coeff_count_ as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(coeff_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).modulus_ as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(modulus_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).inv_root_powers_ as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(inv_root_powers_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).scaled_inv_root_powers_ as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(scaled_inv_root_powers_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_SmallNTTTables>())).inv_degree_modulo_ as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_SmallNTTTables),
            "::",
            stringify!(inv_degree_modulo_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables12is_generatedEv"]
    pub fn seal_util_SmallNTTTables_is_generated(this: *const seal_util_SmallNTTTables) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14SmallNTTTables8generateEiRKNS_12SmallModulusE"]
    pub fn seal_util_SmallNTTTables_generate(
        this: *mut seal_util_SmallNTTTables,
        coeff_count_power: ::std::os::raw::c_int,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14SmallNTTTables5resetEv"]
    pub fn seal_util_SmallNTTTables_reset(this: *mut seal_util_SmallNTTTables);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables8get_rootEv"]
    pub fn seal_util_SmallNTTTables_get_root(this: *const seal_util_SmallNTTTables) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables20get_from_root_powersEm"]
    pub fn seal_util_SmallNTTTables_get_from_root_powers(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables27get_from_scaled_root_powersEm"]
    pub fn seal_util_SmallNTTTables_get_from_scaled_root_powers(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables24get_from_inv_root_powersEm"]
    pub fn seal_util_SmallNTTTables_get_from_inv_root_powers(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables31get_from_scaled_inv_root_powersEm"]
    pub fn seal_util_SmallNTTTables_get_from_scaled_inv_root_powers(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables32get_from_inv_root_powers_div_twoEm"]
    pub fn seal_util_SmallNTTTables_get_from_inv_root_powers_div_two(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables39get_from_scaled_inv_root_powers_div_twoEm"]
    pub fn seal_util_SmallNTTTables_get_from_scaled_inv_root_powers_div_two(
        this: *const seal_util_SmallNTTTables,
        index: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables21get_inv_degree_moduloEv"]
    pub fn seal_util_SmallNTTTables_get_inv_degree_modulo(
        this: *const seal_util_SmallNTTTables,
    ) -> *const u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables7modulusEv"]
    pub fn seal_util_SmallNTTTables_modulus(
        this: *const seal_util_SmallNTTTables,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables17coeff_count_powerEv"]
    pub fn seal_util_SmallNTTTables_coeff_count_power(
        this: *const seal_util_SmallNTTTables,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util14SmallNTTTables11coeff_countEv"]
    pub fn seal_util_SmallNTTTables_coeff_count(this: *const seal_util_SmallNTTTables) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14SmallNTTTablesC1ENS_16MemoryPoolHandleE"]
    pub fn seal_util_SmallNTTTables_SmallNTTTables(
        this: *mut seal_util_SmallNTTTables,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14SmallNTTTablesC1EiRKNS_12SmallModulusENS_16MemoryPoolHandleE"]
    pub fn seal_util_SmallNTTTables_SmallNTTTables1(
        this: *mut seal_util_SmallNTTTables,
        coeff_count_power: ::std::os::raw::c_int,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        pool: seal_MemoryPoolHandle,
    );
}
impl Default for seal_util_SmallNTTTables {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_SmallNTTTables {
    #[inline]
    pub unsafe fn is_generated(&self) -> bool {
        seal_util_SmallNTTTables_is_generated(self)
    }
    #[inline]
    pub unsafe fn generate(
        &mut self,
        coeff_count_power: ::std::os::raw::c_int,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> bool {
        seal_util_SmallNTTTables_generate(self, coeff_count_power, modulus)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        seal_util_SmallNTTTables_reset(self)
    }
    #[inline]
    pub unsafe fn get_root(&self) -> u64 {
        seal_util_SmallNTTTables_get_root(self)
    }
    #[inline]
    pub unsafe fn get_from_root_powers(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_root_powers(self, index)
    }
    #[inline]
    pub unsafe fn get_from_scaled_root_powers(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_scaled_root_powers(self, index)
    }
    #[inline]
    pub unsafe fn get_from_inv_root_powers(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_inv_root_powers(self, index)
    }
    #[inline]
    pub unsafe fn get_from_scaled_inv_root_powers(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_scaled_inv_root_powers(self, index)
    }
    #[inline]
    pub unsafe fn get_from_inv_root_powers_div_two(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_inv_root_powers_div_two(self, index)
    }
    #[inline]
    pub unsafe fn get_from_scaled_inv_root_powers_div_two(&self, index: usize) -> u64 {
        seal_util_SmallNTTTables_get_from_scaled_inv_root_powers_div_two(self, index)
    }
    #[inline]
    pub unsafe fn get_inv_degree_modulo(&self) -> *const u64 {
        seal_util_SmallNTTTables_get_inv_degree_modulo(self)
    }
    #[inline]
    pub unsafe fn modulus(&self) -> *const seal_util_global_variables_internal_mods_SmallModulus {
        seal_util_SmallNTTTables_modulus(self)
    }
    #[inline]
    pub unsafe fn coeff_count_power(&self) -> ::std::os::raw::c_int {
        seal_util_SmallNTTTables_coeff_count_power(self)
    }
    #[inline]
    pub unsafe fn coeff_count(&self) -> usize {
        seal_util_SmallNTTTables_coeff_count(self)
    }
    #[inline]
    pub unsafe fn new(pool: seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_SmallNTTTables_SmallNTTTables(&mut __bindgen_tmp, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        coeff_count_power: ::std::os::raw::c_int,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        pool: seal_MemoryPoolHandle,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_SmallNTTTables_SmallNTTTables1(
            &mut __bindgen_tmp,
            coeff_count_power,
            modulus,
            pool,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util26ntt_negacyclic_harvey_lazyEPmRKNS0_14SmallNTTTablesE"]
    pub fn seal_util_ntt_negacyclic_harvey_lazy(
        operand: *mut u64,
        tables: *const seal_util_SmallNTTTables,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util21ntt_negacyclic_harveyEPmRKNS0_14SmallNTTTablesE"]
    pub fn seal_util_ntt_negacyclic_harvey(
        operand: *mut u64,
        tables: *const seal_util_SmallNTTTables,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util34inverse_ntt_negacyclic_harvey_lazyEPmRKNS0_14SmallNTTTablesE"]
    pub fn seal_util_inverse_ntt_negacyclic_harvey_lazy(
        operand: *mut u64,
        tables: *const seal_util_SmallNTTTables,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util29inverse_ntt_negacyclic_harveyEPmRKNS0_14SmallNTTTablesE"]
    pub fn seal_util_inverse_ntt_negacyclic_harvey(
        operand: *mut u64,
        tables: *const seal_util_SmallNTTTables,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_util_BaseConverter {
    pub pool_: seal_MemoryPoolHandle,
    pub generated_: bool,
    pub coeff_base_mod_count_: usize,
    pub aux_base_mod_count_: usize,
    pub bsk_base_mod_count_: usize,
    pub coeff_count_: usize,
    pub plain_gamma_count_: usize,
    pub coeff_base_array_: seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
    pub aux_base_array_: seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
    pub bsk_base_array_: seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
    pub plain_gamma_array_:
        seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
    pub coeff_products_array_: seal_util_Pointer<u64>,
    pub coeff_base_products_mod_aux_bsk_array_: seal_util_Pointer<seal_util_Pointer<u64>>,
    pub inv_coeff_base_products_mod_coeff_array_: seal_util_Pointer<u64>,
    pub coeff_base_products_mod_mtilde_array_: seal_util_Pointer<u64>,
    pub mtilde_inv_coeff_base_products_mod_coeff_array_: seal_util_Pointer<u64>,
    pub inv_coeff_products_all_mod_aux_bsk_array_: seal_util_Pointer<u64>,
    pub aux_base_products_mod_coeff_array_: seal_util_Pointer<seal_util_Pointer<u64>>,
    pub inv_aux_base_products_mod_aux_array_: seal_util_Pointer<u64>,
    pub aux_base_products_mod_msk_array_: seal_util_Pointer<u64>,
    pub inv_coeff_products_mod_mtilde_: u64,
    pub inv_aux_products_mod_msk_: u64,
    pub inv_gamma_mod_plain_: u64,
    pub aux_products_all_mod_coeff_array_: seal_util_Pointer<u64>,
    pub inv_mtilde_mod_bsk_array_: seal_util_Pointer<u64>,
    pub coeff_products_all_mod_bsk_array_: seal_util_Pointer<u64>,
    pub coeff_products_mod_plain_gamma_array_: seal_util_Pointer<seal_util_Pointer<u64>>,
    pub neg_inv_coeff_products_all_mod_plain_gamma_array_: seal_util_Pointer<u64>,
    pub plain_gamma_product_mod_coeff_array_: seal_util_Pointer<u64>,
    pub bsk_small_ntt_tables_: seal_util_Pointer<seal_util_SmallNTTTables>,
    pub inv_last_coeff_mod_array_: seal_util_Pointer<u64>,
    pub m_tilde_: seal_util_global_variables_internal_mods_SmallModulus,
    pub m_sk_: seal_util_global_variables_internal_mods_SmallModulus,
    pub small_plain_mod_: seal_util_global_variables_internal_mods_SmallModulus,
    pub gamma_: seal_util_global_variables_internal_mods_SmallModulus,
}
#[test]
fn bindgen_test_layout_seal_util_BaseConverter() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_BaseConverter>(),
        952usize,
        concat!("Size of: ", stringify!(seal_util_BaseConverter))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_BaseConverter>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_util_BaseConverter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_BaseConverter>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).generated_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(generated_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).coeff_base_mod_count_ as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(coeff_base_mod_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).aux_base_mod_count_ as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(aux_base_mod_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).bsk_base_mod_count_ as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(bsk_base_mod_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).coeff_count_ as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(coeff_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).plain_gamma_count_ as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(plain_gamma_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).coeff_base_array_ as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(coeff_base_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).aux_base_array_ as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(aux_base_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).bsk_base_array_ as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(bsk_base_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).plain_gamma_array_ as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(plain_gamma_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).coeff_products_array_ as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(coeff_products_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>()))
                .coeff_base_products_mod_aux_bsk_array_ as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(coeff_base_products_mod_aux_bsk_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>()))
                .inv_coeff_base_products_mod_coeff_array_ as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(inv_coeff_base_products_mod_coeff_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>()))
                .coeff_base_products_mod_mtilde_array_ as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(coeff_base_products_mod_mtilde_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>()))
                .mtilde_inv_coeff_base_products_mod_coeff_array_ as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(mtilde_inv_coeff_base_products_mod_coeff_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>()))
                .inv_coeff_products_all_mod_aux_bsk_array_ as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(inv_coeff_products_all_mod_aux_bsk_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).aux_base_products_mod_coeff_array_
                as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(aux_base_products_mod_coeff_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).inv_aux_base_products_mod_aux_array_
                as *const _ as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(inv_aux_base_products_mod_aux_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).aux_base_products_mod_msk_array_
                as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(aux_base_products_mod_msk_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).inv_coeff_products_mod_mtilde_
                as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(inv_coeff_products_mod_mtilde_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).inv_aux_products_mod_msk_
                as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(inv_aux_products_mod_msk_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).inv_gamma_mod_plain_ as *const _
                as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(inv_gamma_mod_plain_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).aux_products_all_mod_coeff_array_
                as *const _ as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(aux_products_all_mod_coeff_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).inv_mtilde_mod_bsk_array_
                as *const _ as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(inv_mtilde_mod_bsk_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).coeff_products_all_mod_bsk_array_
                as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(coeff_products_all_mod_bsk_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>()))
                .coeff_products_mod_plain_gamma_array_ as *const _ as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(coeff_products_mod_plain_gamma_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>()))
                .neg_inv_coeff_products_all_mod_plain_gamma_array_ as *const _ as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(neg_inv_coeff_products_all_mod_plain_gamma_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).plain_gamma_product_mod_coeff_array_
                as *const _ as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(plain_gamma_product_mod_coeff_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).bsk_small_ntt_tables_ as *const _
                as usize
        },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(bsk_small_ntt_tables_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).inv_last_coeff_mod_array_
                as *const _ as usize
        },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(inv_last_coeff_mod_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).m_tilde_ as *const _ as usize
        },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(m_tilde_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_BaseConverter>())).m_sk_ as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(m_sk_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_util_BaseConverter>())).small_plain_mod_ as *const _
                as usize
        },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(small_plain_mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_util_BaseConverter>())).gamma_ as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_util_BaseConverter),
            "::",
            stringify!(gamma_)
        )
    );
}
extern "C" {
    ///Generates the pre-computations for the given parameters.
    #[link_name = "\u{1}_ZN4seal4util13BaseConverter8generateERKSt6vectorINS_12SmallModulusESaIS3_EEmRKS3_"]
    pub fn seal_util_BaseConverter_generate(
        this: *mut seal_util_BaseConverter,
        coeff_base: *const [u64; 3usize],
        coeff_count: usize,
        small_plain_mod: *const seal_util_global_variables_internal_mods_SmallModulus,
    );
}
extern "C" {
    ///Fast base converter from q to Bsk
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter9fastbconvEPKmPmNS_16MemoryPoolHandleE"]
    pub fn seal_util_BaseConverter_fastbconv(
        this: *const seal_util_BaseConverter,
        input: *const u64,
        destination: *mut u64,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Fast base converter from Bsk to q
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter12fastbconv_skEPKmPmNS_16MemoryPoolHandleE"]
    pub fn seal_util_BaseConverter_fastbconv_sk(
        this: *const seal_util_BaseConverter,
        input: *const u64,
        destination: *mut u64,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Reduction from Bsk U {m_tilde} to Bsk
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter7mont_rqEPKmPm"]
    pub fn seal_util_BaseConverter_mont_rq(
        this: *const seal_util_BaseConverter,
        input: *const u64,
        destination: *mut u64,
    );
}
extern "C" {
    ///Fast base converter from q U Bsk to Bsk
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter10fast_floorEPKmPmNS_16MemoryPoolHandleE"]
    pub fn seal_util_BaseConverter_fast_floor(
        this: *const seal_util_BaseConverter,
        input: *const u64,
        destination: *mut u64,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Fast base converter from q to Bsk U {m_tilde}
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter16fastbconv_mtildeEPKmPmNS_16MemoryPoolHandleE"]
    pub fn seal_util_BaseConverter_fastbconv_mtilde(
        this: *const seal_util_BaseConverter,
        input: *const u64,
        destination: *mut u64,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Fast base converter from q to plain_modulus U {gamma}
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter21fastbconv_plain_gammaEPKmPmNS_16MemoryPoolHandleE"]
    pub fn seal_util_BaseConverter_fastbconv_plain_gamma(
        this: *const seal_util_BaseConverter,
        input: *const u64,
        destination: *mut u64,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13BaseConverter5resetEv"]
    pub fn seal_util_BaseConverter_reset(this: *mut seal_util_BaseConverter);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter12is_generatedEv"]
    pub fn seal_util_BaseConverter_is_generated(this: *const seal_util_BaseConverter) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter20coeff_base_mod_countEv"]
    pub fn seal_util_BaseConverter_coeff_base_mod_count(
        this: *const seal_util_BaseConverter,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter18aux_base_mod_countEv"]
    pub fn seal_util_BaseConverter_aux_base_mod_count(
        this: *const seal_util_BaseConverter,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter23get_plain_gamma_productEv"]
    pub fn seal_util_BaseConverter_get_plain_gamma_product(
        this: *const seal_util_BaseConverter,
    ) -> *mut seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter17get_neg_inv_coeffEv"]
    pub fn seal_util_BaseConverter_get_neg_inv_coeff(
        this: *const seal_util_BaseConverter,
    ) -> *mut seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter21get_plain_gamma_arrayEv"]
    pub fn seal_util_BaseConverter_get_plain_gamma_array(
        this: *const seal_util_BaseConverter,
    ) -> *mut seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter24get_coeff_products_arrayEv"]
    pub fn seal_util_BaseConverter_get_coeff_products_array(
        this: *const seal_util_BaseConverter,
    ) -> *const u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter13get_inv_gammaEv"]
    pub fn seal_util_BaseConverter_get_inv_gamma(this: *const seal_util_BaseConverter) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter24get_bsk_small_ntt_tablesEv"]
    pub fn seal_util_BaseConverter_get_bsk_small_ntt_tables(
        this: *const seal_util_BaseConverter,
    ) -> *mut seal_util_Pointer<seal_util_SmallNTTTables>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter18bsk_base_mod_countEv"]
    pub fn seal_util_BaseConverter_bsk_base_mod_count(
        this: *const seal_util_BaseConverter,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter17get_bsk_mod_arrayEv"]
    pub fn seal_util_BaseConverter_get_bsk_mod_array(
        this: *const seal_util_BaseConverter,
    ) -> *mut seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter7get_mskEv"]
    pub fn seal_util_BaseConverter_get_msk(
        this: *const seal_util_BaseConverter,
    ) -> *mut seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter11get_m_tildeEv"]
    pub fn seal_util_BaseConverter_get_m_tilde(
        this: *const seal_util_BaseConverter,
    ) -> *mut seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter39get_mtilde_inv_coeff_products_mod_coeffEv"]
    pub fn seal_util_BaseConverter_get_mtilde_inv_coeff_products_mod_coeff(
        this: *const seal_util_BaseConverter,
    ) -> *mut seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter24get_inv_coeff_mod_mtildeEv"]
    pub fn seal_util_BaseConverter_get_inv_coeff_mod_mtilde(
        this: *const seal_util_BaseConverter,
    ) -> *const ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter29get_inv_coeff_mod_coeff_arrayEv"]
    pub fn seal_util_BaseConverter_get_inv_coeff_mod_coeff_array(
        this: *const seal_util_BaseConverter,
    ) -> *mut seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter28get_inv_last_coeff_mod_arrayEv"]
    pub fn seal_util_BaseConverter_get_inv_last_coeff_mod_array(
        this: *const seal_util_BaseConverter,
    ) -> *mut seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal4util13BaseConverter31get_coeff_base_products_mod_mskEv"]
    pub fn seal_util_BaseConverter_get_coeff_base_products_mod_msk(
        this: *const seal_util_BaseConverter,
    ) -> *mut seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13BaseConverterC1ENS_16MemoryPoolHandleE"]
    pub fn seal_util_BaseConverter_BaseConverter(
        this: *mut seal_util_BaseConverter,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13BaseConverterC1ERKSt6vectorINS_12SmallModulusESaIS3_EEmRKS3_NS_16MemoryPoolHandleE"]
    pub fn seal_util_BaseConverter_BaseConverter1(
        this: *mut seal_util_BaseConverter,
        coeff_base: *const [u64; 3usize],
        coeff_count: usize,
        small_plain_mod: *const seal_util_global_variables_internal_mods_SmallModulus,
        pool: seal_MemoryPoolHandle,
    );
}
impl Default for seal_util_BaseConverter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_util_BaseConverter {
    #[inline]
    pub unsafe fn generate(
        &mut self,
        coeff_base: *const [u64; 3usize],
        coeff_count: usize,
        small_plain_mod: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) {
        seal_util_BaseConverter_generate(self, coeff_base, coeff_count, small_plain_mod)
    }
    #[inline]
    pub unsafe fn fastbconv(
        &self,
        input: *const u64,
        destination: *mut u64,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_util_BaseConverter_fastbconv(self, input, destination, pool)
    }
    #[inline]
    pub unsafe fn fastbconv_sk(
        &self,
        input: *const u64,
        destination: *mut u64,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_util_BaseConverter_fastbconv_sk(self, input, destination, pool)
    }
    #[inline]
    pub unsafe fn mont_rq(&self, input: *const u64, destination: *mut u64) {
        seal_util_BaseConverter_mont_rq(self, input, destination)
    }
    #[inline]
    pub unsafe fn fast_floor(
        &self,
        input: *const u64,
        destination: *mut u64,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_util_BaseConverter_fast_floor(self, input, destination, pool)
    }
    #[inline]
    pub unsafe fn fastbconv_mtilde(
        &self,
        input: *const u64,
        destination: *mut u64,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_util_BaseConverter_fastbconv_mtilde(self, input, destination, pool)
    }
    #[inline]
    pub unsafe fn fastbconv_plain_gamma(
        &self,
        input: *const u64,
        destination: *mut u64,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_util_BaseConverter_fastbconv_plain_gamma(self, input, destination, pool)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        seal_util_BaseConverter_reset(self)
    }
    #[inline]
    pub unsafe fn is_generated(&self) -> bool {
        seal_util_BaseConverter_is_generated(self)
    }
    #[inline]
    pub unsafe fn coeff_base_mod_count(&self) -> ::std::os::raw::c_ulong {
        seal_util_BaseConverter_coeff_base_mod_count(self)
    }
    #[inline]
    pub unsafe fn aux_base_mod_count(&self) -> ::std::os::raw::c_ulong {
        seal_util_BaseConverter_aux_base_mod_count(self)
    }
    #[inline]
    pub unsafe fn get_plain_gamma_product(
        &self,
    ) -> *mut seal_util_Pointer<::std::os::raw::c_ulong> {
        seal_util_BaseConverter_get_plain_gamma_product(self)
    }
    #[inline]
    pub unsafe fn get_neg_inv_coeff(&self) -> *mut seal_util_Pointer<::std::os::raw::c_ulong> {
        seal_util_BaseConverter_get_neg_inv_coeff(self)
    }
    #[inline]
    pub unsafe fn get_plain_gamma_array(
        &self,
    ) -> *mut seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus> {
        seal_util_BaseConverter_get_plain_gamma_array(self)
    }
    #[inline]
    pub unsafe fn get_coeff_products_array(&self) -> *const u64 {
        seal_util_BaseConverter_get_coeff_products_array(self)
    }
    #[inline]
    pub unsafe fn get_inv_gamma(&self) -> u64 {
        seal_util_BaseConverter_get_inv_gamma(self)
    }
    #[inline]
    pub unsafe fn get_bsk_small_ntt_tables(
        &self,
    ) -> *mut seal_util_Pointer<seal_util_SmallNTTTables> {
        seal_util_BaseConverter_get_bsk_small_ntt_tables(self)
    }
    #[inline]
    pub unsafe fn bsk_base_mod_count(&self) -> ::std::os::raw::c_ulong {
        seal_util_BaseConverter_bsk_base_mod_count(self)
    }
    #[inline]
    pub unsafe fn get_bsk_mod_array(
        &self,
    ) -> *mut seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus> {
        seal_util_BaseConverter_get_bsk_mod_array(self)
    }
    #[inline]
    pub unsafe fn get_msk(&self) -> *mut seal_util_global_variables_internal_mods_SmallModulus {
        seal_util_BaseConverter_get_msk(self)
    }
    #[inline]
    pub unsafe fn get_m_tilde(&self) -> *mut seal_util_global_variables_internal_mods_SmallModulus {
        seal_util_BaseConverter_get_m_tilde(self)
    }
    #[inline]
    pub unsafe fn get_mtilde_inv_coeff_products_mod_coeff(
        &self,
    ) -> *mut seal_util_Pointer<::std::os::raw::c_ulong> {
        seal_util_BaseConverter_get_mtilde_inv_coeff_products_mod_coeff(self)
    }
    #[inline]
    pub unsafe fn get_inv_coeff_mod_mtilde(&self) -> *const ::std::os::raw::c_ulong {
        seal_util_BaseConverter_get_inv_coeff_mod_mtilde(self)
    }
    #[inline]
    pub unsafe fn get_inv_coeff_mod_coeff_array(
        &self,
    ) -> *mut seal_util_Pointer<::std::os::raw::c_ulong> {
        seal_util_BaseConverter_get_inv_coeff_mod_coeff_array(self)
    }
    #[inline]
    pub unsafe fn get_inv_last_coeff_mod_array(
        &self,
    ) -> *mut seal_util_Pointer<::std::os::raw::c_ulong> {
        seal_util_BaseConverter_get_inv_last_coeff_mod_array(self)
    }
    #[inline]
    pub unsafe fn get_coeff_base_products_mod_msk(
        &self,
    ) -> *mut seal_util_Pointer<::std::os::raw::c_ulong> {
        seal_util_BaseConverter_get_coeff_base_products_mod_msk(self)
    }
    #[inline]
    pub unsafe fn new(pool: seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_BaseConverter_BaseConverter(&mut __bindgen_tmp, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        coeff_base: *const [u64; 3usize],
        coeff_count: usize,
        small_plain_mod: *const seal_util_global_variables_internal_mods_SmallModulus,
        pool: seal_MemoryPoolHandle,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_util_BaseConverter_BaseConverter1(
            &mut __bindgen_tmp,
            coeff_base,
            coeff_count,
            small_plain_mod,
            pool,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18poly_to_hex_stringB5cxx11EPKmmm"]
    pub fn seal_util_poly_to_hex_string(
        value: *const u64,
        coeff_count: usize,
        coeff_uint64_count: usize,
    ) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18poly_to_dec_stringB5cxx11EPKmmmRNS0_10MemoryPoolE"]
    pub fn seal_util_poly_to_dec_string(
        value: *const u64,
        coeff_count: usize,
        coeff_uint64_count: usize,
        pool: *mut seal_util_MemoryPool,
    ) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13allocate_polyEmmRNS0_10MemoryPoolE"]
    pub fn seal_util_allocate_poly(
        coeff_count: usize,
        coeff_uint64_count: usize,
        pool: *mut seal_util_MemoryPool,
    ) -> seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13set_zero_polyEmmPm"]
    pub fn seal_util_set_zero_poly(coeff_count: usize, coeff_uint64_count: usize, result: *mut u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18allocate_zero_polyEmmRNS0_10MemoryPoolE"]
    pub fn seal_util_allocate_zero_poly(
        coeff_count: usize,
        coeff_uint64_count: usize,
        pool: *mut seal_util_MemoryPool,
    ) -> seal_util_Pointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14get_poly_coeffEPmmm"]
    pub fn seal_util_get_poly_coeff(
        poly: *mut u64,
        coeff_index: usize,
        coeff_uint64_count: usize,
    ) -> *mut u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util14get_poly_coeffEPKmmm"]
    pub fn seal_util_get_poly_coeff1(
        poly: *const u64,
        coeff_index: usize,
        coeff_uint64_count: usize,
    ) -> *const u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13set_poly_polyEPKmmmPm"]
    pub fn seal_util_set_poly_poly(
        poly: *const u64,
        coeff_count: usize,
        coeff_uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util12is_zero_polyEPKmmm"]
    pub fn seal_util_is_zero_poly(
        poly: *const u64,
        coeff_count: usize,
        coeff_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18is_equal_poly_polyEPKmS2_mm"]
    pub fn seal_util_is_equal_poly_poly(
        operand1: *const u64,
        operand2: *const u64,
        coeff_count: usize,
        coeff_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13set_poly_polyEPKmmmmmPm"]
    pub fn seal_util_set_poly_poly1(
        poly: *const u64,
        poly_coeff_count: usize,
        poly_coeff_uint64_count: usize,
        result_coeff_count: usize,
        result_coeff_uint64_count: usize,
        result: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util20is_one_zero_one_polyEPKmmm"]
    pub fn seal_util_is_one_zero_one_poly(
        poly: *const u64,
        coeff_count: usize,
        coeff_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util32get_significant_coeff_count_polyEPKmmm"]
    pub fn seal_util_get_significant_coeff_count_poly(
        poly: *const u64,
        coeff_count: usize,
        coeff_uint64_count: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util24duplicate_poly_if_neededEPKmmmmmbRNS0_10MemoryPoolE"]
    pub fn seal_util_duplicate_poly_if_needed(
        poly: *const u64,
        coeff_count: usize,
        coeff_uint64_count: usize,
        new_coeff_count: usize,
        new_coeff_uint64_count: usize,
        force: bool,
        pool: *mut seal_util_MemoryPool,
    ) -> seal_util_ConstPointer<::std::os::raw::c_ulong>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util31are_poly_coefficients_less_thanEPKmmmS2_m"]
    pub fn seal_util_are_poly_coefficients_less_than(
        poly: *const u64,
        coeff_count: usize,
        coeff_uint64_count: usize,
        compare: *const u64,
        compare_uint64_count: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util31are_poly_coefficients_less_thanEPKmmm"]
    pub fn seal_util_are_poly_coefficients_less_than1(
        poly: *const u64,
        coeff_count: usize,
        compare: u64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util3gcdEmm"]
    pub fn seal_util_gcd(x: u64, y: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util4xgcdEmm"]
    pub fn seal_util_xgcd(x: u64, y: u64) -> [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15try_mod_inverseEmmRm"]
    pub fn seal_util_try_mod_inverse(value: u64, modulus: u64, result: *mut u64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util21multiplicative_ordersESt6vectorImSaImEEm"]
    pub fn seal_util_multiplicative_orders(conjugate_classes: u8, modulus: u64) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util17conjugate_classesEmm"]
    pub fn seal_util_conjugate_classes(modulus: u64, subgroup_generator: u64) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18babystep_giantstepEmRSt6vectorImSaImEES4_"]
    pub fn seal_util_babystep_giantstep(modulus: u64, baby_steps: *mut u8, giant_steps: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util28decompose_babystep_giantstepEmmRKSt6vectorImSaImEES5_"]
    pub fn seal_util_decompose_babystep_giantstep(
        modulus: u64,
        input: u64,
        baby_steps: *const u8,
        giant_steps: *const u8,
    ) -> [u64; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18increment_uint_modEmRKNS_12SmallModulusE"]
    pub fn seal_util_increment_uint_mod1(
        operand: u64,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18decrement_uint_modEmRKNS_12SmallModulusE"]
    pub fn seal_util_decrement_uint_mod1(
        operand: u64,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util15negate_uint_modEmRKNS_12SmallModulusE"]
    pub fn seal_util_negate_uint_mod1(
        operand: u64,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util13div2_uint_modEmRKNS_12SmallModulusE"]
    pub fn seal_util_div2_uint_mod1(
        operand: u64,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util17add_uint_uint_modEmmRKNS_12SmallModulusE"]
    pub fn seal_util_add_uint_uint_mod1(
        operand1: u64,
        operand2: u64,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util17sub_uint_uint_modEmmRKNS_12SmallModulusE"]
    pub fn seal_util_sub_uint_uint_mod1(
        operand1: u64,
        operand2: u64,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util22multiply_uint_uint_modEmmRKNS_12SmallModulusE"]
    pub fn seal_util_multiply_uint_uint_mod(
        operand1: u64,
        operand2: u64,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util19modulo_uint_inplaceEPmmRKNS_12SmallModulusE"]
    pub fn seal_util_modulo_uint_inplace(
        value: *mut u64,
        value_uint64_count: usize,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util11modulo_uintEPKmmRKNS_12SmallModulusERNS0_10MemoryPoolE"]
    pub fn seal_util_modulo_uint(
        value: *const u64,
        value_uint64_count: usize,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        pool: *mut seal_util_MemoryPool,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util19try_invert_uint_modEmRKNS_12SmallModulusERm"]
    pub fn seal_util_try_invert_uint_mod1(
        operand: u64,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        result: *mut u64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util17is_primitive_rootEmmRKNS_12SmallModulusE"]
    pub fn seal_util_is_primitive_root(
        root: u64,
        degree: u64,
        prime_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util18try_primitive_rootEmRKNS_12SmallModulusERm"]
    pub fn seal_util_try_primitive_root(
        degree: u64,
        prime_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        destination: *mut u64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util26try_minimal_primitive_rootEmRKNS_12SmallModulusERm"]
    pub fn seal_util_try_minimal_primitive_root(
        degree: u64,
        prime_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        destination: *mut u64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util21exponentiate_uint_modEmmRKNS_12SmallModulusE"]
    pub fn seal_util_exponentiate_uint_mod(
        operand: u64,
        exponent: u64,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util28divide_uint_uint_mod_inplaceEPmRKNS_12SmallModulusEmS1_RNS0_10MemoryPoolE"]
    pub fn seal_util_divide_uint_uint_mod_inplace(
        numerator: *mut u64,
        modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        uint64_count: usize,
        quotient: *mut u64,
        pool: *mut seal_util_MemoryPool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal4util19steps_to_galois_eltEim"]
    pub fn seal_util_steps_to_galois_elt(steps: ::std::os::raw::c_int, coeff_count: usize) -> u64;
}
#[test]
fn __bindgen_test_layout_seal_util_ConstPointer_open0_seal_SEAL_BYTE_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ConstPointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_ConstPointer<seal_SEAL_BYTE>)
        )
    );
}
///Manages a shared pointer to a memory pool. SEAL uses memory pools for
///improved performance due to the large number of memory allocations needed
///by the homomorphic encryption operations, and the underlying polynomial
///arithmetic. The library automatically creates a shared global memory pool
///that is used for all dynamic allocations by default, and the user can
///optionally create any number of custom memory pools to be used instead.
///
///@Uses in Multi-Threaded Applications
///Sometimes the user might want to use specific memory pools for dynamic
///allocations in certain functions. For example, in heavily multi-threaded
///applications allocating concurrently from a shared memory pool might lead
///to significant performance issues due to thread contention. For these cases
///SEAL provides overloads of the functions that take a MemoryPoolHandle as an
///additional argument, and uses the associated memory pool for all dynamic
///allocations inside the function. Whenever these functions are called, the
///user can then simply pass a thread-local MemoryPoolHandle to be used.
///
///@Thread-Unsafe Memory Pools
///While memory pools are by default thread-safe, in some cases it suffices
///to have a memory pool be thread-unsafe. To get a little extra performance,
///the user can optionally create such thread-unsafe memory pools and use them
///just as they would use thread-safe memory pools.
///
///@Initialized and Uninitialized Handles
///A MemoryPoolHandle has to be set to point either to the global memory pool,
///or to a new memory pool. If this is not done, the MemoryPoolHandle is
///said to be uninitialized, and cannot be used. Initialization simple means
///assigning MemoryPoolHandle::Global() or MemoryPoolHandle::New() to it.
///
///@Managing Lifetime
///Internally, the MemoryPoolHandle wraps an std::shared_ptr pointing to
///a SEAL memory pool class. Thus, as long as a MemoryPoolHandle pointing to
///a particular memory pool exists, the pool stays alive. Classes such as
///Evaluator and Ciphertext store their own local copies of a MemoryPoolHandle
///to guarantee that the pool stays alive as long as the managing object
///itself stays alive. The global memory pool is implemented as a global
///std::shared_ptr to a memory pool class, and is thus expected to stay
///alive for the entire duration of the program execution. Note that it can
///be problematic to create other global objects that use the memory pool
///e.g. in their constructor, as one would have to ensure the initialization
///order of these global variables to be correct (i.e. global memory pool
///first).
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_MemoryPoolHandle {
    pub pool_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_seal_MemoryPoolHandle() {
    assert_eq!(
        ::std::mem::size_of::<seal_MemoryPoolHandle>(),
        16usize,
        concat!("Size of: ", stringify!(seal_MemoryPoolHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MemoryPoolHandle>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MemoryPoolHandle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_MemoryPoolHandle>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MemoryPoolHandle),
            "::",
            stringify!(pool_)
        )
    );
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to the global memory pool.
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandle6GlobalEv"]
    pub fn seal_MemoryPoolHandle_Global() -> seal_MemoryPoolHandle;
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to the thread-local memory pool. Note
    ///that the thread-local memory pool cannot be used to communicate across
    ///different threads.
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandle11ThreadLocalEv"]
    pub fn seal_MemoryPoolHandle_ThreadLocal() -> seal_MemoryPoolHandle;
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to a new thread-safe memory pool.
    ///
    ///@param[in] clear_on_destruction Indicates whether the memory pool data
    ///should be cleared when destroyed. This can be important when memory pools
    ///are used to store private data.
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandle3NewEb"]
    pub fn seal_MemoryPoolHandle_New(clear_on_destruction: bool) -> seal_MemoryPoolHandle;
}
extern "C" {
    ///Returns the number of different allocation sizes. This function returns
    ///the number of different allocation sizes the memory pool pointed to by
    ///the current MemoryPoolHandle has made. For example, if the memory pool has
    ///only allocated two allocations of sizes 128 KB, this function returns 1.
    ///If it has instead allocated one allocation of size 64 KB and one of 128 KB,
    ///this function returns 2.
    ///
    ///@throws std::logic_error if the MemoryPoolHandle is uninitialized
    #[link_name = "\u{1}_ZNK4seal16MemoryPoolHandle10pool_countEv"]
    pub fn seal_MemoryPoolHandle_pool_count(this: *const seal_MemoryPoolHandle) -> usize;
}
extern "C" {
    ///Returns the size of allocated memory. This functions returns the total
    ///amount of memory (in bytes) allocated by the memory pool pointed to by
    ///the current MemoryPoolHandle.
    ///
    ///
    ///@throws std::logic_error if the MemoryPoolHandle is uninitialized
    #[link_name = "\u{1}_ZNK4seal16MemoryPoolHandle16alloc_byte_countEv"]
    pub fn seal_MemoryPoolHandle_alloc_byte_count(this: *const seal_MemoryPoolHandle) -> usize;
}
extern "C" {
    ///Creates a new uninitialized MemoryPoolHandle.
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1Ev"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle(this: *mut seal_MemoryPoolHandle);
}
extern "C" {
    ///Creates a MemoryPoolHandle pointing to a given MemoryPool object.
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1ESt10shared_ptrINS_4util10MemoryPoolEE"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle1(
        this: *mut seal_MemoryPoolHandle,
        pool: [u64; 2usize],
    );
}
extern "C" {
    ///Creates a copy of a given MemoryPoolHandle. As a result, the created
    ///MemoryPoolHandle will point to the same underlying memory pool as the
    ///copied instance.
    ///
    ///
    ///@param[in] copy The MemoryPoolHandle to copy from
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1ERKS0_"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle2(
        this: *mut seal_MemoryPoolHandle,
        copy: *const seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Creates a new MemoryPoolHandle by moving a given one. As a result, the
    ///moved MemoryPoolHandle will become uninitialized.
    ///
    ///
    ///@param[in] source The MemoryPoolHandle to move from
    #[link_name = "\u{1}_ZN4seal16MemoryPoolHandleC1EOS0_"]
    pub fn seal_MemoryPoolHandle_MemoryPoolHandle3(
        this: *mut seal_MemoryPoolHandle,
        source: *mut seal_MemoryPoolHandle,
    );
}
impl seal_MemoryPoolHandle {
    #[inline]
    pub unsafe fn Global() -> seal_MemoryPoolHandle {
        seal_MemoryPoolHandle_Global()
    }
    #[inline]
    pub unsafe fn ThreadLocal() -> seal_MemoryPoolHandle {
        seal_MemoryPoolHandle_ThreadLocal()
    }
    #[inline]
    pub unsafe fn New(clear_on_destruction: bool) -> seal_MemoryPoolHandle {
        seal_MemoryPoolHandle_New(clear_on_destruction)
    }
    #[inline]
    pub unsafe fn pool_count(&self) -> usize {
        seal_MemoryPoolHandle_pool_count(self)
    }
    #[inline]
    pub unsafe fn alloc_byte_count(&self) -> usize {
        seal_MemoryPoolHandle_alloc_byte_count(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(pool: [u64; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle1(&mut __bindgen_tmp, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(copy: *const seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle2(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(source: *mut seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryPoolHandle_MemoryPoolHandle3(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
pub type seal_mm_prof_opt_t = u64;
pub const seal_mm_prof_opt_DEFAULT: seal_mm_prof_opt = 0;
pub const seal_mm_prof_opt_FORCE_GLOBAL: seal_mm_prof_opt = 1;
pub const seal_mm_prof_opt_FORCE_NEW: seal_mm_prof_opt = 2;
pub const seal_mm_prof_opt_FORCE_THREAD_LOCAL: seal_mm_prof_opt = 4;
///Control options for MemoryManager::GetPool function. These force the MemoryManager
///to override the current MMProf and instead return a MemoryPoolHandle pointing
///to a memory pool of the indicated type.
pub type seal_mm_prof_opt = u64;
#[repr(C)]
pub struct seal_MMProf__bindgen_vtable(::std::os::raw::c_void);
///The MMProf is a pure virtual class that every profile for the MemoryManager
///should inherit from. The only functionality this class implements is the
///get_pool(mm_prof_opt_t) function that returns a MemoryPoolHandle pointing
///to a pool selected by internal logic optionally using the input parameter
///of type mm_prof_opt_t. The returned MemoryPoolHandle must point to a valid
///memory pool.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProf {
    pub vtable_: *const seal_MMProf__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_seal_MMProf() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProf>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProf))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProf>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProf))
    );
}
extern "C" {
    ///Creates a new MMProf.
    #[link_name = "\u{1}_ZN4seal6MMProfC2Ev"]
    pub fn seal_MMProf_MMProf(this: *mut seal_MMProf);
}
impl Default for seal_MMProf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProf {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProf_MMProf(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProf.
    #[link_name = "\u{1}_ZN4seal6MMProfD1Ev"]
    pub fn seal_MMProf_MMProf_destructor(this: *mut seal_MMProf);
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///the global memory pool. SEAL uses this memory manager profile by default.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfGlobal {
    pub _base: seal_MMProf,
}
#[test]
fn bindgen_test_layout_seal_MMProfGlobal() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfGlobal>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProfGlobal))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfGlobal>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfGlobal))
    );
}
extern "C" {
    ///Creates a new MMProfGlobal.
    #[link_name = "\u{1}_ZN4seal12MMProfGlobalC1Ev"]
    pub fn seal_MMProfGlobal_MMProfGlobal(this: *mut seal_MMProfGlobal);
}
impl Default for seal_MMProfGlobal {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfGlobal {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfGlobal_MMProfGlobal(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfGlobal.
    #[link_name = "\u{1}_ZN4seal12MMProfGlobalD1Ev"]
    pub fn seal_MMProfGlobal_MMProfGlobal_destructor(this: *mut seal_MMProfGlobal);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to the global memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal12MMProfGlobal8get_poolEm"]
    pub fn seal_MMProfGlobal_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///the new thread-safe memory pool. This profile should not be used except in
///special circumstances, as it does not result in any reuse of allocated memory.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfNew {
    pub _base: seal_MMProf,
}
#[test]
fn bindgen_test_layout_seal_MMProfNew() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfNew>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProfNew))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfNew>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfNew))
    );
}
extern "C" {
    ///Creates a new MMProfNew.
    #[link_name = "\u{1}_ZN4seal9MMProfNewC1Ev"]
    pub fn seal_MMProfNew_MMProfNew(this: *mut seal_MMProfNew);
}
impl Default for seal_MMProfNew {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfNew {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfNew_MMProfNew(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfNew.
    #[link_name = "\u{1}_ZN4seal9MMProfNewD1Ev"]
    pub fn seal_MMProfNew_MMProfNew_destructor(this: *mut seal_MMProfNew);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to a new thread-safe memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal9MMProfNew8get_poolEm"]
    pub fn seal_MMProfNew_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///specific memory pool.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfFixed {
    pub _base: seal_MMProf,
    pub pool_: seal_MemoryPoolHandle,
}
#[test]
fn bindgen_test_layout_seal_MMProfFixed() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfFixed>(),
        24usize,
        concat!("Size of: ", stringify!(seal_MMProfFixed))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfFixed>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfFixed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_MMProfFixed>())).pool_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MMProfFixed),
            "::",
            stringify!(pool_)
        )
    );
}
extern "C" {
    ///Creates a new MMProfFixed. The MemoryPoolHandle given as argument is returned
    ///by every call to get_pool(mm_prof_opt_t).
    ///
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal11MMProfFixedC1ENS_16MemoryPoolHandleE"]
    pub fn seal_MMProfFixed_MMProfFixed(this: *mut seal_MMProfFixed, pool: seal_MemoryPoolHandle);
}
impl Default for seal_MMProfFixed {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfFixed {
    #[inline]
    pub unsafe fn new(pool: seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfFixed_MMProfFixed(&mut __bindgen_tmp, pool);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfFixed.
    #[link_name = "\u{1}_ZN4seal11MMProfFixedD1Ev"]
    pub fn seal_MMProfFixed_MMProfFixed_destructor(this: *mut seal_MMProfFixed);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to the stored memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal11MMProfFixed8get_poolEm"]
    pub fn seal_MMProfFixed_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///A memory manager profile that always returns a MemoryPoolHandle pointing to
///the thread-local memory pool. This profile should be used with care, as any
///memory allocated by it will be released once the thread exits. In other words,
///the thread-local memory pool cannot be used to share memory across different
///threads. On the other hand, this profile can be useful when a very high number
///of threads doing simultaneous allocations would cause contention in the
///global memory pool.
#[repr(C)]
#[derive(Debug)]
pub struct seal_MMProfThreadLocal {
    pub _base: seal_MMProf,
}
#[test]
fn bindgen_test_layout_seal_MMProfThreadLocal() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfThreadLocal>(),
        8usize,
        concat!("Size of: ", stringify!(seal_MMProfThreadLocal))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfThreadLocal>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfThreadLocal))
    );
}
extern "C" {
    ///Creates a new MMProfThreadLocal.
    #[link_name = "\u{1}_ZN4seal17MMProfThreadLocalC1Ev"]
    pub fn seal_MMProfThreadLocal_MMProfThreadLocal(this: *mut seal_MMProfThreadLocal);
}
impl Default for seal_MMProfThreadLocal {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_MMProfThreadLocal {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfThreadLocal_MMProfThreadLocal(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the MMProfThreadLocal.
    #[link_name = "\u{1}_ZN4seal17MMProfThreadLocalD1Ev"]
    pub fn seal_MMProfThreadLocal_MMProfThreadLocal_destructor(this: *mut seal_MMProfThreadLocal);
}
extern "C" {
    ///Returns a MemoryPoolHandle pointing to the thread-local memory pool. The
    ///mm_prof_opt_t input parameter has no effect.
    #[link_name = "\u{1}_ZN4seal17MMProfThreadLocal8get_poolEm"]
    pub fn seal_MMProfThreadLocal_get_pool(
        this: *mut ::std::os::raw::c_void,
        arg1: seal_mm_prof_opt_t,
    ) -> seal_MemoryPoolHandle;
}
///The MemoryManager class can be used to create instances of MemoryPoolHandle
///based on a given "profile". A profile is implemented by inheriting from the
///MMProf class (pure virtual) and encapsulates internal logic for deciding which
///memory pool to use.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_MemoryManager {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManager8mm_prof_E"]
    pub static mut seal_MemoryManager_mm_prof_: u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManager13switch_mutex_E"]
    pub static mut seal_MemoryManager_switch_mutex_: std_mutex;
}
#[test]
fn bindgen_test_layout_seal_MemoryManager() {
    assert_eq!(
        ::std::mem::size_of::<seal_MemoryManager>(),
        1usize,
        concat!("Size of: ", stringify!(seal_MemoryManager))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MemoryManager>(),
        1usize,
        concat!("Alignment of ", stringify!(seal_MemoryManager))
    );
}
extern "C" {
    ///Sets the current profile to a given one and returns a unique_ptr pointing
    ///to the previously set profile.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::invalid_argument if mm_prof is nullptr
    #[link_name = "\u{1}_ZN4seal13MemoryManager13SwitchProfileEOPNS_6MMProfE"]
    pub fn seal_MemoryManager_SwitchProfile(mm_prof: *mut *mut seal_MMProf) -> u64;
}
extern "C" {
    ///Sets the current profile to a given one and returns a unique_ptr pointing
    ///to the previously set profile.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::invalid_argument if mm_prof is nullptr
    #[link_name = "\u{1}_ZN4seal13MemoryManager13SwitchProfileEOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EE"]
    pub fn seal_MemoryManager_SwitchProfile1(mm_prof: *mut u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManager7GetPoolEv"]
    pub fn seal_MemoryManager_GetPool() -> seal_MemoryPoolHandle;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal13MemoryManagerC1Ev"]
    pub fn seal_MemoryManager_MemoryManager(this: *mut seal_MemoryManager);
}
impl seal_MemoryManager {
    #[inline]
    pub unsafe fn SwitchProfile(mm_prof: *mut *mut seal_MMProf) -> u64 {
        seal_MemoryManager_SwitchProfile(mm_prof)
    }
    #[inline]
    pub unsafe fn SwitchProfile1(mm_prof: *mut u64) -> u64 {
        seal_MemoryManager_SwitchProfile1(mm_prof)
    }
    #[inline]
    pub unsafe fn GetPool() -> seal_MemoryPoolHandle {
        seal_MemoryManager_GetPool()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MemoryManager_MemoryManager(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
///Class for a scoped switch of memory manager profile. This class acts as a scoped
///"guard" for changing the memory manager profile so that the programmer does
///not have to explicitly switch back afterwards and that other threads cannot
///change the MMProf. It can also help with exception safety by guaranteeing that
///the profile is switched back to the original if a function throws an exception
///after changing the profile for local use.
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_MMProfGuard {
    pub old_prof_: u64,
    pub mm_switch_lock_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_seal_MMProfGuard() {
    assert_eq!(
        ::std::mem::size_of::<seal_MMProfGuard>(),
        24usize,
        concat!("Size of: ", stringify!(seal_MMProfGuard))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_MMProfGuard>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_MMProfGuard))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_MMProfGuard>())).old_prof_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MMProfGuard),
            "::",
            stringify!(old_prof_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_MMProfGuard>())).mm_switch_lock_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_MMProfGuard),
            "::",
            stringify!(mm_switch_lock_)
        )
    );
}
extern "C" {
    ///Attempts to lock the MemoryManager for profile switch, perform the switch
    ///to currently stored memory manager profile, store the previously held profile,
    ///and keep the lock until unlocked or destroyed. If the lock cannot be obtained
    ///on the first attempt, the function returns false; otherwise returns true.
    ///
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard8try_lockEv"]
    pub fn seal_MMProfGuard_try_lock(this: *mut seal_MMProfGuard) -> bool;
}
extern "C" {
    ///Locks the MemoryManager for profile switch, performs the switch to currently
    ///stored memory manager profile, stores the previously held profile, and
    ///keep the lock until unlocked or destroyed. The calling thread will block
    ///until the lock can be obtained.
    ///
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard4lockEv"]
    pub fn seal_MMProfGuard_lock(this: *mut seal_MMProfGuard);
}
extern "C" {
    ///Attempts to lock the MemoryManager for profile switch, perform the switch
    ///to the given memory manager profile, store the previously held profile,
    ///and keep the lock until unlocked or destroyed. If the lock cannot be
    ///obtained on the first attempt, the function returns false; otherwise
    ///returns true.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard8try_lockEOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EE"]
    pub fn seal_MMProfGuard_try_lock1(this: *mut seal_MMProfGuard, mm_prof: *mut u64) -> bool;
}
extern "C" {
    ///Locks the MemoryManager for profile switch, performs the switch to the given
    ///memory manager profile, stores the previously held profile, and keep the
    ///lock until unlocked or destroyed. The calling thread will block until the
    ///lock can be obtained.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard4lockEOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EE"]
    pub fn seal_MMProfGuard_lock1(this: *mut seal_MMProfGuard, mm_prof: *mut u64);
}
extern "C" {
    ///Attempts to lock the MemoryManager for profile switch, perform the switch
    ///to the given memory manager profile, store the previously held profile,
    ///and keep the lock until unlocked or destroyed. If the lock cannot be
    ///obtained on the first attempt, the function returns false; otherwise returns
    ///true.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard8try_lockEOPNS_6MMProfE"]
    pub fn seal_MMProfGuard_try_lock2(
        this: *mut seal_MMProfGuard,
        mm_prof: *mut *mut seal_MMProf,
    ) -> bool;
}
extern "C" {
    ///Locks the MemoryManager for profile switch, performs the switch to the
    ///given memory manager profile, stores the previously held profile, and keep
    ///the lock until unlocked or destroyed. The calling thread will block until
    ///the lock can be obtained.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@throws std::runtime_error if the lock is already owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard4lockEOPNS_6MMProfE"]
    pub fn seal_MMProfGuard_lock2(this: *mut seal_MMProfGuard, mm_prof: *mut *mut seal_MMProf);
}
extern "C" {
    ///Releases the memory manager profile switch lock for MemoryManager, stores
    ///the current profile, and resets the profile to the one used before locking.
    ///
    ///@throw std::runtime_error if the lock is not owned
    #[link_name = "\u{1}_ZN4seal11MMProfGuard6unlockEv"]
    pub fn seal_MMProfGuard_unlock(this: *mut seal_MMProfGuard);
}
extern "C" {
    ///Returns whether the current MMProfGuard owns the memory manager profile
    ///switch lock.
    #[link_name = "\u{1}_ZN4seal11MMProfGuard9owns_lockEv"]
    pub fn seal_MMProfGuard_owns_lock(this: *mut seal_MMProfGuard) -> bool;
}
extern "C" {
    ///Creates a new MMProfGuard. If start_locked is true, this function will
    ///attempt to lock the MemoryManager for profile switch to mm_prof, perform
    ///the switch, and keep the lock until unlocked or destroyed. If start_lock
    ///is false, mm_prof will be stored but the switch will not be performed and
    ///a lock will not be obtained until lock() is explicitly called.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@param[in] start_locked Bool indicating whether the lock should be
    ///immediately obtained (true by default)
    #[link_name = "\u{1}_ZN4seal11MMProfGuardC1EOSt10unique_ptrINS_6MMProfESt14default_deleteIS2_EEb"]
    pub fn seal_MMProfGuard_MMProfGuard(
        this: *mut seal_MMProfGuard,
        mm_prof: *mut u64,
        start_locked: bool,
    );
}
extern "C" {
    ///Creates a new MMProfGuard. If start_locked is true, this function will
    ///attempt to lock the MemoryManager for profile switch to mm_prof, perform
    ///the switch, and keep the lock until unlocked or destroyed. If start_lock
    ///is false, mm_prof will be stored but the switch will not be performed and
    ///a lock will not be obtained until lock() is explicitly called.
    ///
    ///@param[in] mm_prof Pointer to a new memory manager profile
    ///@param[in] start_locked Bool indicating whether the lock should be
    ///immediately obtained (true by default)
    #[link_name = "\u{1}_ZN4seal11MMProfGuardC1EOPNS_6MMProfEb"]
    pub fn seal_MMProfGuard_MMProfGuard1(
        this: *mut seal_MMProfGuard,
        mm_prof: *mut *mut seal_MMProf,
        start_locked: bool,
    );
}
extern "C" {
    ///Destroys the MMProfGuard. If the memory manager profile switch lock is
    ///owned, releases the lock, and resets the profile to the one used before
    ///locking.
    #[link_name = "\u{1}_ZN4seal11MMProfGuardD1Ev"]
    pub fn seal_MMProfGuard_MMProfGuard_destructor(this: *mut seal_MMProfGuard);
}
impl seal_MMProfGuard {
    #[inline]
    pub unsafe fn try_lock(&mut self) -> bool {
        seal_MMProfGuard_try_lock(self)
    }
    #[inline]
    pub unsafe fn lock(&mut self) {
        seal_MMProfGuard_lock(self)
    }
    #[inline]
    pub unsafe fn try_lock1(&mut self, mm_prof: *mut u64) -> bool {
        seal_MMProfGuard_try_lock1(self, mm_prof)
    }
    #[inline]
    pub unsafe fn lock1(&mut self, mm_prof: *mut u64) {
        seal_MMProfGuard_lock1(self, mm_prof)
    }
    #[inline]
    pub unsafe fn try_lock2(&mut self, mm_prof: *mut *mut seal_MMProf) -> bool {
        seal_MMProfGuard_try_lock2(self, mm_prof)
    }
    #[inline]
    pub unsafe fn lock2(&mut self, mm_prof: *mut *mut seal_MMProf) {
        seal_MMProfGuard_lock2(self, mm_prof)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        seal_MMProfGuard_unlock(self)
    }
    #[inline]
    pub unsafe fn owns_lock(&mut self) -> bool {
        seal_MMProfGuard_owns_lock(self)
    }
    #[inline]
    pub unsafe fn new(mm_prof: *mut u64, start_locked: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfGuard_MMProfGuard(&mut __bindgen_tmp, mm_prof, start_locked);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(mm_prof: *mut *mut seal_MMProf, start_locked: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_MMProfGuard_MMProfGuard1(&mut __bindgen_tmp, mm_prof, start_locked);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        seal_MMProfGuard_MMProfGuard_destructor(self)
    }
}
///Represents an unsigned integer with a specified bit width. Non-const
///BigUInts are mutable and able to be resized. The bit count for a BigUInt
///(which can be read with bit_count()) is set initially by the constructor
///and can be resized either explicitly with the resize() function or
///implicitly with an assignment operation (e.g., operator=(), operator+=(),
///etc.). A rich set of unsigned integer operations are provided by the
///BigUInt class, including comparison, traditional arithmetic (addition,
///subtraction, multiplication, division), and modular arithmetic functions.
///
///@par Backing Array
///The backing array for a BigUInt stores its unsigned integer value as
///a contiguous std::uint64_t array. Each std::uint64_t in the array
///sequentially represents 64-bits of the integer value, with the least
///significant quad-word storing the lower 64-bits and the order of the bits
///for each quad word dependent on the architecture's std::uint64_t
///representation. The size of the array equals the bit count of the BigUInt
///(which can be read with bit_count()) rounded up to the next std::uint64_t
///boundary (i.e., rounded up to the next 64-bit boundary). The uint64_count()
///function returns the number of std::uint64_t in the backing array. The
///data() function returns a pointer to the first std::uint64_t in the array.
///Additionally, the operator [] function allows accessing the individual
///bytes of the integer value in a platform-independent way - for example,
///reading the third byte will always return bits 16-24 of the BigUInt value
///regardless of the platform being little-endian or big-endian.
///
///@par Implicit Resizing
///Both the copy constructor and operator=() allocate more memory for the
///backing array when needed, i.e. when the source BigUInt has a larger
///backing array than the destination. Conversely, when the destination
///backing array is already large enough, the data is only copied and the
///unnecessary higher order bits are set to zero. When new memory has to be
///allocated, only the significant bits of the source BigUInt are taken
///into account. This is is important, because it avoids unnecessary zero
///bits to be included in the destination, which in some cases could
///accumulate and result in very large unnecessary allocations. However,
///sometimes it is necessary to preserve the original size, even if some
///of the leading bits are zero. For this purpose BigUInt contains functions
///duplicate_from and duplicate_to, which create an exact copy of the source
///BigUInt.
///
///@par Alias BigUInts
///An aliased BigUInt (which can be determined with is_alias()) is a special
///type of BigUInt that does not manage its underlying std::uint64_t pointer
///used to store the value. An aliased BigUInt supports most of the same
///operations as a non-aliased BigUInt, including reading and writing the
///value, however an aliased BigUInt does not internally allocate or
///deallocate its backing array and, therefore, does not support resizing.
///Any attempt, either explicitly or implicitly, to resize the BigUInt will
///result in an exception being thrown. An aliased BigUInt can be created
///with the BigUInt(int, std::uint64_t*) constructor or the alias() function.
///Note that the pointer specified to be aliased must be deallocated
///externally after the BigUInt is no longer in use. Aliasing is useful in
///cases where it is desirable to not have each BigUInt manage its own memory
///allocation and/or to prevent unnecessary copying.
///
///@par Thread Safety
///In general, reading a BigUInt is thread-safe while mutating is not.
///Specifically, the backing array may be freed whenever a resize occurs,
///the BigUInt is destroyed, or alias() is called, which would invalidate
///the address returned by data() and the byte references returned by
///operator []. When it is known that a resize will not occur, concurrent
///reading and mutating will not inherently fail but it is possible for
///a read to see a partially updated value from a concurrent write.
///A non-aliased BigUInt allocates its backing array from the global
///(thread-safe) memory pool. Consequently, creating or resizing a large
///number of BigUInt can result in a performance loss due to thread
///contention.
#[repr(C)]
#[derive(Debug)]
pub struct seal_BigUInt {
    pub pool_: seal_MemoryPoolHandle,
    ///Points to the backing array for the BigUInt. This pointer will be set
    ///to nullptr if and only if the bit count is zero. This pointer is
    ///automatically allocated and freed by the BigUInt if and only if
    ///the BigUInt is not an alias. If the BigUInt is an alias, then the
    ///pointer was passed-in to a constructor or alias() call, and will not be
    ///deallocated by the BigUInt.
    ///
    ///@see BigUInt for more information about aliased BigUInts or the format
    ///of the backing array.
    pub value_: seal_util_Pointer<u64>,
    ///The bit count for the BigUInt.
    pub bit_count_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_seal_BigUInt() {
    assert_eq!(
        ::std::mem::size_of::<seal_BigUInt>(),
        56usize,
        concat!("Size of: ", stringify!(seal_BigUInt))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_BigUInt>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_BigUInt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_BigUInt>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BigUInt),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_BigUInt>())).value_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BigUInt),
            "::",
            stringify!(value_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_BigUInt>())).bit_count_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BigUInt),
            "::",
            stringify!(bit_count_)
        )
    );
}
extern "C" {
    ///Returns whether or not the BigUInt is an alias.
    ///
    ///@see BigUInt for a detailed description of aliased BigUInt.
    #[link_name = "\u{1}_ZNK4seal7BigUInt8is_aliasEv"]
    pub fn seal_BigUInt_is_alias(this: *const seal_BigUInt) -> bool;
}
extern "C" {
    ///Returns the bit count for the BigUInt.
    ///
    ///@see significant_bit_count() to instead ignore leading zero bits.
    #[link_name = "\u{1}_ZNK4seal7BigUInt9bit_countEv"]
    pub fn seal_BigUInt_bit_count(this: *const seal_BigUInt) -> ::std::os::raw::c_int;
}
extern "C" {
    ///Returns a pointer to the backing array storing the BigUInt value.
    ///The pointer points to the beginning of the backing array at the
    ///least-significant quad word.
    ///
    ///@warning The pointer is valid only until the backing array is freed,
    ///which occurs when the BigUInt is resized, destroyed, or the alias()
    ///function is called.
    ///@see uint64_count() to determine the number of std::uint64_t values
    ///in the backing array.
    #[link_name = "\u{1}_ZN4seal7BigUInt4dataEv"]
    pub fn seal_BigUInt_data(this: *mut seal_BigUInt) -> *mut u64;
}
extern "C" {
    ///Returns a const pointer to the backing array storing the BigUInt value.
    ///The pointer points to the beginning of the backing array at the
    ///least-significant quad word.
    ///
    ///@warning The pointer is valid only until the backing array is freed, which
    ///occurs when the BigUInt is resized, destroyed, or the alias() function is
    ///called.
    ///@see uint64_count() to determine the number of std::uint64_t values in the
    ///backing array.
    #[link_name = "\u{1}_ZNK4seal7BigUInt4dataEv"]
    pub fn seal_BigUInt_data1(this: *const seal_BigUInt) -> *const u64;
}
extern "C" {
    ///Returns the number of bytes in the backing array used to store the BigUInt
    ///value.
    ///
    ///@see BigUInt for a detailed description of the format of the backing array.
    #[link_name = "\u{1}_ZNK4seal7BigUInt10byte_countEv"]
    pub fn seal_BigUInt_byte_count(this: *const seal_BigUInt) -> usize;
}
extern "C" {
    ///Returns the number of std::uint64_t in the backing array used to store
    ///the BigUInt value.
    ///
    ///@see BigUInt for a detailed description of the format of the backing array.
    #[link_name = "\u{1}_ZNK4seal7BigUInt12uint64_countEv"]
    pub fn seal_BigUInt_uint64_count(this: *const seal_BigUInt) -> usize;
}
extern "C" {
    ///Returns the number of significant bits for the BigUInt.
    ///
    ///@see bit_count() to instead return the bit count regardless of leading zero
    ///bits.
    #[link_name = "\u{1}_ZNK4seal7BigUInt21significant_bit_countEv"]
    pub fn seal_BigUInt_significant_bit_count(this: *const seal_BigUInt) -> ::std::os::raw::c_int;
}
extern "C" {
    ///Returns the BigUInt value as a double. Note that precision may be lost during
    ///the conversion.
    #[link_name = "\u{1}_ZNK4seal7BigUInt9to_doubleEv"]
    pub fn seal_BigUInt_to_double(this: *const seal_BigUInt) -> f64;
}
extern "C" {
    ///Returns the BigUInt value as a hexadecimal string.
    #[link_name = "\u{1}_ZNK4seal7BigUInt9to_stringB5cxx11Ev"]
    pub fn seal_BigUInt_to_string(this: *const seal_BigUInt) -> std_string;
}
extern "C" {
    ///Returns the BigUInt value as a decimal string.
    #[link_name = "\u{1}_ZNK4seal7BigUInt13to_dec_stringB5cxx11Ev"]
    pub fn seal_BigUInt_to_dec_string(this: *const seal_BigUInt) -> std_string;
}
extern "C" {
    ///Returns whether or not the BigUInt has the value zero.
    #[link_name = "\u{1}_ZNK4seal7BigUInt7is_zeroEv"]
    pub fn seal_BigUInt_is_zero(this: *const seal_BigUInt) -> bool;
}
extern "C" {
    ///Sets the BigUInt value to zero. This does not resize the BigUInt.
    #[link_name = "\u{1}_ZN4seal7BigUInt8set_zeroEv"]
    pub fn seal_BigUInt_set_zero(this: *mut seal_BigUInt);
}
extern "C" {
    ///Resizes the BigUInt to the specified bit width, copying over the old value
    ///as much as will fit.
    ///
    ///@param[in] bit_count The bit width
    ///@throws std::invalid_argument if bit_count is negative
    ///@throws std::logic_error if the BigUInt is an alias
    #[link_name = "\u{1}_ZN4seal7BigUInt6resizeEi"]
    pub fn seal_BigUInt_resize(this: *mut seal_BigUInt, bit_count: ::std::os::raw::c_int);
}
extern "C" {
    ///Makes the BigUInt an aliased BigUInt with the specified bit width and
    ///backing array. An aliased BigUInt does not internally allocate or
    ///deallocate the backing array, and instead uses the specified backing array
    ///for all read/write operations. Note that resizing is not supported by
    ///an aliased BigUInt and any required deallocation of the specified backing
    ///array must occur externally after the aliased BigUInt is no longer in use.
    ///
    ///@param[in] bit_count The bit width
    ///@param[in] value The backing array to use
    ///@throws std::invalid_argument if bit_count is negative or value is null
    #[link_name = "\u{1}_ZN4seal7BigUInt5aliasEiPm"]
    pub fn seal_BigUInt_alias(
        this: *mut seal_BigUInt,
        bit_count: ::std::os::raw::c_int,
        value: *mut u64,
    );
}
extern "C" {
    ///Resets an aliased BigUInt into an empty non-alias BigUInt with bit count
    ///of zero.
    ///
    ///@throws std::logic_error if BigUInt is not an alias
    #[link_name = "\u{1}_ZN4seal7BigUInt7unaliasEv"]
    pub fn seal_BigUInt_unalias(this: *mut seal_BigUInt);
}
extern "C" {
    ///Compares two BigUInts and returns -1, 0, or 1 if the BigUInt is
    ///less-than, equal-to, or greater-than the second operand respectively.
    ///The input operands are not modified.
    ///
    ///@param[in] compare The value to compare against
    #[link_name = "\u{1}_ZNK4seal7BigUInt9comparetoERKS0_"]
    pub fn seal_BigUInt_compareto(
        this: *const seal_BigUInt,
        compare: *const seal_BigUInt,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///Compares a BigUInt and an unsigned integer and returns -1, 0, or 1 if
    ///the BigUInt is less-than, equal-to, or greater-than the second operand
    ///respectively. The input operands are not modified.
    ///
    ///@param[in] compare The value to compare against
    #[link_name = "\u{1}_ZNK4seal7BigUInt9comparetoEm"]
    pub fn seal_BigUInt_compareto1(
        this: *const seal_BigUInt,
        compare: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///Divides two BigUInts and returns the quotient and sets the remainder
    ///parameter to the remainder. The bit count of the quotient is set to be
    ///the significant bit count of the BigUInt. The remainder is resized if
    ///and only if it is smaller than the bit count of the BigUInt.
    ///
    ///@param[in] operand2 The second operand to divide
    ///@param[out] remainder The BigUInt to store the remainder
    ///@throws std::Invalid_argument if operand2 is zero
    ///@throws std::logic_error if the remainder is an alias and the operator
    ///attempts to enlarge the BigUInt to fit the result
    #[link_name = "\u{1}_ZNK4seal7BigUInt6divremERKS0_RS0_"]
    pub fn seal_BigUInt_divrem(
        this: *const seal_BigUInt,
        operand2: *const seal_BigUInt,
        remainder: *mut seal_BigUInt,
    ) -> seal_BigUInt;
}
extern "C" {
    ///Divides a BigUInt and an unsigned integer and returns the quotient and
    ///sets the remainder parameter to the remainder. The bit count of the
    ///quotient is set to be the significant bit count of the BigUInt. The
    ///remainder is resized if and only if it is smaller than the bit count
    ///of the BigUInt.
    ///
    ///@param[in] operand2 The second operand to divide
    ///@param[out] remainder The BigUInt to store the remainder
    ///@throws std::Invalid_argument if operand2 is zero
    ///@throws std::logic_error if the remainder is an alias which the
    ///function attempts to enlarge to fit the result
    #[link_name = "\u{1}_ZNK4seal7BigUInt6divremEmRS0_"]
    pub fn seal_BigUInt_divrem1(
        this: *const seal_BigUInt,
        operand2: u64,
        remainder: *mut seal_BigUInt,
    ) -> seal_BigUInt;
}
extern "C" {
    ///Returns the inverse of a BigUInt with respect to the specified modulus.
    ///The original BigUInt is not modified. The bit count of the inverse is
    ///set to be the significant bit count of the modulus.
    ///
    ///@param[in] modulus The modulus to calculate the inverse with respect to
    ///@throws std::Invalid_argument if modulus is zero
    ///@throws std::Invalid_argument if modulus is not greater than the BigUInt value
    ///@throws std::Invalid_argument if the BigUInt value and modulus are not co-prime
    #[link_name = "\u{1}_ZNK4seal7BigUInt6modinvERKS0_"]
    pub fn seal_BigUInt_modinv(
        this: *const seal_BigUInt,
        modulus: *const seal_BigUInt,
    ) -> seal_BigUInt;
}
extern "C" {
    ///Returns the inverse of a BigUInt with respect to the specified modulus.
    ///The original BigUInt is not modified. The bit count of the inverse is set
    ///to be the significant bit count of the modulus.
    ///
    ///@param[in] modulus The modulus to calculate the inverse with respect to
    ///@throws std::Invalid_argument if modulus is zero
    ///@throws std::Invalid_argument if modulus is not greater than the BigUInt value
    ///@throws std::Invalid_argument if the BigUInt value and modulus are not co-prime
    #[link_name = "\u{1}_ZNK4seal7BigUInt6modinvEm"]
    pub fn seal_BigUInt_modinv1(this: *const seal_BigUInt, modulus: u64) -> seal_BigUInt;
}
extern "C" {
    ///Attempts to calculate the inverse of a BigUInt with respect to the
    ///specified modulus, returning whether or not the inverse was successful
    ///and setting the inverse parameter to the inverse. The original BigUInt
    ///is not modified. The inverse parameter is resized if and only if its bit
    ///count is smaller than the significant bit count of the modulus.
    ///
    ///@param[in] modulus The modulus to calculate the inverse with respect to
    ///@param[out] inverse Stores the inverse if the inverse operation was
    ///successful
    ///@throws std::Invalid_argument if modulus is zero
    ///@throws std::Invalid_argument if modulus is not greater than the BigUInt
    ///value
    ///@throws std::logic_error if the inverse is an alias which the function
    ///attempts to enlarge to fit the result
    #[link_name = "\u{1}_ZNK4seal7BigUInt9trymodinvERKS0_RS0_"]
    pub fn seal_BigUInt_trymodinv(
        this: *const seal_BigUInt,
        modulus: *const seal_BigUInt,
        inverse: *mut seal_BigUInt,
    ) -> bool;
}
extern "C" {
    ///Attempts to calculate the inverse of a BigUInt with respect to the
    ///specified modulus, returning whether or not the inverse was successful
    ///and setting the inverse parameter to the inverse. The original BigUInt
    ///is not modified. The inverse parameter is resized if and only if its
    ///bit count is smaller than the significant bit count of the modulus.
    ///
    ///@param[in] modulus The modulus to calculate the inverse with respect to
    ///@param[out] inverse Stores the inverse if the inverse operation was
    ///successful
    ///@throws std::Invalid_argument if modulus is zero
    ///@throws std::Invalid_argument if modulus is not greater than the BigUInt
    ///value
    ///@throws std::logic_error if the inverse is an alias which the function
    ///attempts to enlarge to fit the result
    #[link_name = "\u{1}_ZNK4seal7BigUInt9trymodinvEmRS0_"]
    pub fn seal_BigUInt_trymodinv1(
        this: *const seal_BigUInt,
        modulus: u64,
        inverse: *mut seal_BigUInt,
    ) -> bool;
}
extern "C" {
    ///Saves the BigUInt to an output stream. The full state of the BigUInt is
    ///serialized, including insignificant bits. The output is in binary format
    ///and not human-readable. The output stream must have the "binary" flag set.
    ///
    ///@param[in] stream The stream to save the BigUInt to
    ///@throws std::exception if the BigUInt could not be written to stream
    #[link_name = "\u{1}_ZNK4seal7BigUInt4saveERSo"]
    pub fn seal_BigUInt_save(this: *const seal_BigUInt, stream: *mut std_ostream);
}
extern "C" {
    ///Loads a BigUInt from an input stream overwriting the current BigUInt
    ///and enlarging if needed to fit the loaded BigUInt.
    ///
    ///@param[in] stream The stream to load the BigUInt from
    ///@throws std::logic_error if BigUInt is an alias and the loaded BigUInt
    ///is too large to fit with the current bit
    ///@throws std::exception if a valid BigUInt could not be read from stream
    #[link_name = "\u{1}_ZN4seal7BigUInt4loadERSi"]
    pub fn seal_BigUInt_load(this: *mut seal_BigUInt, stream: *mut std_istream);
}
extern "C" {
    ///Creates a minimally sized BigUInt initialized to the specified unsigned
    ///integer value.
    ///
    ///@param[in] value The value to initialized the BigUInt to
    #[link_name = "\u{1}_ZN4seal7BigUInt2ofEm"]
    pub fn seal_BigUInt_of(value: u64) -> seal_BigUInt;
}
extern "C" {
    ///Duplicates the current BigUInt. The bit count and the value of the
    ///given BigUInt are set to be exactly the same as in the current one.
    ///
    ///@param[out] destination The BigUInt to overwrite with the duplicate
    ///@throws std::logic_error if the destination BigUInt is an alias
    #[link_name = "\u{1}_ZNK4seal7BigUInt12duplicate_toERS0_"]
    pub fn seal_BigUInt_duplicate_to(this: *const seal_BigUInt, destination: *mut seal_BigUInt);
}
extern "C" {
    ///Duplicates a given BigUInt. The bit count and the value of the current
    ///BigUInt are set to be exactly the same as in the given one.
    ///
    ///@param[in] value The BigUInt to duplicate
    ///@throws std::logic_error if the current BigUInt is an alias
    #[link_name = "\u{1}_ZN4seal7BigUInt14duplicate_fromERKS0_"]
    pub fn seal_BigUInt_duplicate_from(this: *mut seal_BigUInt, value: *const seal_BigUInt);
}
extern "C" {
    ///Creates an empty BigUInt with zero bit width. No memory is allocated
    ///by this constructor.
    #[link_name = "\u{1}_ZN4seal7BigUIntC1Ev"]
    pub fn seal_BigUInt_BigUInt(this: *mut seal_BigUInt);
}
extern "C" {
    ///Creates a zero-initialized BigUInt of the specified bit width.
    ///
    ///@param[in] bit_count The bit width
    ///@throws std::invalid_argument if bit_count is negative
    #[link_name = "\u{1}_ZN4seal7BigUIntC1Ei"]
    pub fn seal_BigUInt_BigUInt1(this: *mut seal_BigUInt, bit_count: ::std::os::raw::c_int);
}
extern "C" {
    ///Creates a BigUInt initialized and minimally sized to fit the unsigned
    ///hexadecimal integer specified by the string. The string matches the format
    ///returned by to_string() and must consist of only the characters 0-9, A-F,
    ///or a-f, most-significant nibble first.
    ///
    ///@param[in] hex_value The hexadecimal integer string specifying the initial
    ///value
    ///@throws std::invalid_argument if hex_value does not adhere to the expected
    ///format
    #[link_name = "\u{1}_ZN4seal7BigUIntC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn seal_BigUInt_BigUInt2(this: *mut seal_BigUInt, hex_value: *const std_string);
}
extern "C" {
    ///Creates a BigUInt of the specified bit width and initializes it with the
    ///unsigned hexadecimal integer specified by the string. The string must match
    ///the format returned by to_string() and must consist of only the characters
    ///0-9, A-F, or a-f, most-significant nibble first.
    ///
    ///@param[in] bit_count The bit width
    ///@param[in] hex_value The hexadecimal integer string specifying the initial
    ///value
    ///@throws std::invalid_argument if bit_count is negative
    ///@throws std::invalid_argument if hex_value does not adhere to the expected
    ///format
    #[link_name = "\u{1}_ZN4seal7BigUIntC1EiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn seal_BigUInt_BigUInt3(
        this: *mut seal_BigUInt,
        bit_count: ::std::os::raw::c_int,
        hex_value: *const std_string,
    );
}
extern "C" {
    ///Creates an aliased BigUInt with the specified bit width and backing array.
    ///An aliased BigUInt does not internally allocate or deallocate the backing
    ///array, and instead uses the specified backing array for all read/write
    ///operations. Note that resizing is not supported by an aliased BigUInt and
    ///any required deallocation of the specified backing array must occur
    ///externally after the aliased BigUInt is no longer in use.
    ///
    ///@param[in] bit_count The bit width
    ///@param[in] value The backing array to use
    ///@throws std::invalid_argument if bit_count is negative or value is null
    ///and bit_count is positive
    #[link_name = "\u{1}_ZN4seal7BigUIntC1EiPm"]
    pub fn seal_BigUInt_BigUInt4(
        this: *mut seal_BigUInt,
        bit_count: ::std::os::raw::c_int,
        value: *mut u64,
    );
}
extern "C" {
    ///Creates a BigUInt of the specified bit width and initializes it to the
    ///specified unsigned integer value.
    ///
    ///@param[in] bit_count The bit width
    ///@param[in] value The initial value to set the BigUInt
    ///@throws std::invalid_argument if bit_count is negative
    #[link_name = "\u{1}_ZN4seal7BigUIntC1Eim"]
    pub fn seal_BigUInt_BigUInt5(
        this: *mut seal_BigUInt,
        bit_count: ::std::os::raw::c_int,
        value: u64,
    );
}
extern "C" {
    ///Creates a deep copy of a BigUInt. The created BigUInt will have the same
    ///bit count and value as the original.
    ///
    ///@param[in] copy The BigUInt to copy from
    #[link_name = "\u{1}_ZN4seal7BigUIntC1ERKS0_"]
    pub fn seal_BigUInt_BigUInt6(this: *mut seal_BigUInt, copy: *const seal_BigUInt);
}
extern "C" {
    ///Creates a new BigUInt by moving an old one.
    ///
    ///@param[in] source The BigUInt to move from
    #[link_name = "\u{1}_ZN4seal7BigUIntC1EOS0_"]
    pub fn seal_BigUInt_BigUInt7(this: *mut seal_BigUInt, source: *mut seal_BigUInt);
}
extern "C" {
    ///Destroys the BigUInt and deallocates the backing array if it is not
    ///an aliased BigUInt.
    #[link_name = "\u{1}_ZN4seal7BigUIntD1Ev"]
    pub fn seal_BigUInt_BigUInt_destructor(this: *mut seal_BigUInt);
}
impl Default for seal_BigUInt {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_BigUInt {
    #[inline]
    pub unsafe fn is_alias(&self) -> bool {
        seal_BigUInt_is_alias(self)
    }
    #[inline]
    pub unsafe fn bit_count(&self) -> ::std::os::raw::c_int {
        seal_BigUInt_bit_count(self)
    }
    #[inline]
    pub unsafe fn data(&mut self) -> *mut u64 {
        seal_BigUInt_data(self)
    }
    #[inline]
    pub unsafe fn data1(&self) -> *const u64 {
        seal_BigUInt_data1(self)
    }
    #[inline]
    pub unsafe fn byte_count(&self) -> usize {
        seal_BigUInt_byte_count(self)
    }
    #[inline]
    pub unsafe fn uint64_count(&self) -> usize {
        seal_BigUInt_uint64_count(self)
    }
    #[inline]
    pub unsafe fn significant_bit_count(&self) -> ::std::os::raw::c_int {
        seal_BigUInt_significant_bit_count(self)
    }
    #[inline]
    pub unsafe fn to_double(&self) -> f64 {
        seal_BigUInt_to_double(self)
    }
    #[inline]
    pub unsafe fn to_string(&self) -> std_string {
        seal_BigUInt_to_string(self)
    }
    #[inline]
    pub unsafe fn to_dec_string(&self) -> std_string {
        seal_BigUInt_to_dec_string(self)
    }
    #[inline]
    pub unsafe fn is_zero(&self) -> bool {
        seal_BigUInt_is_zero(self)
    }
    #[inline]
    pub unsafe fn set_zero(&mut self) {
        seal_BigUInt_set_zero(self)
    }
    #[inline]
    pub unsafe fn resize(&mut self, bit_count: ::std::os::raw::c_int) {
        seal_BigUInt_resize(self, bit_count)
    }
    #[inline]
    pub unsafe fn alias(&mut self, bit_count: ::std::os::raw::c_int, value: *mut u64) {
        seal_BigUInt_alias(self, bit_count, value)
    }
    #[inline]
    pub unsafe fn unalias(&mut self) {
        seal_BigUInt_unalias(self)
    }
    #[inline]
    pub unsafe fn compareto(&self, compare: *const seal_BigUInt) -> ::std::os::raw::c_int {
        seal_BigUInt_compareto(self, compare)
    }
    #[inline]
    pub unsafe fn compareto1(&self, compare: u64) -> ::std::os::raw::c_int {
        seal_BigUInt_compareto1(self, compare)
    }
    #[inline]
    pub unsafe fn divrem(
        &self,
        operand2: *const seal_BigUInt,
        remainder: *mut seal_BigUInt,
    ) -> seal_BigUInt {
        seal_BigUInt_divrem(self, operand2, remainder)
    }
    #[inline]
    pub unsafe fn divrem1(&self, operand2: u64, remainder: *mut seal_BigUInt) -> seal_BigUInt {
        seal_BigUInt_divrem1(self, operand2, remainder)
    }
    #[inline]
    pub unsafe fn modinv(&self, modulus: *const seal_BigUInt) -> seal_BigUInt {
        seal_BigUInt_modinv(self, modulus)
    }
    #[inline]
    pub unsafe fn modinv1(&self, modulus: u64) -> seal_BigUInt {
        seal_BigUInt_modinv1(self, modulus)
    }
    #[inline]
    pub unsafe fn trymodinv(
        &self,
        modulus: *const seal_BigUInt,
        inverse: *mut seal_BigUInt,
    ) -> bool {
        seal_BigUInt_trymodinv(self, modulus, inverse)
    }
    #[inline]
    pub unsafe fn trymodinv1(&self, modulus: u64, inverse: *mut seal_BigUInt) -> bool {
        seal_BigUInt_trymodinv1(self, modulus, inverse)
    }
    #[inline]
    pub unsafe fn save(&self, stream: *mut std_ostream) {
        seal_BigUInt_save(self, stream)
    }
    #[inline]
    pub unsafe fn load(&mut self, stream: *mut std_istream) {
        seal_BigUInt_load(self, stream)
    }
    #[inline]
    pub unsafe fn of(value: u64) -> seal_BigUInt {
        seal_BigUInt_of(value)
    }
    #[inline]
    pub unsafe fn duplicate_to(&self, destination: *mut seal_BigUInt) {
        seal_BigUInt_duplicate_to(self, destination)
    }
    #[inline]
    pub unsafe fn duplicate_from(&mut self, value: *const seal_BigUInt) {
        seal_BigUInt_duplicate_from(self, value)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BigUInt_BigUInt(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(bit_count: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BigUInt_BigUInt1(&mut __bindgen_tmp, bit_count);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(hex_value: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BigUInt_BigUInt2(&mut __bindgen_tmp, hex_value);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(bit_count: ::std::os::raw::c_int, hex_value: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BigUInt_BigUInt3(&mut __bindgen_tmp, bit_count, hex_value);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(bit_count: ::std::os::raw::c_int, value: *mut u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BigUInt_BigUInt4(&mut __bindgen_tmp, bit_count, value);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new5(bit_count: ::std::os::raw::c_int, value: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BigUInt_BigUInt5(&mut __bindgen_tmp, bit_count, value);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new6(copy: *const seal_BigUInt) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BigUInt_BigUInt6(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new7(source: *mut seal_BigUInt) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BigUInt_BigUInt7(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        seal_BigUInt_BigUInt_destructor(self)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union seal_aes_block {
    pub u32: [u32; 4usize],
    pub u64: [u64; 2usize],
    pub i128: __m128i,
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_seal_aes_block() {
    assert_eq!(
        ::std::mem::size_of::<seal_aes_block>(),
        16usize,
        concat!("Size of: ", stringify!(seal_aes_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_aes_block>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_aes_block),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_aes_block>())).u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_aes_block),
            "::",
            stringify!(u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_aes_block>())).i128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_aes_block),
            "::",
            stringify!(i128)
        )
    );
}
impl Default for seal_aes_block {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_AESEncryptor {
    pub round_key_: [__m128i; 11usize],
}
#[test]
fn bindgen_test_layout_seal_AESEncryptor() {
    assert_eq!(
        ::std::mem::size_of::<seal_AESEncryptor>(),
        176usize,
        concat!("Size of: ", stringify!(seal_AESEncryptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_AESEncryptor>())).round_key_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_AESEncryptor),
            "::",
            stringify!(round_key_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptor7set_keyERKNS_9aes_blockE"]
    pub fn seal_AESEncryptor_set_key(this: *mut seal_AESEncryptor, key: *const seal_aes_block);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor11ecb_encryptERKNS_9aes_blockERS1_"]
    pub fn seal_AESEncryptor_ecb_encrypt(
        this: *const seal_AESEncryptor,
        plaintext: *const seal_aes_block,
        ciphertext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor11ecb_encryptERKNS_9aes_blockE"]
    pub fn seal_AESEncryptor_ecb_encrypt1(
        this: *const seal_AESEncryptor,
        plaintext: *const seal_aes_block,
    ) -> seal_aes_block;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor11ecb_encryptEPKNS_9aes_blockEmPS1_"]
    pub fn seal_AESEncryptor_ecb_encrypt2(
        this: *const seal_AESEncryptor,
        plaintext: *const seal_aes_block,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal12AESEncryptor15counter_encryptEmmPNS_9aes_blockE"]
    pub fn seal_AESEncryptor_counter_encrypt(
        this: *const seal_AESEncryptor,
        start_index: usize,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptorC1Ev"]
    pub fn seal_AESEncryptor_AESEncryptor(this: *mut seal_AESEncryptor);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptorC1ERKNS_9aes_blockE"]
    pub fn seal_AESEncryptor_AESEncryptor1(
        this: *mut seal_AESEncryptor,
        key: *const seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESEncryptorC1Emm"]
    pub fn seal_AESEncryptor_AESEncryptor2(this: *mut seal_AESEncryptor, key_lw: u64, key_hw: u64);
}
impl seal_AESEncryptor {
    #[inline]
    pub unsafe fn set_key(&mut self, key: *const seal_aes_block) {
        seal_AESEncryptor_set_key(self, key)
    }
    #[inline]
    pub unsafe fn ecb_encrypt(
        &self,
        plaintext: *const seal_aes_block,
        ciphertext: *mut seal_aes_block,
    ) {
        seal_AESEncryptor_ecb_encrypt(self, plaintext, ciphertext)
    }
    #[inline]
    pub unsafe fn ecb_encrypt1(&self, plaintext: *const seal_aes_block) -> seal_aes_block {
        seal_AESEncryptor_ecb_encrypt1(self, plaintext)
    }
    #[inline]
    pub unsafe fn ecb_encrypt2(
        &self,
        plaintext: *const seal_aes_block,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    ) {
        seal_AESEncryptor_ecb_encrypt2(self, plaintext, aes_block_count, ciphertext)
    }
    #[inline]
    pub unsafe fn counter_encrypt(
        &self,
        start_index: usize,
        aes_block_count: usize,
        ciphertext: *mut seal_aes_block,
    ) {
        seal_AESEncryptor_counter_encrypt(self, start_index, aes_block_count, ciphertext)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESEncryptor_AESEncryptor(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(key: *const seal_aes_block) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESEncryptor_AESEncryptor1(&mut __bindgen_tmp, key);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(key_lw: u64, key_hw: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESEncryptor_AESEncryptor2(&mut __bindgen_tmp, key_lw, key_hw);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_AESDecryptor {
    pub round_key_: [__m128i; 11usize],
}
#[test]
fn bindgen_test_layout_seal_AESDecryptor() {
    assert_eq!(
        ::std::mem::size_of::<seal_AESDecryptor>(),
        176usize,
        concat!("Size of: ", stringify!(seal_AESDecryptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_AESDecryptor>())).round_key_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_AESDecryptor),
            "::",
            stringify!(round_key_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptor7set_keyERKNS_9aes_blockE"]
    pub fn seal_AESDecryptor_set_key(this: *mut seal_AESDecryptor, key: *const seal_aes_block);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptor11ecb_decryptERKNS_9aes_blockERS1_"]
    pub fn seal_AESDecryptor_ecb_decrypt(
        this: *mut seal_AESDecryptor,
        ciphertext: *const seal_aes_block,
        plaintext: *mut seal_aes_block,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptor11ecb_decryptERKNS_9aes_blockE"]
    pub fn seal_AESDecryptor_ecb_decrypt1(
        this: *mut seal_AESDecryptor,
        ciphertext: *const seal_aes_block,
    ) -> seal_aes_block;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptorC1Ev"]
    pub fn seal_AESDecryptor_AESDecryptor(this: *mut seal_AESDecryptor);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12AESDecryptorC1ERKNS_9aes_blockE"]
    pub fn seal_AESDecryptor_AESDecryptor1(
        this: *mut seal_AESDecryptor,
        key: *const seal_aes_block,
    );
}
impl seal_AESDecryptor {
    #[inline]
    pub unsafe fn set_key(&mut self, key: *const seal_aes_block) {
        seal_AESDecryptor_set_key(self, key)
    }
    #[inline]
    pub unsafe fn ecb_decrypt(
        &mut self,
        ciphertext: *const seal_aes_block,
        plaintext: *mut seal_aes_block,
    ) {
        seal_AESDecryptor_ecb_decrypt(self, ciphertext, plaintext)
    }
    #[inline]
    pub unsafe fn ecb_decrypt1(&mut self, ciphertext: *const seal_aes_block) -> seal_aes_block {
        seal_AESDecryptor_ecb_decrypt1(self, ciphertext)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESDecryptor_AESDecryptor(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(key: *const seal_aes_block) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_AESDecryptor_AESDecryptor1(&mut __bindgen_tmp, key);
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct seal_UniformRandomGenerator__bindgen_vtable(::std::os::raw::c_void);
///Provides the base-class for a uniform random number generator. Instances of
///this class are typically returned from the UniformRandomGeneratorFactory class.
///This class is meant for users to sub-class to implement their own random number
///generators. The implementation should provide a uniform random unsigned 32-bit
///value for each call to generate(). Note that the library will never make
///concurrent calls to generate() to the same instance (but individual instances
///of the same class may have concurrent calls). The uniformity and unpredictability
///of the numbers generated is essential for making a secure cryptographic system.
///
///@see UniformRandomGeneratorFactory for the base-class of a factory class that
///generates UniformRandomGenerator instances.
///@see StandardRandomAdapter for an implementation of UniformRandomGenerator to
///support the C++ standard library's random number generators.
#[repr(C)]
#[derive(Debug)]
pub struct seal_UniformRandomGenerator {
    pub vtable_: *const seal_UniformRandomGenerator__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_seal_UniformRandomGenerator() {
    assert_eq!(
        ::std::mem::size_of::<seal_UniformRandomGenerator>(),
        8usize,
        concat!("Size of: ", stringify!(seal_UniformRandomGenerator))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_UniformRandomGenerator>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_UniformRandomGenerator))
    );
}
impl Default for seal_UniformRandomGenerator {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    ///Destroys the random number generator.
    #[link_name = "\u{1}_ZN4seal22UniformRandomGeneratorD1Ev"]
    pub fn seal_UniformRandomGenerator_UniformRandomGenerator_destructor(
        this: *mut seal_UniformRandomGenerator,
    );
}
#[repr(C)]
pub struct seal_UniformRandomGeneratorFactory__bindgen_vtable(::std::os::raw::c_void);
///Provides the base-class for a factory instance that creates instances of
///UniformRandomGenerator. This class is meant for users to sub-class to implement
///their own random number generators. Note that each instance returned may be
///used concurrently across separate threads, but each individual instance does
///not need to be thread-safe.
///
///@see UniformRandomGenerator for details relating to the random number generator
///instances.
///@see StandardRandomAdapterFactory for an implementation of
///UniformRandomGeneratorFactory that supports the standard C++ library's
///random number generators.
#[repr(C)]
#[derive(Debug)]
pub struct seal_UniformRandomGeneratorFactory {
    pub vtable_: *const seal_UniformRandomGeneratorFactory__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_seal_UniformRandomGeneratorFactory() {
    assert_eq!(
        ::std::mem::size_of::<seal_UniformRandomGeneratorFactory>(),
        8usize,
        concat!("Size of: ", stringify!(seal_UniformRandomGeneratorFactory))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_UniformRandomGeneratorFactory>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(seal_UniformRandomGeneratorFactory)
        )
    );
}
extern "C" {
    ///Returns the default random number generator factory. This instance should
    ///not be destroyed.
    #[link_name = "\u{1}_ZN4seal29UniformRandomGeneratorFactory15default_factoryEv"]
    pub fn seal_UniformRandomGeneratorFactory_default_factory() -> [u64; 2usize];
}
impl Default for seal_UniformRandomGeneratorFactory {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_UniformRandomGeneratorFactory {
    #[inline]
    pub unsafe fn default_factory() -> [u64; 2usize] {
        seal_UniformRandomGeneratorFactory_default_factory()
    }
}
extern "C" {
    ///Destroys the random number generator factory.
    #[link_name = "\u{1}_ZN4seal29UniformRandomGeneratorFactoryD1Ev"]
    pub fn seal_UniformRandomGeneratorFactory_UniformRandomGeneratorFactory_destructor(
        this: *mut seal_UniformRandomGeneratorFactory,
    );
}
///Provides an implementation of UniformRandomGenerator for using very fast
///AES-NI randomness with given 128-bit seed.
#[repr(C)]
pub struct seal_FastPRNG {
    pub _base: seal_UniformRandomGenerator,
    pub __bindgen_padding_0: u64,
    pub aes_enc_: seal_AESEncryptor,
    pub buffer_: [u8; 128usize],
    pub counter_: usize,
    pub buffer_head_: seal_FastPRNG_const_iterator,
}
pub const seal_FastPRNG_bytes_per_block_: usize = 16;
pub const seal_FastPRNG_buffer_block_size_: usize = 8;
pub const seal_FastPRNG_buffer_size_: usize = 128;
#[test]
fn bindgen_test_layout_seal_FastPRNG() {
    assert_eq!(
        ::std::mem::size_of::<seal_FastPRNG>(),
        336usize,
        concat!("Size of: ", stringify!(seal_FastPRNG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).aes_enc_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(aes_enc_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).buffer_ as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(buffer_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).counter_ as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(counter_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNG>())).buffer_head_ as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNG),
            "::",
            stringify!(buffer_head_)
        )
    );
}
extern "C" {
    ///Creates a new FastPRNGFactory instance that initializes every FastPRNG
    ///instance it creates with the given seed.
    #[link_name = "\u{1}_ZN4seal8FastPRNGC1Emm"]
    pub fn seal_FastPRNG_FastPRNG(this: *mut seal_FastPRNG, seed_lw: u64, seed_hw: u64);
}
impl Default for seal_FastPRNG {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_FastPRNG {
    #[inline]
    pub unsafe fn new(seed_lw: u64, seed_hw: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_FastPRNG_FastPRNG(&mut __bindgen_tmp, seed_lw, seed_hw);
        __bindgen_tmp
    }
}
extern "C" {
    ///Generates a new uniform unsigned 32-bit random number. Note that the
    ///implementation does not need to be thread-safe.
    #[link_name = "\u{1}_ZN4seal8FastPRNG8generateEv"]
    pub fn seal_FastPRNG_generate(this: *mut ::std::os::raw::c_void) -> u32;
}
extern "C" {
    ///Destroys the random number generator.
    #[link_name = "\u{1}_ZN4seal8FastPRNGD1Ev"]
    pub fn seal_FastPRNG_FastPRNG_destructor(this: *mut seal_FastPRNG);
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_FastPRNGFactory {
    pub _base: seal_UniformRandomGeneratorFactory,
    pub seed_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_seal_FastPRNGFactory() {
    assert_eq!(
        ::std::mem::size_of::<seal_FastPRNGFactory>(),
        24usize,
        concat!("Size of: ", stringify!(seal_FastPRNGFactory))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_FastPRNGFactory>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_FastPRNGFactory))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FastPRNGFactory>())).seed_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FastPRNGFactory),
            "::",
            stringify!(seed_)
        )
    );
}
extern "C" {
    ///Creates a new FastPRNGFactory instance that initializes every FastPRNG
    ///instance it creates with the given seed. A zero seed (default value)
    ///signals that each random number generator created by the factory should
    ///use a different random seed obtained from std::random_device.
    ///
    ///@param[in] seed_lw Low-word for seed for the PRNG
    ///@param[in] seed_hw High-word for seed for the PRNG
    #[link_name = "\u{1}_ZN4seal15FastPRNGFactoryC1Emm"]
    pub fn seal_FastPRNGFactory_FastPRNGFactory(
        this: *mut seal_FastPRNGFactory,
        seed_lw: u64,
        seed_hw: u64,
    );
}
impl Default for seal_FastPRNGFactory {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_FastPRNGFactory {
    #[inline]
    pub unsafe fn new(seed_lw: u64, seed_hw: u64) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_FastPRNGFactory_FastPRNGFactory(&mut __bindgen_tmp, seed_lw, seed_hw);
        __bindgen_tmp
    }
}
extern "C" {
    ///Creates a new uniform random number generator. The caller of create needs
    ///to ensure the returned instance is destroyed once it is no longer in-use
    ///to prevent a memory leak.
    #[link_name = "\u{1}_ZN4seal15FastPRNGFactory6createEv"]
    pub fn seal_FastPRNGFactory_create(this: *mut ::std::os::raw::c_void) -> [u64; 2usize];
}
extern "C" {
    ///Destroys the random number generator factory.
    #[link_name = "\u{1}_ZN4seal15FastPRNGFactoryD1Ev"]
    pub fn seal_FastPRNGFactory_FastPRNGFactory_destructor(this: *mut seal_FastPRNGFactory);
}
///Provides an implementation of UniformRandomGenerator for the standard C++
///library's uniform random number generators.
///
///@tparam RNG specifies the type of the standard C++ library's random number
///generator (e.g., std::default_random_engine)
#[repr(C)]
#[derive(Debug)]
pub struct seal_StandardRandomAdapter<RNG> {
    pub _base: seal_UniformRandomGenerator,
    pub generator_: RNG,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<RNG>>,
}
impl<RNG> Default for seal_StandardRandomAdapter<RNG> {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///Provides an implementation of UniformRandomGeneratorFactory for the standard
///C++ library's random number generators.
///
///@tparam RNG specifies the type of the standard C++ library's random number
///generator (e.g., std::default_random_engine)
#[repr(C)]
#[derive(Debug)]
pub struct seal_StandardRandomAdapterFactory {
    pub _base: seal_UniformRandomGeneratorFactory,
}
impl Default for seal_StandardRandomAdapterFactory {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const seal_scheme_type_BFV: seal_scheme_type = 1;
pub const seal_scheme_type_CKKS: seal_scheme_type = 2;
pub type seal_scheme_type = u8;
extern "C" {
    #[link_name = "\u{1}_ZN4seal15is_valid_schemeENS_11scheme_typeE"]
    pub fn seal_is_valid_scheme(scheme: seal_scheme_type) -> bool;
}
///The data type to store unique identifiers of encryption parameters.
pub type seal_parms_id_type = seal_util_HashFunction_sha3_block_type;
///Represents user-customizable encryption scheme settings. The parameters (most
///importantly poly_modulus, coeff_modulus, plain_modulus) significantly affect
///the performance, capabilities, and security of the encryption scheme. Once
///an instance of EncryptionParameters is populated with appropriate parameters,
///it can be used to create an instance of the SEALContext class, which verifies
///the validity of the parameters, and performs necessary pre-computations.
///
///Picking appropriate encryption parameters is essential to enable a particular
///application while balancing performance and security. Some encryption settings
///will not allow some inputs (e.g. attempting to encrypt a polynomial with more
///coefficients than poly_modulus or larger coefficients than plain_modulus) or,
///support the desired computations (with noise growing too fast due to too large
///plain_modulus and too small coeff_modulus).
///
///@par parms_id
///The EncryptionParameters class maintains at all times a 256-bit SHA-3 hash of
///the currently set encryption parameters. This hash acts as a unique identifier
///of the encryption parameters and is used by all further objects created for
///these encryption parameters. The parms_id is not intended to be directly modified
///by the user but is used internally for pre-computation data lookup and input
///validity checks. In modulus switching the user can use the parms_id to map the
///chain of encryption parameters.
///
///@par Thread Safety
///In general, reading from EncryptionParameters is thread-safe, while mutating
///is not.
///
///@warning Choosing inappropriate encryption parameters may lead to an encryption
///scheme that is not secure, does not perform well, and/or does not support the
///input and computation of the desired application. We highly recommend consulting
///an expert in RLWE-based encryption when selecting parameters, as this is where
///inexperienced users seem to most often make critical mistakes.
#[repr(C)]
#[derive(Debug)]
pub struct seal_EncryptionParameters {
    pub pool_: seal_MemoryPoolHandle,
    pub scheme_: seal_scheme_type,
    pub poly_modulus_degree_: usize,
    pub coeff_modulus_: [u64; 3usize],
    pub noise_standard_deviation_: f64,
    pub noise_max_deviation_: f64,
    pub random_generator_: [u64; 2usize],
    pub plain_modulus_: seal_util_global_variables_internal_mods_SmallModulus,
    pub parms_id_: seal_parms_id_type,
}
#[test]
fn bindgen_test_layout_seal_EncryptionParameters() {
    assert_eq!(
        ::std::mem::size_of::<seal_EncryptionParameters>(),
        168usize,
        concat!("Size of: ", stringify!(seal_EncryptionParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_EncryptionParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_EncryptionParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_EncryptionParameters>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).scheme_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(scheme_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).poly_modulus_degree_ as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(poly_modulus_degree_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).coeff_modulus_ as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(coeff_modulus_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).noise_standard_deviation_
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(noise_standard_deviation_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).noise_max_deviation_ as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(noise_max_deviation_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).random_generator_ as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(random_generator_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).plain_modulus_ as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(plain_modulus_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameters>())).parms_id_ as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameters),
            "::",
            stringify!(parms_id_)
        )
    );
}
extern "C" {
    ///Sets the degree of the polynomial modulus parameter to the specified value.
    ///The polynomial modulus directly affects the number of coefficients in
    ///plaintext polynomials, the size of ciphertext elements, the computational
    ///performance of the scheme (bigger is worse), and the security level (bigger
    ///is better). In SEAL the degree of the polynomial modulus must be a power
    ///of 2 (e.g.  1024, 2048, 4096, 8192, 16384, or 32768).
    ///
    ///@param[in] poly_modulus_degree The new polynomial modulus degree
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters23set_poly_modulus_degreeEm"]
    pub fn seal_EncryptionParameters_set_poly_modulus_degree(
        this: *mut seal_EncryptionParameters,
        poly_modulus_degree: usize,
    );
}
extern "C" {
    ///Sets the coefficient modulus parameter. The coefficient modulus consists
    ///of a list of distinct prime numbers, and is represented by a vector of
    ///SmallModulus objects. The coefficient modulus directly affects the size
    ///of ciphertext elements, the amount of computation that the scheme can perform
    ///(bigger is better), and the security level (bigger is worse). In SEAL each
    ///of the prime numbers in the coefficient modulus must be at most 60 bits,
    ///and must be congruent to 1 modulo 2*degree(poly_modulus).
    ///
    ///@param[in] coeff_modulus The new coefficient modulus
    ///@throws std::invalid_argument if size of coeff_modulus is invalid
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters17set_coeff_modulusERKSt6vectorINS_12SmallModulusESaIS2_EE"]
    pub fn seal_EncryptionParameters_set_coeff_modulus(
        this: *mut seal_EncryptionParameters,
        coeff_modulus: *const [u64; 3usize],
    );
}
extern "C" {
    ///Sets the plaintext modulus parameter. The plaintext modulus is an integer
    ///modulus represented by the SmallModulus class. The plaintext modulus
    ///determines the largest coefficient that plaintext polynomials can represent.
    ///It also affects the amount of computation that the scheme can perform
    ///(bigger is worse). In SEAL the plaintext modulus can be at most 60 bits
    ///long, but can otherwise be any integer. Note, however, that some features
    ///(e.g. batching) require the plaintext modulus to be of a particular form.
    ///
    ///@param[in] plain_modulus The new plaintext modulus
    ///@throws std::logic_error if scheme is not scheme_type::BFV
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters17set_plain_modulusERKNS_12SmallModulusE"]
    pub fn seal_EncryptionParameters_set_plain_modulus(
        this: *mut seal_EncryptionParameters,
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    );
}
extern "C" {
    ///Sets the plaintext modulus parameter. The plaintext modulus is an integer
    ///modulus represented by the SmallModulus class. This constructor instead
    ///takes a std::uint64_t and automatically creates the SmallModulus object.
    ///The plaintext modulus determines the largest coefficient that plaintext
    ///polynomials can represent. It also affects the amount of computation that
    ///the scheme can perform (bigger is worse). In SEAL the plaintext modulus
    ///can be at most 60 bits long, but can otherwise be any integer. Note,
    ///however, that some features (e.g. batching) require the plaintext modulus
    ///to be of a particular form.
    ///
    ///@param[in] plain_modulus The new plaintext modulus
    ///@throws std::invalid_argument if plain_modulus is invalid
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters17set_plain_modulusEm"]
    pub fn seal_EncryptionParameters_set_plain_modulus1(
        this: *mut seal_EncryptionParameters,
        plain_modulus: u64,
    );
}
extern "C" {
    ///Sets the standard deviation of the noise distribution used for error
    ///sampling. This parameter directly affects the security level of the scheme.
    ///However, it should not be necessary for most users to change this parameter
    ///from its default value.
    ///
    ///@param[in] noise_standard_deviation The new standard deviation
    ///@throw std::invalid_argument if noise_standard_deviation is negative or
    ///too large
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters28set_noise_standard_deviationEd"]
    pub fn seal_EncryptionParameters_set_noise_standard_deviation(
        this: *mut seal_EncryptionParameters,
        noise_standard_deviation: f64,
    );
}
extern "C" {
    ///Sets the random number generator factory to use for encryption. By default,
    ///the random generator is set to UniformRandomGeneratorFactory::default_factory().
    ///Setting this value allows a user to specify a custom random number generator
    ///source.
    ///
    ///@param[in] random_generator Pointer to the random generator factory
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters20set_random_generatorESt10shared_ptrINS_29UniformRandomGeneratorFactoryEE"]
    pub fn seal_EncryptionParameters_set_random_generator(
        this: *mut seal_EncryptionParameters,
        random_generator: [u64; 2usize],
    );
}
extern "C" {
    ///Returns the encryption scheme type.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters6schemeEv"]
    pub fn seal_EncryptionParameters_scheme(
        this: *const seal_EncryptionParameters,
    ) -> seal_scheme_type;
}
extern "C" {
    ///Returns the degree of the polynomial modulus parameter.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters19poly_modulus_degreeEv"]
    pub fn seal_EncryptionParameters_poly_modulus_degree(
        this: *const seal_EncryptionParameters,
    ) -> usize;
}
extern "C" {
    ///Returns a const reference to the currently set coefficient modulus parameter.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters13coeff_modulusEv"]
    pub fn seal_EncryptionParameters_coeff_modulus(
        this: *const seal_EncryptionParameters,
    ) -> *const [u64; 3usize];
}
extern "C" {
    ///Returns a const reference to the currently set plaintext modulus parameter.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters13plain_modulusEv"]
    pub fn seal_EncryptionParameters_plain_modulus(
        this: *const seal_EncryptionParameters,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///Returns the currently set standard deviation of the noise distribution.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters24noise_standard_deviationEv"]
    pub fn seal_EncryptionParameters_noise_standard_deviation(
        this: *const seal_EncryptionParameters,
    ) -> f64;
}
extern "C" {
    ///Returns the currently set maximum deviation of the noise distribution.
    ///This value cannot be directly controlled by the user, and is automatically
    ///set to be an appropriate multiple of the noise_standard_deviation parameter.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters19noise_max_deviationEv"]
    pub fn seal_EncryptionParameters_noise_max_deviation(
        this: *const seal_EncryptionParameters,
    ) -> f64;
}
extern "C" {
    ///Returns a pointer to the random number generator factory to use for encryption.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters16random_generatorEv"]
    pub fn seal_EncryptionParameters_random_generator(
        this: *const seal_EncryptionParameters,
    ) -> [u64; 2usize];
}
extern "C" {
    ///Returns the parms_id of the current parameters. This function is intended
    ///mainly for internal use.
    #[link_name = "\u{1}_ZNK4seal20EncryptionParameters8parms_idEv"]
    pub fn seal_EncryptionParameters_parms_id(
        this: *const seal_EncryptionParameters,
    ) -> *mut [u64; 4usize];
}
extern "C" {
    ///Saves EncryptionParameters to an output stream. The output is in binary
    ///format and is not human-readable. The output stream must have the "binary"
    ///flag set.
    ///
    ///@param[in] stream The stream to save the EncryptionParameters to
    ///@throws std::exception if the EncryptionParameters could not be written
    ///to stream
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters4SaveERKS0_RSo"]
    pub fn seal_EncryptionParameters_Save(
        parms: *const seal_EncryptionParameters,
        stream: *mut std_ostream,
    );
}
extern "C" {
    ///Loads EncryptionParameters from an input stream.
    ///
    ///@param[in] stream The stream to load the EncryptionParameters from
    ///@throws std::exception if valid EncryptionParameters could not be read
    ///from stream
    #[link_name = "\u{1}_ZN4seal20EncryptionParameters4LoadERSi"]
    pub fn seal_EncryptionParameters_Load(stream: *mut std_istream) -> seal_EncryptionParameters;
}
extern "C" {
    ///Creates an empty set of encryption parameters. At a minimum, the user needs
    ///to specify the parameters poly_modulus, coeff_modulus, and plain_modulus
    ///for the parameters to be usable.
    ///
    ///@throw std::invalid_argument if scheme is not supported
    ///@see scheme_type for the supported schemes
    #[link_name = "\u{1}_ZN4seal20EncryptionParametersC1ENS_11scheme_typeE"]
    pub fn seal_EncryptionParameters_EncryptionParameters(
        this: *mut seal_EncryptionParameters,
        scheme: seal_scheme_type,
    );
}
extern "C" {
    ///Creates a copy of a given instance of EncryptionParameters.
    ///
    ///@param[in] copy The EncryptionParameters to copy from
    #[link_name = "\u{1}_ZN4seal20EncryptionParametersC1ERKS0_"]
    pub fn seal_EncryptionParameters_EncryptionParameters1(
        this: *mut seal_EncryptionParameters,
        copy: *const seal_EncryptionParameters,
    );
}
extern "C" {
    ///Creates a new EncryptionParameters instance by moving a given instance.
    ///
    ///@param[in] source The EncryptionParameters to move from
    #[link_name = "\u{1}_ZN4seal20EncryptionParametersC1EOS0_"]
    pub fn seal_EncryptionParameters_EncryptionParameters2(
        this: *mut seal_EncryptionParameters,
        source: *mut seal_EncryptionParameters,
    );
}
impl Default for seal_EncryptionParameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_EncryptionParameters {
    #[inline]
    pub unsafe fn set_poly_modulus_degree(&mut self, poly_modulus_degree: usize) {
        seal_EncryptionParameters_set_poly_modulus_degree(self, poly_modulus_degree)
    }
    #[inline]
    pub unsafe fn set_coeff_modulus(&mut self, coeff_modulus: *const [u64; 3usize]) {
        seal_EncryptionParameters_set_coeff_modulus(self, coeff_modulus)
    }
    #[inline]
    pub unsafe fn set_plain_modulus(
        &mut self,
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) {
        seal_EncryptionParameters_set_plain_modulus(self, plain_modulus)
    }
    #[inline]
    pub unsafe fn set_plain_modulus1(&mut self, plain_modulus: u64) {
        seal_EncryptionParameters_set_plain_modulus1(self, plain_modulus)
    }
    #[inline]
    pub unsafe fn set_noise_standard_deviation(&mut self, noise_standard_deviation: f64) {
        seal_EncryptionParameters_set_noise_standard_deviation(self, noise_standard_deviation)
    }
    #[inline]
    pub unsafe fn set_random_generator(&mut self, random_generator: [u64; 2usize]) {
        seal_EncryptionParameters_set_random_generator(self, random_generator)
    }
    #[inline]
    pub unsafe fn scheme(&self) -> seal_scheme_type {
        seal_EncryptionParameters_scheme(self)
    }
    #[inline]
    pub unsafe fn poly_modulus_degree(&self) -> usize {
        seal_EncryptionParameters_poly_modulus_degree(self)
    }
    #[inline]
    pub unsafe fn coeff_modulus(&self) -> *const [u64; 3usize] {
        seal_EncryptionParameters_coeff_modulus(self)
    }
    #[inline]
    pub unsafe fn plain_modulus(
        &self,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus {
        seal_EncryptionParameters_plain_modulus(self)
    }
    #[inline]
    pub unsafe fn noise_standard_deviation(&self) -> f64 {
        seal_EncryptionParameters_noise_standard_deviation(self)
    }
    #[inline]
    pub unsafe fn noise_max_deviation(&self) -> f64 {
        seal_EncryptionParameters_noise_max_deviation(self)
    }
    #[inline]
    pub unsafe fn random_generator(&self) -> [u64; 2usize] {
        seal_EncryptionParameters_random_generator(self)
    }
    #[inline]
    pub unsafe fn parms_id(&self) -> *mut [u64; 4usize] {
        seal_EncryptionParameters_parms_id(self)
    }
    #[inline]
    pub unsafe fn Save(parms: *const seal_EncryptionParameters, stream: *mut std_ostream) {
        seal_EncryptionParameters_Save(parms, stream)
    }
    #[inline]
    pub unsafe fn Load(stream: *mut std_istream) -> seal_EncryptionParameters {
        seal_EncryptionParameters_Load(stream)
    }
    #[inline]
    pub unsafe fn new(scheme: seal_scheme_type) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_EncryptionParameters_EncryptionParameters(&mut __bindgen_tmp, scheme);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_EncryptionParameters) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_EncryptionParameters_EncryptionParameters1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_EncryptionParameters) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_EncryptionParameters_EncryptionParameters2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
///Stores a set of attributes (qualifiers) of a set of encryption parameters.
///These parameters are mainly used internally in various parts of the library, e.g.
///to determine which algorithmic optimizations the current support. The qualifiers
///are automatically created by the SEALContext class, silently passed on to classes
///such as Encryptor, Evaluator, and Decryptor, and the only way to change them is by
///changing the encryption parameters themselves. In other words, a user will never
///have to create their own instance of EncryptionParameterQualifiers, and in most
///cases never have to worry about them at all.
///
///@see EncryptionParameters::GetQualifiers for obtaining the EncryptionParameterQualifiers
///corresponding to the current parameter set.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seal_EncryptionParameterQualifiers {
    ///If the encryption parameters are set in a way that is considered valid by SEAL, the
    ///variable parameters_set is set to true.
    pub parameters_set: bool,
    ///Tells whether FFT can be used for polynomial multiplication. If the polynomial modulus
    ///is of the form X^N+1, where N is a power of two, then FFT can be used for fast
    ///multiplication of polynomials modulo the polynomial modulus. In this case the
    ///variable using_fft will be set to true. However, currently SEAL requires this
    ///to be the case for the parameters to be valid. Therefore, parameters_set can only
    ///be true if using_fft is true.
    pub using_fft: bool,
    ///Tells whether NTT can be used for polynomial multiplication. If the primes in the
    ///coefficient modulus are congruent to 1 modulo 2N, where X^N+1 is the polynomial
    ///modulus and N is a power of two, then the number-theoretic transform (NTT) can be
    ///used for fast multiplications of polynomials modulo the polynomial modulus and
    ///coefficient modulus. In this case the variable using_ntt will be set to true. However,
    ///currently SEAL requires this to be the case for the parameters to be valid. Therefore,
    ///parameters_set can only be true if using_ntt is true.
    pub using_ntt: bool,
    ///Tells whether batching is supported by the encryption parameters. If the plaintext
    ///modulus is congruent to 1 modulo 2N, where X^N+1 is the polynomial modulus and N is
    ///a power of two, then it is possible to use the BatchEncoder class to view plaintext
    ///elements as 2-by-(N/2) matrices of integers modulo the plaintext modulus. This is
    ///called batching, and allows the user to operate on the matrix elements (slots) in
    ///a SIMD fashion, and rotate the matrix rows and columns. When the computation is
    ///easily vectorizable, using batching can yield a huge performance boost. If the
    ///encryption parameters support batching, the variable using_batching is set to true.
    pub using_batching: bool,
    ///Tells whether fast plain lift is supported by the encryption parameters. A certain
    ///performance optimization in multiplication of a ciphertext by a plaintext
    ///(Evaluator::multiply_plain) and in transforming a plaintext element to NTT domain
    ///(Evaluator::transform_to_ntt) can be used when the plaintext modulus is smaller than
    ///each prime in the coefficient modulus. In this case the variable using_fast_plain_lift
    ///is set to true.
    pub using_fast_plain_lift: bool,
    ///Tells whether the encryption parameters are secure based on the standard parameters
    ///from HomomorphicEncryption.org security standard.
    pub using_he_std_security: bool,
}
#[test]
fn bindgen_test_layout_seal_EncryptionParameterQualifiers() {
    assert_eq!(
        ::std::mem::size_of::<seal_EncryptionParameterQualifiers>(),
        6usize,
        concat!("Size of: ", stringify!(seal_EncryptionParameterQualifiers))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_EncryptionParameterQualifiers>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(seal_EncryptionParameterQualifiers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameterQualifiers>())).parameters_set
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameterQualifiers),
            "::",
            stringify!(parameters_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameterQualifiers>())).using_fft as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameterQualifiers),
            "::",
            stringify!(using_fft)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameterQualifiers>())).using_ntt as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameterQualifiers),
            "::",
            stringify!(using_ntt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameterQualifiers>())).using_batching
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameterQualifiers),
            "::",
            stringify!(using_batching)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameterQualifiers>())).using_fast_plain_lift
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameterQualifiers),
            "::",
            stringify!(using_fast_plain_lift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_EncryptionParameterQualifiers>())).using_he_std_security
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_EncryptionParameterQualifiers),
            "::",
            stringify!(using_he_std_security)
        )
    );
}
///Performs sanity checks (validation) and pre-computations for a given set of encryption
///parameters. While the EncryptionParameters class is intended to be a light-weight class
///to store the encryption parameters, the SEALContext class is a heavy-weight class that
///is constructed from a given set of encryption parameters. It validates the parameters
///for correctness, evaluates their properties, and performs and stores the results of
///several costly pre-computations.
///
///After the user has set at least the poly_modulus, coeff_modulus, and plain_modulus
///parameters in a given EncryptionParameters instance, the parameters can be validated
///for correctness and functionality by constructing an instance of SEALContext. The
///constructor of SEALContext does all of its work automatically, and concludes by
///constructing and storing an instance of the EncryptionParameterQualifiers class, with
///its flags set according to the properties of the given parameters. If the created
///instance of EncryptionParameterQualifiers has the parameters_set flag set to true, the
///given parameter set has been deemed valid and is ready to be used. If the parameters
///were for some reason not appropriately set, the parameters_set flag will be false,
///and a new SEALContext will have to be created after the parameters are corrected.
///
///@see EncryptionParameters for more details on the parameters.
///@see EncryptionParameterQualifiers for more details on the qualifiers.
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_SEALContext {
    pub pool_: seal_MemoryPoolHandle,
    pub first_parms_id_: seal_parms_id_type,
    pub last_parms_id_: seal_parms_id_type,
    pub context_data_map_: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct seal_SEALContext_ContextData {
    pub pool_: seal_MemoryPoolHandle,
    pub parms_: seal_EncryptionParameters,
    pub qualifiers_: seal_EncryptionParameterQualifiers,
    pub base_converter_: seal_util_Pointer<seal_util_BaseConverter>,
    pub small_ntt_tables_: seal_util_Pointer<seal_util_SmallNTTTables>,
    pub plain_ntt_tables_: seal_util_Pointer<seal_util_SmallNTTTables>,
    pub total_coeff_modulus_: seal_util_Pointer<u64>,
    pub total_coeff_modulus_bit_count_: ::std::os::raw::c_int,
    pub coeff_div_plain_modulus_: seal_util_Pointer<u64>,
    pub plain_upper_half_threshold_: u64,
    pub plain_upper_half_increment_: seal_util_Pointer<u64>,
    pub upper_half_threshold_: seal_util_Pointer<u64>,
    pub upper_half_increment_: seal_util_Pointer<u64>,
    pub next_context_data_: [u64; 2usize],
    pub chain_index_: usize,
}
#[test]
fn bindgen_test_layout_seal_SEALContext_ContextData() {
    assert_eq!(
        ::std::mem::size_of::<seal_SEALContext_ContextData>(),
        488usize,
        concat!("Size of: ", stringify!(seal_SEALContext_ContextData))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_SEALContext_ContextData>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_SEALContext_ContextData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).pool_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).parms_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(parms_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).qualifiers_ as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(qualifiers_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).base_converter_ as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(base_converter_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).small_ntt_tables_ as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(small_ntt_tables_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).plain_ntt_tables_ as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(plain_ntt_tables_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).total_coeff_modulus_
                as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(total_coeff_modulus_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).total_coeff_modulus_bit_count_
                as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(total_coeff_modulus_bit_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).coeff_div_plain_modulus_
                as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(coeff_div_plain_modulus_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).plain_upper_half_threshold_
                as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(plain_upper_half_threshold_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).plain_upper_half_increment_
                as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(plain_upper_half_increment_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).upper_half_threshold_
                as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(upper_half_threshold_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).upper_half_increment_
                as *const _ as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(upper_half_increment_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).next_context_data_ as *const _
                as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(next_context_data_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext_ContextData>())).chain_index_ as *const _
                as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext_ContextData),
            "::",
            stringify!(chain_index_)
        )
    );
}
extern "C" {
    ///Returns a const reference to the underlying encryption parameters.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData5parmsEv"]
    pub fn seal_SEALContext_ContextData_parms(
        this: *const seal_SEALContext_ContextData,
    ) -> *mut seal_EncryptionParameters;
}
extern "C" {
    ///Returns a copy of EncryptionParameterQualifiers corresponding to the
    ///current encryption parameters. Note that to change the qualifiers it is
    ///necessary to create a new instance of SEALContext once appropriate changes
    ///to the encryption parameters have been made.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData10qualifiersEv"]
    pub fn seal_SEALContext_ContextData_qualifiers(
        this: *const seal_SEALContext_ContextData,
    ) -> seal_EncryptionParameterQualifiers;
}
extern "C" {
    ///Returns a pointer to a pre-computed product of all primes in the coefficient
    ///modulus. The security of the encryption parameters largely depends on the
    ///bit-length of this product, and on the degree of the polynomial modulus.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData19total_coeff_modulusEv"]
    pub fn seal_SEALContext_ContextData_total_coeff_modulus(
        this: *const seal_SEALContext_ContextData,
    ) -> *const u64;
}
extern "C" {
    ///Returns the significant bit count of the total coefficient modulus.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData29total_coeff_modulus_bit_countEv"]
    pub fn seal_SEALContext_ContextData_total_coeff_modulus_bit_count(
        this: *const seal_SEALContext_ContextData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///Returns a const reference to the base converter.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData14base_converterEv"]
    pub fn seal_SEALContext_ContextData_base_converter(
        this: *const seal_SEALContext_ContextData,
    ) -> *mut seal_util_Pointer<seal_util_BaseConverter>;
}
extern "C" {
    ///Returns a const reference to the NTT tables.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData16small_ntt_tablesEv"]
    pub fn seal_SEALContext_ContextData_small_ntt_tables(
        this: *const seal_SEALContext_ContextData,
    ) -> *mut seal_util_Pointer<seal_util_SmallNTTTables>;
}
extern "C" {
    ///Returns a const reference to the NTT tables.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData16plain_ntt_tablesEv"]
    pub fn seal_SEALContext_ContextData_plain_ntt_tables(
        this: *const seal_SEALContext_ContextData,
    ) -> *mut seal_util_Pointer<seal_util_SmallNTTTables>;
}
extern "C" {
    ///Return a pointer to BFV "Delta", i.e. coefficient modulus divided by
    ///plaintext modulus.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData23coeff_div_plain_modulusEv"]
    pub fn seal_SEALContext_ContextData_coeff_div_plain_modulus(
        this: *const seal_SEALContext_ContextData,
    ) -> *const u64;
}
extern "C" {
    ///Return the threshold for the upper half of integers modulo plain_modulus.
    ///This is simply (plain_modulus + 1) / 2.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData26plain_upper_half_thresholdEv"]
    pub fn seal_SEALContext_ContextData_plain_upper_half_threshold(
        this: *const seal_SEALContext_ContextData,
    ) -> u64;
}
extern "C" {
    ///Return a pointer to the plaintext upper half increment, i.e. coeff_modulus
    ///minus plain_modulus. The upper half increment is represented as an integer
    ///for the full product coeff_modulus if using_fast_plain_lift is false and is
    ///otherwise represented modulo each of the coeff_modulus primes in order.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData26plain_upper_half_incrementEv"]
    pub fn seal_SEALContext_ContextData_plain_upper_half_increment(
        this: *const seal_SEALContext_ContextData,
    ) -> *const u64;
}
extern "C" {
    ///Return a pointer to the upper half threshold with respect to the total
    ///coefficient modulus. This is needed in CKKS decryption.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData20upper_half_thresholdEv"]
    pub fn seal_SEALContext_ContextData_upper_half_threshold(
        this: *const seal_SEALContext_ContextData,
    ) -> *const u64;
}
extern "C" {
    ///Return a pointer to the upper half increment used for computing Delta*m
    ///and converting the coefficients to modulo coeff_modulus. For example,
    ///t-1 in plaintext should change into
    ///q - Delta = Delta*t + r_t(q) - Delta
    ///= Delta*(t-1) + r_t(q)
    ///so multiplying the message by Delta is not enough and requires also an
    ///addition of r_t(q). This is precisely the upper_half_increment. Note that
    ///this operation is only done for negative message coefficients, i.e. those
    ///that exceed plain_upper_half_threshold.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData20upper_half_incrementEv"]
    pub fn seal_SEALContext_ContextData_upper_half_increment(
        this: *const seal_SEALContext_ContextData,
    ) -> *const u64;
}
extern "C" {
    ///Returns a shared_ptr to the context data corresponding to the next parameters
    ///in the modulus switching chain. If the current data is the last one in the
    ///chain, then the result is nullptr.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData17next_context_dataEv"]
    pub fn seal_SEALContext_ContextData_next_context_data(
        this: *const seal_SEALContext_ContextData,
    ) -> [u64; 2usize];
}
extern "C" {
    ///Returns the index of the parameter set in a chain. The initial parameters
    ///have index 0 and the index increases sequentially in the parameter chain.
    #[link_name = "\u{1}_ZNK4seal11SEALContext11ContextData11chain_indexEv"]
    pub fn seal_SEALContext_ContextData_chain_index(
        this: *const seal_SEALContext_ContextData,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal11SEALContext11ContextDataC1Ev"]
    pub fn seal_SEALContext_ContextData_ContextData(this: *mut seal_SEALContext_ContextData);
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal11SEALContext11ContextDataC1ERKS1_"]
    pub fn seal_SEALContext_ContextData_ContextData1(
        this: *mut seal_SEALContext_ContextData,
        copy: *const seal_SEALContext_ContextData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal11SEALContext11ContextDataC1EOS1_"]
    pub fn seal_SEALContext_ContextData_ContextData2(
        this: *mut seal_SEALContext_ContextData,
        move_: *mut seal_SEALContext_ContextData,
    );
}
impl Default for seal_SEALContext_ContextData {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_SEALContext_ContextData {
    #[inline]
    pub unsafe fn parms(&self) -> *mut seal_EncryptionParameters {
        seal_SEALContext_ContextData_parms(self)
    }
    #[inline]
    pub unsafe fn qualifiers(&self) -> seal_EncryptionParameterQualifiers {
        seal_SEALContext_ContextData_qualifiers(self)
    }
    #[inline]
    pub unsafe fn total_coeff_modulus(&self) -> *const u64 {
        seal_SEALContext_ContextData_total_coeff_modulus(self)
    }
    #[inline]
    pub unsafe fn total_coeff_modulus_bit_count(&self) -> ::std::os::raw::c_int {
        seal_SEALContext_ContextData_total_coeff_modulus_bit_count(self)
    }
    #[inline]
    pub unsafe fn base_converter(&self) -> *mut seal_util_Pointer<seal_util_BaseConverter> {
        seal_SEALContext_ContextData_base_converter(self)
    }
    #[inline]
    pub unsafe fn small_ntt_tables(&self) -> *mut seal_util_Pointer<seal_util_SmallNTTTables> {
        seal_SEALContext_ContextData_small_ntt_tables(self)
    }
    #[inline]
    pub unsafe fn plain_ntt_tables(&self) -> *mut seal_util_Pointer<seal_util_SmallNTTTables> {
        seal_SEALContext_ContextData_plain_ntt_tables(self)
    }
    #[inline]
    pub unsafe fn coeff_div_plain_modulus(&self) -> *const u64 {
        seal_SEALContext_ContextData_coeff_div_plain_modulus(self)
    }
    #[inline]
    pub unsafe fn plain_upper_half_threshold(&self) -> u64 {
        seal_SEALContext_ContextData_plain_upper_half_threshold(self)
    }
    #[inline]
    pub unsafe fn plain_upper_half_increment(&self) -> *const u64 {
        seal_SEALContext_ContextData_plain_upper_half_increment(self)
    }
    #[inline]
    pub unsafe fn upper_half_threshold(&self) -> *const u64 {
        seal_SEALContext_ContextData_upper_half_threshold(self)
    }
    #[inline]
    pub unsafe fn upper_half_increment(&self) -> *const u64 {
        seal_SEALContext_ContextData_upper_half_increment(self)
    }
    #[inline]
    pub unsafe fn next_context_data(&self) -> [u64; 2usize] {
        seal_SEALContext_ContextData_next_context_data(self)
    }
    #[inline]
    pub unsafe fn chain_index(&self) -> usize {
        seal_SEALContext_ContextData_chain_index(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_SEALContext_ContextData_ContextData(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_SEALContext_ContextData) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_SEALContext_ContextData_ContextData1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(move_: *mut seal_SEALContext_ContextData) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_SEALContext_ContextData_ContextData2(&mut __bindgen_tmp, move_);
        __bindgen_tmp
    }
}
#[test]
fn bindgen_test_layout_seal_SEALContext() {
    assert_eq!(
        ::std::mem::size_of::<seal_SEALContext>(),
        136usize,
        concat!("Size of: ", stringify!(seal_SEALContext))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_SEALContext>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_SEALContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_SEALContext>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext>())).first_parms_id_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext),
            "::",
            stringify!(first_parms_id_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_SEALContext>())).last_parms_id_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext),
            "::",
            stringify!(last_parms_id_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_SEALContext>())).context_data_map_ as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SEALContext),
            "::",
            stringify!(context_data_map_)
        )
    );
}
extern "C" {
    ///Creates an instance of SEALContext, and performs several pre-computations
    ///on the given EncryptionParameters.
    ///
    ///@param[in] parms The encryption parameters
    ///@param[in] expand_mod_chain Determines whether the modulus switching chain
    ///should be created
    #[link_name = "\u{1}_ZN4seal11SEALContext6CreateERKNS_20EncryptionParametersEb"]
    pub fn seal_SEALContext_Create(
        parms: *const seal_EncryptionParameters,
        expand_mod_chain: bool,
    ) -> [u64; 2usize];
}
extern "C" {
    ///Returns a const reference to ContextData class corresponding to the
    ///encryption parameters. This is the first set of parameters in a chain
    ///of parameters when modulus switching is used.
    #[link_name = "\u{1}_ZNK4seal11SEALContext12context_dataEv"]
    pub fn seal_SEALContext_context_data(this: *const seal_SEALContext) -> [u64; 2usize];
}
extern "C" {
    ///Returns an optional const reference to ContextData class corresponding to
    ///the parameters with a given parms_id. If parameters with the given parms_id
    ///are not found then the function returns nullptr.
    ///
    ///@param[in] parms_id The parms_id of the encryption parameters
    #[link_name = "\u{1}_ZNK4seal11SEALContext12context_dataESt5arrayImLm4EE"]
    pub fn seal_SEALContext_context_data1(
        this: *const seal_SEALContext,
        parms_id: seal_parms_id_type,
    ) -> [u64; 2usize];
}
extern "C" {
    ///Returns whether the encryption parameters are valid.
    #[link_name = "\u{1}_ZNK4seal11SEALContext14parameters_setEv"]
    pub fn seal_SEALContext_parameters_set(this: *const seal_SEALContext) -> bool;
}
extern "C" {
    ///Returns a parms_id_type corresponding to the first set
    ///of encryption parameters.
    #[link_name = "\u{1}_ZNK4seal11SEALContext14first_parms_idEv"]
    pub fn seal_SEALContext_first_parms_id(this: *const seal_SEALContext) -> *mut [u64; 4usize];
}
extern "C" {
    ///Returns a parms_id_type corresponding to the last set
    ///of encryption parameters.
    #[link_name = "\u{1}_ZNK4seal11SEALContext13last_parms_idEv"]
    pub fn seal_SEALContext_last_parms_id(this: *const seal_SEALContext) -> *mut [u64; 4usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal11SEALContextC1Ev"]
    pub fn seal_SEALContext_SEALContext(this: *mut seal_SEALContext);
}
impl seal_SEALContext {
    #[inline]
    pub unsafe fn Create(
        parms: *const seal_EncryptionParameters,
        expand_mod_chain: bool,
    ) -> [u64; 2usize] {
        seal_SEALContext_Create(parms, expand_mod_chain)
    }
    #[inline]
    pub unsafe fn context_data(&self) -> [u64; 2usize] {
        seal_SEALContext_context_data(self)
    }
    #[inline]
    pub unsafe fn context_data1(&self, parms_id: seal_parms_id_type) -> [u64; 2usize] {
        seal_SEALContext_context_data1(self, parms_id)
    }
    #[inline]
    pub unsafe fn parameters_set(&self) -> bool {
        seal_SEALContext_parameters_set(self)
    }
    #[inline]
    pub unsafe fn first_parms_id(&self) -> *mut [u64; 4usize] {
        seal_SEALContext_first_parms_id(self)
    }
    #[inline]
    pub unsafe fn last_parms_id(&self) -> *mut [u64; 4usize] {
        seal_SEALContext_last_parms_id(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_SEALContext_SEALContext(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
///A resizable container for storing an array of integral data types. The
///allocations are done from a memory pool. The IntArray class is mainly
///intended for internal use and provides the underlying data structure for
///Plaintext and Ciphertext classes.
///
///@par Size and Capacity
///IntArray allows the user to pre-allocate memory (capacity) for the array
///in cases where the array is known to be resized in the future and memory
///moves are to be avoided at the time of resizing. The size of the IntArray
///can never exceed its capacity. The capacity and size can be changed using
///the reserve and resize functions, respectively.
///
///@par Thread Safety
///In general, reading from IntArray is thread-safe as long as no other thread
///is concurrently mutating it.
#[repr(C)]
#[derive(Debug)]
pub struct seal_IntArray {
    pub pool_: seal_MemoryPoolHandle,
    pub capacity_: seal_IntArray_size_type,
    pub size_: seal_IntArray_size_type,
    pub data_: seal_util_Pointer<u64>,
}
pub type seal_IntArray_size_type = usize;
impl Default for seal_IntArray {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///Class to store a ciphertext element. The data for a ciphertext consists
///of two or more polynomials, which are in SEAL stored in a CRT form with
///respect to the factors of the coefficient modulus. This data itself is
///not meant to be modified directly by the user, but is instead operated
///on by functions in the Evaluator class. The size of the backing array of
///a ciphertext depends on the encryption parameters and the size of the
///ciphertext (at least 2). If the degree of the poly_modulus encryption
///parameter is N, and the number of primes in the coeff_modulus encryption
///parameter is K, then the ciphertext backing array requires precisely
///8*N*K*size bytes of memory. A ciphertext also carries with it the
///parms_id of its associated encryption parameters, which is used to check
///the validity of the ciphertext for homomorphic operations and decryption.
///
///@par Memory Management
///The size of a ciphertext refers to the number of polynomials it contains,
///whereas its capacity refers to the number of polynomials that fit in the
///current memory allocation. In high-performance applications unnecessary
///re-allocations should be avoided by reserving enough memory for the
///ciphertext to begin with either by providing the desired capacity to the
///constructor as an extra argument, or by calling the reserve function at
///any time.
///
///@par Thread Safety
///In general, reading from ciphertext is thread-safe as long as no other
///thread is concurrently mutating it. This is due to the underlying data
///structure storing the ciphertext not being thread-safe.
///
///@see Plaintext for the class that stores plaintexts.
#[repr(C)]
#[derive(Debug)]
pub struct seal_Ciphertext {
    pub parms_id_: seal_parms_id_type,
    pub is_ntt_form_: bool,
    pub size_capacity_: seal_Ciphertext_size_type,
    pub size_: seal_Ciphertext_size_type,
    pub poly_modulus_degree_: seal_Ciphertext_size_type,
    pub coeff_mod_count_: seal_Ciphertext_size_type,
    pub scale_: f64,
    pub data_: seal_IntArray,
}
pub type seal_Ciphertext_ct_coeff_type = u64;
pub type seal_Ciphertext_size_type = size_type;
#[test]
fn bindgen_test_layout_seal_Ciphertext() {
    assert_eq!(
        ::std::mem::size_of::<seal_Ciphertext>(),
        144usize,
        concat!("Size of: ", stringify!(seal_Ciphertext))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_Ciphertext>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_Ciphertext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Ciphertext>())).parms_id_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Ciphertext),
            "::",
            stringify!(parms_id_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Ciphertext>())).is_ntt_form_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Ciphertext),
            "::",
            stringify!(is_ntt_form_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Ciphertext>())).size_capacity_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Ciphertext),
            "::",
            stringify!(size_capacity_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Ciphertext>())).size_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Ciphertext),
            "::",
            stringify!(size_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_Ciphertext>())).poly_modulus_degree_ as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Ciphertext),
            "::",
            stringify!(poly_modulus_degree_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_Ciphertext>())).coeff_mod_count_ as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Ciphertext),
            "::",
            stringify!(coeff_mod_count_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Ciphertext>())).scale_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Ciphertext),
            "::",
            stringify!(scale_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Ciphertext>())).data_ as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Ciphertext),
            "::",
            stringify!(data_)
        )
    );
}
extern "C" {
    ///Allocates enough memory to accommodate the backing array of a ciphertext
    ///with given capacity. In addition to the capacity, the allocation size is
    ///determined by the encryption parameters corresponing to the given
    ///parms_id.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] parms_id The parms_id corresponding to the encryption
    ///parameters to be used
    ///@param[in] size_capacity The capacity
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::invalid_argument if parms_id is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if size_capacity is less than 2 or too large
    #[link_name = "\u{1}_ZN4seal10Ciphertext7reserveESt10shared_ptrINS_11SEALContextEESt5arrayImLm4EEm"]
    pub fn seal_Ciphertext_reserve(
        this: *mut seal_Ciphertext,
        context: [u64; 2usize],
        parms_id: seal_parms_id_type,
        size_capacity: seal_Ciphertext_size_type,
    );
}
extern "C" {
    ///Allocates enough memory to accommodate the backing array of a ciphertext
    ///with given capacity. In addition to the capacity, the allocation size is
    ///determined by the highest-level parameters associated to the given
    ///SEALContext.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] size_capacity The capacity
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::invalid_argument if size_capacity is less than 2 or too large
    #[link_name = "\u{1}_ZN4seal10Ciphertext7reserveESt10shared_ptrINS_11SEALContextEEm"]
    pub fn seal_Ciphertext_reserve1(
        this: *mut seal_Ciphertext,
        context: [u64; 2usize],
        size_capacity: seal_Ciphertext_size_type,
    );
}
extern "C" {
    ///Allocates enough memory to accommodate the backing array of a ciphertext
    ///with given capacity. In addition to the capacity, the allocation size is
    ///determined by the current encryption parameters.
    ///
    ///@param[in] size_capacity The capacity
    ///@throws std::invalid_argument if size_capacity is less than 2 or too large
    ///@throws std::logic_error if the encryption parameters are not
    #[link_name = "\u{1}_ZN4seal10Ciphertext7reserveEm"]
    pub fn seal_Ciphertext_reserve2(
        this: *mut seal_Ciphertext,
        size_capacity: seal_Ciphertext_size_type,
    );
}
extern "C" {
    ///Resizes the ciphertext to given size, reallocating if the capacity
    ///of the ciphertext is too small. The ciphertext parameters are
    ///determined by the given SEALContext and parms_id.
    ///
    ///This function is mainly intended for internal use and is called
    ///automatically by functions such as Evaluator::multiply and
    ///Evaluator::relinearize. A normal user should never have a reason
    ///to manually resize a ciphertext.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] parms_id The parms_id corresponding to the encryption
    ///parameters to be used
    ///@param[in] size The new size
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::invalid_argument if parms_id is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if size is less than 2 or too large
    #[link_name = "\u{1}_ZN4seal10Ciphertext6resizeESt10shared_ptrINS_11SEALContextEESt5arrayImLm4EEm"]
    pub fn seal_Ciphertext_resize(
        this: *mut seal_Ciphertext,
        context: [u64; 2usize],
        parms_id: seal_parms_id_type,
        size: seal_Ciphertext_size_type,
    );
}
extern "C" {
    ///Resizes the ciphertext to given size, reallocating if the capacity
    ///of the ciphertext is too small. The ciphertext parameters are
    ///determined by the highest-level parameters associated to the given
    ///SEALContext.
    ///
    ///This function is mainly intended for internal use and is called
    ///automatically by functions such as Evaluator::multiply and
    ///Evaluator::relinearize. A normal user should never have a reason
    ///to manually resize a ciphertext.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] size The new size
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::invalid_argument if size is less than 2 or too large
    #[link_name = "\u{1}_ZN4seal10Ciphertext6resizeESt10shared_ptrINS_11SEALContextEEm"]
    pub fn seal_Ciphertext_resize1(
        this: *mut seal_Ciphertext,
        context: [u64; 2usize],
        size: seal_Ciphertext_size_type,
    );
}
extern "C" {
    ///Resizes the ciphertext to given size, reallocating if the capacity
    ///of the ciphertext is too small.
    ///
    ///This function is mainly intended for internal use and is called
    ///automatically by functions such as Evaluator::multiply and
    ///Evaluator::relinearize. A normal user should never have a reason
    ///to manually resize a ciphertext.
    ///
    ///@param[in] size The new size
    ///@throws std::invalid_argument if size is less than 2 or too large
    #[link_name = "\u{1}_ZN4seal10Ciphertext6resizeEm"]
    pub fn seal_Ciphertext_resize2(this: *mut seal_Ciphertext, size: seal_Ciphertext_size_type);
}
extern "C" {
    ///Resets the ciphertext. This function releases any memory allocated
    ///by the ciphertext, returning it to the memory pool. It also sets all
    ///encryption parameter specific size information to zero.
    #[link_name = "\u{1}_ZN4seal10Ciphertext7releaseEv"]
    pub fn seal_Ciphertext_release(this: *mut seal_Ciphertext);
}
extern "C" {
    ///Returns a pointer to the beginning of the ciphertext data.
    #[link_name = "\u{1}_ZN4seal10Ciphertext4dataEv"]
    pub fn seal_Ciphertext_data(this: *mut seal_Ciphertext) -> *mut seal_Ciphertext_ct_coeff_type;
}
extern "C" {
    ///Returns a const pointer to the beginning of the ciphertext data.
    #[link_name = "\u{1}_ZNK4seal10Ciphertext4dataEv"]
    pub fn seal_Ciphertext_data1(
        this: *const seal_Ciphertext,
    ) -> *const seal_Ciphertext_ct_coeff_type;
}
extern "C" {
    ///Returns a pointer to a particular polynomial in the ciphertext
    ///data. Note that SEAL stores each polynomial in the ciphertext
    ///modulo all of the K primes in the coefficient modulus. The pointer
    ///returned by this function is to the beginning (constant coefficient)
    ///of the first one of these K polynomials.
    ///
    ///@param[in] poly_index The index of the polynomial in the ciphertext
    ///@throws std::out_of_range if poly_index is less than 0 or bigger
    ///than the size of the ciphertext
    #[link_name = "\u{1}_ZN4seal10Ciphertext4dataEm"]
    pub fn seal_Ciphertext_data2(
        this: *mut seal_Ciphertext,
        poly_index: seal_Ciphertext_size_type,
    ) -> *mut seal_Ciphertext_ct_coeff_type;
}
extern "C" {
    ///Returns a const pointer to a particular polynomial in the
    ///ciphertext data. Note that SEAL stores each polynomial in the
    ///ciphertext modulo all of the K primes in the coefficient modulus.
    ///The pointer returned by this function is to the beginning
    ///(constant coefficient) of the first one of these K polynomials.
    ///
    ///@param[in] poly_index The index of the polynomial in the ciphertext
    ///@throws std::out_of_range if poly_index is out of range
    #[link_name = "\u{1}_ZNK4seal10Ciphertext4dataEm"]
    pub fn seal_Ciphertext_data3(
        this: *const seal_Ciphertext,
        poly_index: seal_Ciphertext_size_type,
    ) -> *const seal_Ciphertext_ct_coeff_type;
}
extern "C" {
    ///Returns the number of primes in the coefficient modulus of the
    ///associated encryption parameters. This directly affects the
    ///allocation size of the ciphertext.
    #[link_name = "\u{1}_ZNK4seal10Ciphertext15coeff_mod_countEv"]
    pub fn seal_Ciphertext_coeff_mod_count(
        this: *const seal_Ciphertext,
    ) -> seal_Ciphertext_size_type;
}
extern "C" {
    ///Returns the degree of the polynomial modulus of the associated
    ///encryption parameters. This directly affects the allocation size
    ///of the ciphertext.
    #[link_name = "\u{1}_ZNK4seal10Ciphertext19poly_modulus_degreeEv"]
    pub fn seal_Ciphertext_poly_modulus_degree(
        this: *const seal_Ciphertext,
    ) -> seal_Ciphertext_size_type;
}
extern "C" {
    ///Returns the capacity of the allocation. This means the largest size
    ///of the ciphertext that can be stored in the current allocation with
    ///the current encryption parameters.
    #[link_name = "\u{1}_ZNK4seal10Ciphertext13size_capacityEv"]
    pub fn seal_Ciphertext_size_capacity(this: *const seal_Ciphertext)
        -> seal_Ciphertext_size_type;
}
extern "C" {
    ///Returns the size of the ciphertext.
    #[link_name = "\u{1}_ZNK4seal10Ciphertext4sizeEv"]
    pub fn seal_Ciphertext_size(this: *const seal_Ciphertext) -> seal_Ciphertext_size_type;
}
extern "C" {
    ///Returns the total size of the current allocation in 64-bit words.
    #[link_name = "\u{1}_ZNK4seal10Ciphertext21uint64_count_capacityEv"]
    pub fn seal_Ciphertext_uint64_count_capacity(
        this: *const seal_Ciphertext,
    ) -> seal_Ciphertext_size_type;
}
extern "C" {
    ///Returns the total size of the current ciphertext in 64-bit words.
    #[link_name = "\u{1}_ZNK4seal10Ciphertext12uint64_countEv"]
    pub fn seal_Ciphertext_uint64_count(this: *const seal_Ciphertext) -> seal_Ciphertext_size_type;
}
extern "C" {
    ///Check whether the current ciphertext is valid for a given SEALContext.
    ///If the given SEALContext is not set, the encryption parameters are invalid,
    ///or the ciphertext data does not match the SEALContext, this function
    ///returns false. Otherwise, returns true.
    ///
    ///@param[in] context The SEALContext
    #[link_name = "\u{1}_ZNK4seal10Ciphertext12is_valid_forESt10shared_ptrINS_11SEALContextEE"]
    pub fn seal_Ciphertext_is_valid_for(
        this: *const seal_Ciphertext,
        context: [u64; 2usize],
    ) -> bool;
}
extern "C" {
    ///Saves the ciphertext to an output stream. The output is in binary format
    ///and not human-readable. The output stream must have the "binary" flag set.
    ///
    ///@param[in] stream The stream to save the ciphertext to
    ///@throws std::exception if the ciphertext could not be written to stream
    #[link_name = "\u{1}_ZNK4seal10Ciphertext4saveERSo"]
    pub fn seal_Ciphertext_save(this: *const seal_Ciphertext, stream: *mut std_ostream);
}
extern "C" {
    ///Loads a ciphertext from an input stream overwriting the current ciphertext.
    ///No checking of the validity of the ciphertext data against encryption
    ///parameters is performed. This function should not be used unless the
    ///ciphertext comes from a fully trusted source.
    ///
    ///@param[in] stream The stream to load the ciphertext from
    ///@throws std::exception if a valid ciphertext could not be read from stream
    #[link_name = "\u{1}_ZN4seal10Ciphertext11unsafe_loadERSi"]
    pub fn seal_Ciphertext_unsafe_load(this: *mut seal_Ciphertext, stream: *mut std_istream);
}
extern "C" {
    ///Loads a ciphertext from an input stream overwriting the current ciphertext.
    ///The loaded ciphertext is verified to be valid for the given SEALContext.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] stream The stream to load the ciphertext from
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::exception if a valid ciphertext could not be read from stream
    ///@throws std::invalid_argument if the loaded ciphertext is invalid for the
    ///context
    #[link_name = "\u{1}_ZN4seal10Ciphertext4loadESt10shared_ptrINS_11SEALContextEERSi"]
    pub fn seal_Ciphertext_load(
        this: *mut seal_Ciphertext,
        context: [u64; 2usize],
        stream: *mut std_istream,
    );
}
extern "C" {
    ///Returns whether the ciphertext is in NTT form.
    #[link_name = "\u{1}_ZNK4seal10Ciphertext11is_ntt_formEv"]
    pub fn seal_Ciphertext_is_ntt_form(this: *const seal_Ciphertext) -> bool;
}
extern "C" {
    ///Returns whether the ciphertext is in NTT form.
    #[link_name = "\u{1}_ZN4seal10Ciphertext11is_ntt_formEv"]
    pub fn seal_Ciphertext_is_ntt_form1(this: *mut seal_Ciphertext) -> *mut bool;
}
extern "C" {
    ///Returns a reference to parms_id.
    ///
    ///@see EncryptionParameters for more information about parms_id.
    #[link_name = "\u{1}_ZN4seal10Ciphertext8parms_idEv"]
    pub fn seal_Ciphertext_parms_id(this: *mut seal_Ciphertext) -> *mut [u64; 4usize];
}
extern "C" {
    ///Returns a const reference to parms_id.
    ///
    ///@see EncryptionParameters for more information about parms_id.
    #[link_name = "\u{1}_ZNK4seal10Ciphertext8parms_idEv"]
    pub fn seal_Ciphertext_parms_id1(this: *const seal_Ciphertext) -> *mut [u64; 4usize];
}
extern "C" {
    ///Returns a reference to the scale. This is only needed when using the
    ///CKKS encryption scheme. The user should have little or no reason to ever
    ///change the scale by hand.
    #[link_name = "\u{1}_ZN4seal10Ciphertext5scaleEv"]
    pub fn seal_Ciphertext_scale(this: *mut seal_Ciphertext) -> *mut f64;
}
extern "C" {
    ///Returns a constant reference to the scale. This is only needed when
    ///using the CKKS encryption scheme.
    #[link_name = "\u{1}_ZNK4seal10Ciphertext5scaleEv"]
    pub fn seal_Ciphertext_scale1(this: *const seal_Ciphertext) -> *const f64;
}
extern "C" {
    ///Returns the currently used MemoryPoolHandle.
    #[link_name = "\u{1}_ZNK4seal10Ciphertext4poolEv"]
    pub fn seal_Ciphertext_pool(this: *const seal_Ciphertext) -> seal_MemoryPoolHandle;
}
extern "C" {
    ///Constructs an empty ciphertext allocating no memory.
    ///
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal10CiphertextC1ENS_16MemoryPoolHandleE"]
    pub fn seal_Ciphertext_Ciphertext(this: *mut seal_Ciphertext, pool: seal_MemoryPoolHandle);
}
extern "C" {
    ///Constructs an empty ciphertext with capacity 2. In addition to the
    ///capacity, the allocation size is determined by the highest-level
    ///parameters associated to the given SEALContext.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal10CiphertextC1ESt10shared_ptrINS_11SEALContextEENS_16MemoryPoolHandleE"]
    pub fn seal_Ciphertext_Ciphertext1(
        this: *mut seal_Ciphertext,
        context: [u64; 2usize],
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Constructs an empty ciphertext with capacity 2. In addition to the
    ///capacity, the allocation size is determined by the encryption parameters
    ///with given parms_id.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] parms_id The parms_id corresponding to the encryption
    ///parameters to be used
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::invalid_argument if parms_id is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal10CiphertextC1ESt10shared_ptrINS_11SEALContextEESt5arrayImLm4EENS_16MemoryPoolHandleE"]
    pub fn seal_Ciphertext_Ciphertext2(
        this: *mut seal_Ciphertext,
        context: [u64; 2usize],
        parms_id: seal_parms_id_type,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Constructs an empty ciphertext with given capacity. In addition to
    ///the capacity, the allocation size is determined by the given
    ///encryption parameters.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] parms_id The parms_id corresponding to the encryption
    ///parameters to be used
    ///@param[in] size_capacity The capacity
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::invalid_argument if parms_id is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if size_capacity is less than 2 or too large
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal10CiphertextC1ESt10shared_ptrINS_11SEALContextEESt5arrayImLm4EEmNS_16MemoryPoolHandleE"]
    pub fn seal_Ciphertext_Ciphertext3(
        this: *mut seal_Ciphertext,
        context: [u64; 2usize],
        parms_id: seal_parms_id_type,
        size_capacity: seal_Ciphertext_size_type,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Constructs a new ciphertext by copying a given one.
    ///
    ///@param[in] copy The ciphertext to copy from
    #[link_name = "\u{1}_ZN4seal10CiphertextC1ERKS0_"]
    pub fn seal_Ciphertext_Ciphertext4(this: *mut seal_Ciphertext, copy: *const seal_Ciphertext);
}
extern "C" {
    ///Creates a new ciphertext by moving a given one.
    ///
    ///@param[in] source The ciphertext to move from
    #[link_name = "\u{1}_ZN4seal10CiphertextC1EOS0_"]
    pub fn seal_Ciphertext_Ciphertext5(this: *mut seal_Ciphertext, source: *mut seal_Ciphertext);
}
impl Default for seal_Ciphertext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_Ciphertext {
    #[inline]
    pub unsafe fn reserve(
        &mut self,
        context: [u64; 2usize],
        parms_id: seal_parms_id_type,
        size_capacity: seal_Ciphertext_size_type,
    ) {
        seal_Ciphertext_reserve(self, context, parms_id, size_capacity)
    }
    #[inline]
    pub unsafe fn reserve1(
        &mut self,
        context: [u64; 2usize],
        size_capacity: seal_Ciphertext_size_type,
    ) {
        seal_Ciphertext_reserve1(self, context, size_capacity)
    }
    #[inline]
    pub unsafe fn reserve2(&mut self, size_capacity: seal_Ciphertext_size_type) {
        seal_Ciphertext_reserve2(self, size_capacity)
    }
    #[inline]
    pub unsafe fn resize(
        &mut self,
        context: [u64; 2usize],
        parms_id: seal_parms_id_type,
        size: seal_Ciphertext_size_type,
    ) {
        seal_Ciphertext_resize(self, context, parms_id, size)
    }
    #[inline]
    pub unsafe fn resize1(&mut self, context: [u64; 2usize], size: seal_Ciphertext_size_type) {
        seal_Ciphertext_resize1(self, context, size)
    }
    #[inline]
    pub unsafe fn resize2(&mut self, size: seal_Ciphertext_size_type) {
        seal_Ciphertext_resize2(self, size)
    }
    #[inline]
    pub unsafe fn release(&mut self) {
        seal_Ciphertext_release(self)
    }
    #[inline]
    pub unsafe fn data(&mut self) -> *mut seal_Ciphertext_ct_coeff_type {
        seal_Ciphertext_data(self)
    }
    #[inline]
    pub unsafe fn data1(&self) -> *const seal_Ciphertext_ct_coeff_type {
        seal_Ciphertext_data1(self)
    }
    #[inline]
    pub unsafe fn data2(
        &mut self,
        poly_index: seal_Ciphertext_size_type,
    ) -> *mut seal_Ciphertext_ct_coeff_type {
        seal_Ciphertext_data2(self, poly_index)
    }
    #[inline]
    pub unsafe fn data3(
        &self,
        poly_index: seal_Ciphertext_size_type,
    ) -> *const seal_Ciphertext_ct_coeff_type {
        seal_Ciphertext_data3(self, poly_index)
    }
    #[inline]
    pub unsafe fn coeff_mod_count(&self) -> seal_Ciphertext_size_type {
        seal_Ciphertext_coeff_mod_count(self)
    }
    #[inline]
    pub unsafe fn poly_modulus_degree(&self) -> seal_Ciphertext_size_type {
        seal_Ciphertext_poly_modulus_degree(self)
    }
    #[inline]
    pub unsafe fn size_capacity(&self) -> seal_Ciphertext_size_type {
        seal_Ciphertext_size_capacity(self)
    }
    #[inline]
    pub unsafe fn size(&self) -> seal_Ciphertext_size_type {
        seal_Ciphertext_size(self)
    }
    #[inline]
    pub unsafe fn uint64_count_capacity(&self) -> seal_Ciphertext_size_type {
        seal_Ciphertext_uint64_count_capacity(self)
    }
    #[inline]
    pub unsafe fn uint64_count(&self) -> seal_Ciphertext_size_type {
        seal_Ciphertext_uint64_count(self)
    }
    #[inline]
    pub unsafe fn is_valid_for(&self, context: [u64; 2usize]) -> bool {
        seal_Ciphertext_is_valid_for(self, context)
    }
    #[inline]
    pub unsafe fn save(&self, stream: *mut std_ostream) {
        seal_Ciphertext_save(self, stream)
    }
    #[inline]
    pub unsafe fn unsafe_load(&mut self, stream: *mut std_istream) {
        seal_Ciphertext_unsafe_load(self, stream)
    }
    #[inline]
    pub unsafe fn load(&mut self, context: [u64; 2usize], stream: *mut std_istream) {
        seal_Ciphertext_load(self, context, stream)
    }
    #[inline]
    pub unsafe fn is_ntt_form(&self) -> bool {
        seal_Ciphertext_is_ntt_form(self)
    }
    #[inline]
    pub unsafe fn is_ntt_form1(&mut self) -> *mut bool {
        seal_Ciphertext_is_ntt_form1(self)
    }
    #[inline]
    pub unsafe fn parms_id(&mut self) -> *mut [u64; 4usize] {
        seal_Ciphertext_parms_id(self)
    }
    #[inline]
    pub unsafe fn parms_id1(&self) -> *mut [u64; 4usize] {
        seal_Ciphertext_parms_id1(self)
    }
    #[inline]
    pub unsafe fn scale(&mut self) -> *mut f64 {
        seal_Ciphertext_scale(self)
    }
    #[inline]
    pub unsafe fn scale1(&self) -> *const f64 {
        seal_Ciphertext_scale1(self)
    }
    #[inline]
    pub unsafe fn pool(&self) -> seal_MemoryPoolHandle {
        seal_Ciphertext_pool(self)
    }
    #[inline]
    pub unsafe fn new(pool: seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Ciphertext_Ciphertext(&mut __bindgen_tmp, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(context: [u64; 2usize], pool: seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Ciphertext_Ciphertext1(&mut __bindgen_tmp, context, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(
        context: [u64; 2usize],
        parms_id: seal_parms_id_type,
        pool: seal_MemoryPoolHandle,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Ciphertext_Ciphertext2(&mut __bindgen_tmp, context, parms_id, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(
        context: [u64; 2usize],
        parms_id: seal_parms_id_type,
        size_capacity: seal_Ciphertext_size_type,
        pool: seal_MemoryPoolHandle,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Ciphertext_Ciphertext3(&mut __bindgen_tmp, context, parms_id, size_capacity, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(copy: *const seal_Ciphertext) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Ciphertext_Ciphertext4(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new5(source: *mut seal_Ciphertext) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Ciphertext_Ciphertext5(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
///Class to store a plaintext element. The data for the plaintext is a polynomial
///with coefficients modulo the plaintext modulus. The degree of the plaintext
///polynomial must be one less than the degree of the polynomial modulus. The
///backing array always allocates one 64-bit word per each coefficient of the
///polynomial.
///
///@par Memory Management
///The coefficient count of a plaintext refers to the number of word-size
///coefficients in the plaintext, whereas its capacity refers to the number of
///word-size coefficients that fit in the current memory allocation. In high-
///performance applications unnecessary re-allocations should be avoided by
///reserving enough memory for the plaintext to begin with either by providing
///the desired capacity to the constructor as an extra argument, or by calling
///the reserve function at any time.
///
///When the scheme is scheme_type::BFV each coefficient of a plaintext is a 64-bit
///word, but when the scheme is scheme_type::CKKS the plaintext is by default
///stored in an NTT transformed form with respect to each of the primes in the
///coefficient modulus. Thus, the size of the allocation that is needed is the
///size of the coefficient modulus (number of primes) times the degree of the
///polynomial modulus. In addition, a valid CKKS plaintext also store the parms_id
///for the corresponding encryption parameters.
///
///@par Thread Safety
///In general, reading from plaintext is thread-safe as long as no other thread
///is concurrently mutating it. This is due to the underlying data structure
///storing the plaintext not being thread-safe.
///
///@see Ciphertext for the class that stores ciphertexts.
#[repr(C)]
#[derive(Debug)]
pub struct seal_Plaintext {
    pub parms_id_: seal_parms_id_type,
    pub scale_: f64,
    pub data_: seal_IntArray,
}
pub type seal_Plaintext_pt_coeff_type = u64;
pub type seal_Plaintext_size_type = size_type;
#[test]
fn bindgen_test_layout_seal_Plaintext() {
    assert_eq!(
        ::std::mem::size_of::<seal_Plaintext>(),
        104usize,
        concat!("Size of: ", stringify!(seal_Plaintext))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_Plaintext>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_Plaintext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Plaintext>())).parms_id_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Plaintext),
            "::",
            stringify!(parms_id_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Plaintext>())).scale_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Plaintext),
            "::",
            stringify!(scale_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Plaintext>())).data_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Plaintext),
            "::",
            stringify!(data_)
        )
    );
}
extern "C" {
    ///Allocates enough memory to accommodate the backing array of a plaintext
    ///with given capacity.
    ///
    ///@param[in] capacity The capacity
    ///@throws std::invalid_argument if capacity is negative
    ///@throws std::logic_error if the plaintext is NTT transformed
    #[link_name = "\u{1}_ZN4seal9Plaintext7reserveEm"]
    pub fn seal_Plaintext_reserve(this: *mut seal_Plaintext, capacity: seal_Plaintext_size_type);
}
extern "C" {
    ///Allocates enough memory to accommodate the backing array of the current
    ///plaintext and copies it over to the new location. This function is meant
    ///to reduce the memory use of the plaintext to smallest possible and can be
    ///particularly important after modulus switching.
    #[link_name = "\u{1}_ZN4seal9Plaintext13shrink_to_fitEv"]
    pub fn seal_Plaintext_shrink_to_fit(this: *mut seal_Plaintext);
}
extern "C" {
    ///Resets the plaintext. This function releases any memory allocated by the
    ///plaintext, returning it to the memory pool.
    #[link_name = "\u{1}_ZN4seal9Plaintext7releaseEv"]
    pub fn seal_Plaintext_release(this: *mut seal_Plaintext);
}
extern "C" {
    ///Resizes the plaintext to have a given coefficient count. The plaintext
    ///is automatically reallocated if the new coefficient count does not fit in
    ///the current capacity.
    ///
    ///@param[in] coeff_count The number of coefficients in the plaintext polynomial
    ///@throws std::invalid_argument if coeff_count is negative
    ///@throws std::logic_error if the plaintext is NTT transformed
    #[link_name = "\u{1}_ZN4seal9Plaintext6resizeEm"]
    pub fn seal_Plaintext_resize(this: *mut seal_Plaintext, coeff_count: seal_Plaintext_size_type);
}
extern "C" {
    ///Sets a given range of coefficients of a plaintext polynomial to zero; does
    ///nothing if length is zero.
    ///
    ///@param[in] start_coeff The index of the first coefficient to set to zero
    ///@param[in] length The number of coefficients to set to zero
    ///@throws std::out_of_range if start_coeff + length - 1 is not within [0, coeff_count)
    #[link_name = "\u{1}_ZN4seal9Plaintext8set_zeroEmm"]
    pub fn seal_Plaintext_set_zero(
        this: *mut seal_Plaintext,
        start_coeff: seal_Plaintext_size_type,
        length: seal_Plaintext_size_type,
    );
}
extern "C" {
    ///Sets the plaintext polynomial coefficients to zero starting at a given index.
    ///
    ///@param[in] start_coeff The index of the first coefficient to set to zero
    ///@throws std::out_of_range if start_coeff is not within [0, coeff_count)
    #[link_name = "\u{1}_ZN4seal9Plaintext8set_zeroEm"]
    pub fn seal_Plaintext_set_zero1(
        this: *mut seal_Plaintext,
        start_coeff: seal_Plaintext_size_type,
    );
}
extern "C" {
    ///Sets the plaintext polynomial to zero.
    #[link_name = "\u{1}_ZN4seal9Plaintext8set_zeroEv"]
    pub fn seal_Plaintext_set_zero2(this: *mut seal_Plaintext);
}
extern "C" {
    ///Returns a pointer to the beginning of the plaintext polynomial.
    #[link_name = "\u{1}_ZN4seal9Plaintext4dataEv"]
    pub fn seal_Plaintext_data(this: *mut seal_Plaintext) -> *mut seal_Plaintext_pt_coeff_type;
}
extern "C" {
    ///Returns a const pointer to the beginning of the plaintext polynomial.
    #[link_name = "\u{1}_ZNK4seal9Plaintext4dataEv"]
    pub fn seal_Plaintext_data1(this: *const seal_Plaintext)
        -> *const seal_Plaintext_pt_coeff_type;
}
extern "C" {
    ///Returns a pointer to a given coefficient of the plaintext polynomial.
    ///
    ///@param[in] coeff_index The index of the coefficient in the plaintext polynomial
    ///@throws std::out_of_range if coeff_index is not within [0, coeff_count)
    #[link_name = "\u{1}_ZN4seal9Plaintext4dataEm"]
    pub fn seal_Plaintext_data2(
        this: *mut seal_Plaintext,
        coeff_index: seal_Plaintext_size_type,
    ) -> *mut seal_Plaintext_pt_coeff_type;
}
extern "C" {
    ///Returns a const pointer to a given coefficient of the plaintext polynomial.
    ///
    ///@param[in] coeff_index The index of the coefficient in the plaintext polynomial
    #[link_name = "\u{1}_ZNK4seal9Plaintext4dataEm"]
    pub fn seal_Plaintext_data3(
        this: *const seal_Plaintext,
        coeff_index: seal_Plaintext_size_type,
    ) -> *const seal_Plaintext_pt_coeff_type;
}
extern "C" {
    ///Returns whether the current plaintext polynomial has all zero coefficients.
    #[link_name = "\u{1}_ZNK4seal9Plaintext7is_zeroEv"]
    pub fn seal_Plaintext_is_zero(this: *const seal_Plaintext) -> bool;
}
extern "C" {
    ///Returns the capacity of the current allocation.
    #[link_name = "\u{1}_ZNK4seal9Plaintext8capacityEv"]
    pub fn seal_Plaintext_capacity(this: *const seal_Plaintext) -> seal_Plaintext_size_type;
}
extern "C" {
    ///Returns the coefficient count of the current plaintext polynomial.
    #[link_name = "\u{1}_ZNK4seal9Plaintext11coeff_countEv"]
    pub fn seal_Plaintext_coeff_count(this: *const seal_Plaintext) -> seal_Plaintext_size_type;
}
extern "C" {
    ///Returns the significant coefficient count of the current plaintext polynomial.
    #[link_name = "\u{1}_ZNK4seal9Plaintext23significant_coeff_countEv"]
    pub fn seal_Plaintext_significant_coeff_count(
        this: *const seal_Plaintext,
    ) -> seal_Plaintext_size_type;
}
extern "C" {
    ///Returns a human-readable string description of the plaintext polynomial.
    ///
    ///The returned string is of the form "7FFx^3 + 1x^1 + 3" with a format
    ///summarized by the following:
    ///1. Terms are listed in order of strictly decreasing exponent
    ///2. Coefficient values are non-negative and in hexadecimal format (hexadecimal
    ///letters are in upper-case)
    ///3. Exponents are positive and in decimal format
    ///4. Zero coefficient terms (including the constant term) are omitted unless
    ///the polynomial is exactly 0 (see rule 9)
    ///5. Term with the exponent value of one is written as x^1
    ///6. Term with the exponent value of zero (the constant term) is written as
    ///just a hexadecimal number without x or exponent
    ///7. Terms are separated exactly by <space>+<space>
    ///8. Other than the +, no other terms have whitespace
    ///9. If the polynomial is exactly 0, the string "0" is returned
    ///
    ///@throws std::invalid_argument if the plaintext is in NTT transformed form
    #[link_name = "\u{1}_ZNK4seal9Plaintext9to_stringB5cxx11Ev"]
    pub fn seal_Plaintext_to_string(this: *const seal_Plaintext) -> std_string;
}
extern "C" {
    ///Check whether the current Plaintext is valid for a given SEALContext. If
    ///the given SEALContext is not set, the encryption parameters are invalid,
    ///or the Plaintext data does not match the SEALContext, this function returns
    ///false. Otherwise, returns true.
    ///
    ///@param[in] context The SEALContext
    #[link_name = "\u{1}_ZNK4seal9Plaintext12is_valid_forESt10shared_ptrINS_11SEALContextEE"]
    pub fn seal_Plaintext_is_valid_for(this: *const seal_Plaintext, context: [u64; 2usize])
        -> bool;
}
extern "C" {
    ///Saves the plaintext to an output stream. The output is in binary format
    ///and not human-readable. The output stream must have the "binary" flag set.
    ///
    ///@param[in] stream The stream to save the plaintext to
    ///@throws std::exception if the plaintext could not be written to stream
    #[link_name = "\u{1}_ZNK4seal9Plaintext4saveERSo"]
    pub fn seal_Plaintext_save(this: *const seal_Plaintext, stream: *mut std_ostream);
}
extern "C" {
    ///Loads a plaintext from an input stream overwriting the current plaintext.
    ///No checking of the validity of the plaintext data against encryption
    ///parameters is performed. This function should not be used unless the
    ///plaintext comes from a fully trusted source.
    ///
    ///@param[in] stream The stream to load the plaintext from
    ///@throws std::exception if a valid plaintext could not be read from stream
    #[link_name = "\u{1}_ZN4seal9Plaintext11unsafe_loadERSi"]
    pub fn seal_Plaintext_unsafe_load(this: *mut seal_Plaintext, stream: *mut std_istream);
}
extern "C" {
    ///Loads a plaintext from an input stream overwriting the current plaintext.
    ///The loaded plaintext is verified to be valid for the given SEALContext.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] stream The stream to load the plaintext from
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::exception if a valid plaintext could not be read from stream
    ///@throws std::invalid_argument if the loaded plaintext is invalid for the
    ///context
    #[link_name = "\u{1}_ZN4seal9Plaintext4loadESt10shared_ptrINS_11SEALContextEERSi"]
    pub fn seal_Plaintext_load(
        this: *mut seal_Plaintext,
        context: [u64; 2usize],
        stream: *mut std_istream,
    );
}
extern "C" {
    ///Returns whether the plaintext is in NTT form.
    #[link_name = "\u{1}_ZNK4seal9Plaintext11is_ntt_formEv"]
    pub fn seal_Plaintext_is_ntt_form(this: *const seal_Plaintext) -> bool;
}
extern "C" {
    ///Returns a reference to parms_id. The parms_id must remain zero unless the
    ///plaintext polynomial is in NTT form.
    ///
    ///@see EncryptionParameters for more information about parms_id.
    #[link_name = "\u{1}_ZN4seal9Plaintext8parms_idEv"]
    pub fn seal_Plaintext_parms_id(this: *mut seal_Plaintext) -> *mut [u64; 4usize];
}
extern "C" {
    ///Returns a const reference to parms_id. The parms_id must remain zero unless
    ///the plaintext polynomial is in NTT form.
    ///
    ///@see EncryptionParameters for more information about parms_id.
    #[link_name = "\u{1}_ZNK4seal9Plaintext8parms_idEv"]
    pub fn seal_Plaintext_parms_id1(this: *const seal_Plaintext) -> *mut [u64; 4usize];
}
extern "C" {
    ///Returns a reference to the scale. This is only needed when using the CKKS
    ///encryption scheme. The user should have little or no reason to ever change
    ///the scale by hand.
    #[link_name = "\u{1}_ZN4seal9Plaintext5scaleEv"]
    pub fn seal_Plaintext_scale(this: *mut seal_Plaintext) -> *mut f64;
}
extern "C" {
    ///Returns a constant reference to the scale. This is only needed when using
    ///the CKKS encryption scheme.
    #[link_name = "\u{1}_ZNK4seal9Plaintext5scaleEv"]
    pub fn seal_Plaintext_scale1(this: *const seal_Plaintext) -> *const f64;
}
extern "C" {
    ///Returns the currently used MemoryPoolHandle.
    #[link_name = "\u{1}_ZNK4seal9Plaintext4poolEv"]
    pub fn seal_Plaintext_pool(this: *const seal_Plaintext) -> seal_MemoryPoolHandle;
}
extern "C" {
    ///Constructs an empty plaintext allocating no memory.
    ///
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9PlaintextC1ENS_16MemoryPoolHandleE"]
    pub fn seal_Plaintext_Plaintext(this: *mut seal_Plaintext, pool: seal_MemoryPoolHandle);
}
extern "C" {
    ///Constructs a plaintext representing a constant polynomial 0. The coefficient
    ///count of the polynomial is set to the given value. The capacity is set to
    ///the same value.
    ///
    ///@param[in] coeff_count The number of (zeroed) coefficients in the plaintext
    ///polynomial
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if coeff_count is negative
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9PlaintextC1EmNS_16MemoryPoolHandleE"]
    pub fn seal_Plaintext_Plaintext1(
        this: *mut seal_Plaintext,
        coeff_count: seal_Plaintext_size_type,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Constructs a plaintext representing a constant polynomial 0. The coefficient
    ///count of the polynomial and the capacity are set to the given values.
    ///
    ///@param[in] capacity The capacity
    ///@param[in] coeff_count The number of (zeroed) coefficients in the plaintext
    ///polynomial
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if capacity is less than coeff_count
    ///@throws std::invalid_argument if coeff_count is negative
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9PlaintextC1EmmNS_16MemoryPoolHandleE"]
    pub fn seal_Plaintext_Plaintext2(
        this: *mut seal_Plaintext,
        capacity: seal_Plaintext_size_type,
        coeff_count: seal_Plaintext_size_type,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Constructs a plaintext from a given hexadecimal string describing the
    ///plaintext polynomial.
    ///
    ///The string description of the polynomial must adhere to the format returned
    ///by to_string(),
    ///which is of the form "7FFx^3 + 1x^1 + 3" and summarized by the following
    ///rules:
    ///1. Terms are listed in order of strictly decreasing exponent
    ///2. Coefficient values are non-negative and in hexadecimal format (upper
    ///and lower case letters are both supported)
    ///3. Exponents are positive and in decimal format
    ///4. Zero coefficient terms (including the constant term) may be (but do
    ///not have to be) omitted
    ///5. Term with the exponent value of one must be exactly written as x^1
    ///6. Term with the exponent value of zero (the constant term) must be written
    ///as just a hexadecimal number without exponent
    ///7. Terms must be separated by exactly <space>+<space> and minus is not
    ///allowed
    ///8. Other than the +, no other terms should have whitespace
    ///
    ///@param[in] hex_poly The formatted polynomial string specifying the plaintext
    ///polynomial
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if hex_poly does not adhere to the expected
    ///format
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9PlaintextC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS_16MemoryPoolHandleE"]
    pub fn seal_Plaintext_Plaintext3(
        this: *mut seal_Plaintext,
        hex_poly: *const std_string,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Constructs a new plaintext by copying a given one.
    ///
    ///@param[in] copy The plaintext to copy from
    #[link_name = "\u{1}_ZN4seal9PlaintextC1ERKS0_"]
    pub fn seal_Plaintext_Plaintext4(this: *mut seal_Plaintext, copy: *const seal_Plaintext);
}
extern "C" {
    ///Constructs a new plaintext by moving a given one.
    ///
    ///@param[in] source The plaintext to move from
    #[link_name = "\u{1}_ZN4seal9PlaintextC1EOS0_"]
    pub fn seal_Plaintext_Plaintext5(this: *mut seal_Plaintext, source: *mut seal_Plaintext);
}
impl Default for seal_Plaintext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_Plaintext {
    #[inline]
    pub unsafe fn reserve(&mut self, capacity: seal_Plaintext_size_type) {
        seal_Plaintext_reserve(self, capacity)
    }
    #[inline]
    pub unsafe fn shrink_to_fit(&mut self) {
        seal_Plaintext_shrink_to_fit(self)
    }
    #[inline]
    pub unsafe fn release(&mut self) {
        seal_Plaintext_release(self)
    }
    #[inline]
    pub unsafe fn resize(&mut self, coeff_count: seal_Plaintext_size_type) {
        seal_Plaintext_resize(self, coeff_count)
    }
    #[inline]
    pub unsafe fn set_zero(
        &mut self,
        start_coeff: seal_Plaintext_size_type,
        length: seal_Plaintext_size_type,
    ) {
        seal_Plaintext_set_zero(self, start_coeff, length)
    }
    #[inline]
    pub unsafe fn set_zero1(&mut self, start_coeff: seal_Plaintext_size_type) {
        seal_Plaintext_set_zero1(self, start_coeff)
    }
    #[inline]
    pub unsafe fn set_zero2(&mut self) {
        seal_Plaintext_set_zero2(self)
    }
    #[inline]
    pub unsafe fn data(&mut self) -> *mut seal_Plaintext_pt_coeff_type {
        seal_Plaintext_data(self)
    }
    #[inline]
    pub unsafe fn data1(&self) -> *const seal_Plaintext_pt_coeff_type {
        seal_Plaintext_data1(self)
    }
    #[inline]
    pub unsafe fn data2(
        &mut self,
        coeff_index: seal_Plaintext_size_type,
    ) -> *mut seal_Plaintext_pt_coeff_type {
        seal_Plaintext_data2(self, coeff_index)
    }
    #[inline]
    pub unsafe fn data3(
        &self,
        coeff_index: seal_Plaintext_size_type,
    ) -> *const seal_Plaintext_pt_coeff_type {
        seal_Plaintext_data3(self, coeff_index)
    }
    #[inline]
    pub unsafe fn is_zero(&self) -> bool {
        seal_Plaintext_is_zero(self)
    }
    #[inline]
    pub unsafe fn capacity(&self) -> seal_Plaintext_size_type {
        seal_Plaintext_capacity(self)
    }
    #[inline]
    pub unsafe fn coeff_count(&self) -> seal_Plaintext_size_type {
        seal_Plaintext_coeff_count(self)
    }
    #[inline]
    pub unsafe fn significant_coeff_count(&self) -> seal_Plaintext_size_type {
        seal_Plaintext_significant_coeff_count(self)
    }
    #[inline]
    pub unsafe fn to_string(&self) -> std_string {
        seal_Plaintext_to_string(self)
    }
    #[inline]
    pub unsafe fn is_valid_for(&self, context: [u64; 2usize]) -> bool {
        seal_Plaintext_is_valid_for(self, context)
    }
    #[inline]
    pub unsafe fn save(&self, stream: *mut std_ostream) {
        seal_Plaintext_save(self, stream)
    }
    #[inline]
    pub unsafe fn unsafe_load(&mut self, stream: *mut std_istream) {
        seal_Plaintext_unsafe_load(self, stream)
    }
    #[inline]
    pub unsafe fn load(&mut self, context: [u64; 2usize], stream: *mut std_istream) {
        seal_Plaintext_load(self, context, stream)
    }
    #[inline]
    pub unsafe fn is_ntt_form(&self) -> bool {
        seal_Plaintext_is_ntt_form(self)
    }
    #[inline]
    pub unsafe fn parms_id(&mut self) -> *mut [u64; 4usize] {
        seal_Plaintext_parms_id(self)
    }
    #[inline]
    pub unsafe fn parms_id1(&self) -> *mut [u64; 4usize] {
        seal_Plaintext_parms_id1(self)
    }
    #[inline]
    pub unsafe fn scale(&mut self) -> *mut f64 {
        seal_Plaintext_scale(self)
    }
    #[inline]
    pub unsafe fn scale1(&self) -> *const f64 {
        seal_Plaintext_scale1(self)
    }
    #[inline]
    pub unsafe fn pool(&self) -> seal_MemoryPoolHandle {
        seal_Plaintext_pool(self)
    }
    #[inline]
    pub unsafe fn new(pool: seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Plaintext_Plaintext(&mut __bindgen_tmp, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(coeff_count: seal_Plaintext_size_type, pool: seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Plaintext_Plaintext1(&mut __bindgen_tmp, coeff_count, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(
        capacity: seal_Plaintext_size_type,
        coeff_count: seal_Plaintext_size_type,
        pool: seal_MemoryPoolHandle,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Plaintext_Plaintext2(&mut __bindgen_tmp, capacity, coeff_count, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(hex_poly: *const std_string, pool: seal_MemoryPoolHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Plaintext_Plaintext3(&mut __bindgen_tmp, hex_poly, pool);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(copy: *const seal_Plaintext) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Plaintext_Plaintext4(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new5(source: *mut seal_Plaintext) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Plaintext_Plaintext5(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12from_complexIdvEET_St7complexIdE"]
    pub fn seal_from_complex(in_: [u64; 2usize]) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal12from_complexISt7complexIdEvEET_S2_"]
    pub fn seal_from_complex1(in_: [u64; 2usize]) -> [u64; 2usize];
}
///Provides functionality for encoding vectors of complex or real numbers into plaintext
///polynomials to be encrypted and computed on using the CKKS scheme. If the polynomial
///modulus degree is N, then CKKSEncoder converts vectors of N/2 complex numbers into
///plaintext elements. Homomorphic operations performed on such encrypted vectors are
///applied coefficient (slot-)wise, enabling powerful SIMD functionality for computations
///that are vectorizable. This functionality is often called "batching" in the homomorphic
///encryption literature.
///
///@par Mathematical Background
///Mathematically speaking, if the polynomial modulus is X^N+1, N is a power of two, the
///CKKSEncoder implements an approximation of the canonical embedding of the ring of
///integers Z[X]/(X^N+1) into C^(N/2), where C denotes the complex numbers. The Galois
///group of the extension is (Z/2NZ)* ~= Z/2Z x Z/(N/2) whose action on the primitive roots
///of unity modulo coeff_modulus is easy to describe. Since the batching slots correspond
///1-to-1 to the primitive roots of unity, applying Galois automorphisms on the plaintext
///acts by permuting the slots. By applying generators of the two cyclic subgroups of the
///Galois group, we can effectively enable cyclic rotations and complex conjugations of
///the encrypted complex vectors.
#[repr(C)]
#[derive(Debug)]
pub struct seal_CKKSEncoder {
    pub pool_: seal_MemoryPoolHandle,
    pub context_: [u64; 2usize],
    pub slots_: usize,
    pub roots_: [u64; 4usize],
    pub inv_roots_: [u64; 4usize],
    pub matrix_reps_index_map_: seal_util_Pointer<u64>,
}
pub const seal_CKKSEncoder_PI_: f64 = 3.141592653589793;
extern "C" {
    #[link_name = "\u{1}_ZN4seal11CKKSEncoder11two_pow_64_E"]
    pub static mut seal_CKKSEncoder_two_pow_64_: f64;
}
#[test]
fn bindgen_test_layout_seal_CKKSEncoder() {
    assert_eq!(
        ::std::mem::size_of::<seal_CKKSEncoder>(),
        136usize,
        concat!("Size of: ", stringify!(seal_CKKSEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_CKKSEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_CKKSEncoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_CKKSEncoder>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_CKKSEncoder),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_CKKSEncoder>())).context_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_CKKSEncoder),
            "::",
            stringify!(context_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_CKKSEncoder>())).slots_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_CKKSEncoder),
            "::",
            stringify!(slots_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_CKKSEncoder>())).roots_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_CKKSEncoder),
            "::",
            stringify!(roots_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_CKKSEncoder>())).inv_roots_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_CKKSEncoder),
            "::",
            stringify!(inv_roots_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_CKKSEncoder>())).matrix_reps_index_map_ as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_CKKSEncoder),
            "::",
            stringify!(matrix_reps_index_map_)
        )
    );
}
extern "C" {
    ///Encodes a double-precision floating-point number into a plaintext polynomial.
    ///Dynamic memory allocations in the process are allocated from the memory pool
    ///pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] value The double-precision floating-point number to encode
    ///@param[in] parms_id parms_id determining the encryption parameters to be used
    ///by the result plaintext
    ///@param[in] scale Scaling parameter defining encoding precision
    ///@param[out] destination The plaintext polynomial to overwrite with the result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if parms_id is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if scale is not strictly positive
    ///@throws std::invalid_argument if encoding is too large for the encryption
    ///parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal11CKKSEncoder6encodeEdSt5arrayImLm4EEdRNS_9PlaintextENS_16MemoryPoolHandleE"]
    pub fn seal_CKKSEncoder_encode(
        this: *mut seal_CKKSEncoder,
        value: f64,
        parms_id: seal_parms_id_type,
        scale: f64,
        destination: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Encodes a double-precision floating-point number into a plaintext polynomial.
    ///The encryption parameters used are the top level parameters for the given context.
    ///Dynamic memory allocations in the process are allocated from the memory pool
    ///pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] value The double-precision floating-point number to encode
    ///@param[in] scale Scaling parameter defining encoding precision
    ///@param[out] destination The plaintext polynomial to overwrite with the result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if scale is not strictly positive
    ///@throws std::invalid_argument if encoding is too large for the encryption
    ///parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal11CKKSEncoder6encodeEddRNS_9PlaintextENS_16MemoryPoolHandleE"]
    pub fn seal_CKKSEncoder_encode1(
        this: *mut seal_CKKSEncoder,
        value: f64,
        scale: f64,
        destination: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Encodes a double-precision complex number into a plaintext polynomial. Dynamic
    ///memory allocations in the process are allocated from the memory pool pointed to
    ///by the given MemoryPoolHandle.
    ///
    ///@param[in] value The double-precision complex number to encode
    ///@param[in] parms_id parms_id determining the encryption parameters to be used
    ///by the result plaintext
    ///@param[in] scale Scaling parameter defining encoding precision
    ///@param[out] destination The plaintext polynomial to overwrite with the result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if parms_id is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if scale is not strictly positive
    ///@throws std::invalid_argument if encoding is too large for the encryption
    ///parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal11CKKSEncoder6encodeESt7complexIdESt5arrayImLm4EEdRNS_9PlaintextENS_16MemoryPoolHandleE"]
    pub fn seal_CKKSEncoder_encode2(
        this: *mut seal_CKKSEncoder,
        value: [u64; 2usize],
        parms_id: seal_parms_id_type,
        scale: f64,
        destination: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Encodes a double-precision complex number into a plaintext polynomial. The
    ///encryption parameters used are the top level parameters for the given context.
    ///Dynamic memory allocations in the process are allocated from the memory pool
    ///pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] value The double-precision complex number to encode
    ///@param[in] scale Scaling parameter defining encoding precision
    ///@param[out] destination The plaintext polynomial to overwrite with the result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if scale is not strictly positive
    ///@throws std::invalid_argument if encoding is too large for the encryption
    ///parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal11CKKSEncoder6encodeESt7complexIdEdRNS_9PlaintextENS_16MemoryPoolHandleE"]
    pub fn seal_CKKSEncoder_encode3(
        this: *mut seal_CKKSEncoder,
        value: [u64; 2usize],
        scale: f64,
        destination: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Encodes an integer number into a plaintext polynomial without any scaling.
    ///
    ///@param[in] value The integer number to encode
    ///@param[in] parms_id parms_id determining the encryption parameters to be used
    ///by the result plaintext
    ///@param[out] destination The plaintext polynomial to overwrite with the result
    ///@throws std::invalid_argument if parms_id is not valid for the encryption
    ///parameters
    #[link_name = "\u{1}_ZN4seal11CKKSEncoder6encodeElSt5arrayImLm4EERNS_9PlaintextE"]
    pub fn seal_CKKSEncoder_encode4(
        this: *mut seal_CKKSEncoder,
        value: i64,
        parms_id: seal_parms_id_type,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Encodes an integer number into a plaintext polynomial without any scaling. The
    ///encryption parameters used are the top level parameters for the given context.
    ///
    ///@param[in] value The integer number to encode
    ///@param[out] destination The plaintext polynomial to overwrite with the result
    #[link_name = "\u{1}_ZN4seal11CKKSEncoder6encodeElRNS_9PlaintextE"]
    pub fn seal_CKKSEncoder_encode5(
        this: *mut seal_CKKSEncoder,
        value: i64,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Returns the number of complex numbers encoded.
    #[link_name = "\u{1}_ZNK4seal11CKKSEncoder10slot_countEv"]
    pub fn seal_CKKSEncoder_slot_count(this: *const seal_CKKSEncoder) -> usize;
}
extern "C" {
    ///Creates a CKKSEncoder instance initialized with the specified SEALContext.
    ///
    ///@param[in] context The SEALContext
    ///@throws std::invalid_argument if the context is not set or encryption parameters
    ///are not valid
    ///@throws std::invalid_argument if scheme is not scheme_type::CKKS
    #[link_name = "\u{1}_ZN4seal11CKKSEncoderC1ESt10shared_ptrINS_11SEALContextEE"]
    pub fn seal_CKKSEncoder_CKKSEncoder(this: *mut seal_CKKSEncoder, context: [u64; 2usize]);
}
impl Default for seal_CKKSEncoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_CKKSEncoder {
    #[inline]
    pub unsafe fn encode(
        &mut self,
        value: f64,
        parms_id: seal_parms_id_type,
        scale: f64,
        destination: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_CKKSEncoder_encode(self, value, parms_id, scale, destination, pool)
    }
    #[inline]
    pub unsafe fn encode1(
        &mut self,
        value: f64,
        scale: f64,
        destination: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_CKKSEncoder_encode1(self, value, scale, destination, pool)
    }
    #[inline]
    pub unsafe fn encode2(
        &mut self,
        value: [u64; 2usize],
        parms_id: seal_parms_id_type,
        scale: f64,
        destination: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_CKKSEncoder_encode2(self, value, parms_id, scale, destination, pool)
    }
    #[inline]
    pub unsafe fn encode3(
        &mut self,
        value: [u64; 2usize],
        scale: f64,
        destination: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_CKKSEncoder_encode3(self, value, scale, destination, pool)
    }
    #[inline]
    pub unsafe fn encode4(
        &mut self,
        value: i64,
        parms_id: seal_parms_id_type,
        destination: *mut seal_Plaintext,
    ) {
        seal_CKKSEncoder_encode4(self, value, parms_id, destination)
    }
    #[inline]
    pub unsafe fn encode5(&mut self, value: i64, destination: *mut seal_Plaintext) {
        seal_CKKSEncoder_encode5(self, value, destination)
    }
    #[inline]
    pub unsafe fn slot_count(&self) -> usize {
        seal_CKKSEncoder_slot_count(self)
    }
    #[inline]
    pub unsafe fn new(context: [u64; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_CKKSEncoder_CKKSEncoder(&mut __bindgen_tmp, context);
        __bindgen_tmp
    }
}
///Class to store a secret key.
///
///@par Thread Safety
///In general, reading from SecretKey is thread-safe as long as no other thread
///is concurrently mutating it. This is due to the underlying data structure
///storing the secret key not being thread-safe.
///
///
///@see KeyGenerator for the class that generates the secret key.
///@see PublicKey for the class that stores the public key.
///@see RelinKeys for the class that stores the relinearization keys.
///@see GaloisKeys for the class that stores the Galois keys.
#[repr(C)]
#[derive(Debug)]
pub struct seal_SecretKey {
    ///We use a fresh memory pool with `clear_on_destruction' enabled
    pub sk_: seal_Plaintext,
}
#[test]
fn bindgen_test_layout_seal_SecretKey() {
    assert_eq!(
        ::std::mem::size_of::<seal_SecretKey>(),
        104usize,
        concat!("Size of: ", stringify!(seal_SecretKey))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_SecretKey>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_SecretKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_SecretKey>())).sk_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_SecretKey),
            "::",
            stringify!(sk_)
        )
    );
}
extern "C" {
    ///Returns a reference to the underlying polynomial.
    #[link_name = "\u{1}_ZN4seal9SecretKey4dataEv"]
    pub fn seal_SecretKey_data(this: *mut seal_SecretKey) -> *mut seal_Plaintext;
}
extern "C" {
    ///Returns a const reference to the underlying polynomial.
    #[link_name = "\u{1}_ZNK4seal9SecretKey4dataEv"]
    pub fn seal_SecretKey_data1(this: *const seal_SecretKey) -> *mut seal_Plaintext;
}
extern "C" {
    ///Check whether the current SecretKey is valid for a given SEALContext. If
    ///the given SEALContext is not set, the encryption parameters are invalid,
    ///or the SecretKey data does not match the SEALContext, this function returns
    ///false. Otherwise, returns true.
    ///
    ///@param[in] context The SEALContext
    #[link_name = "\u{1}_ZNK4seal9SecretKey12is_valid_forESt10shared_ptrINS_11SEALContextEE"]
    pub fn seal_SecretKey_is_valid_for(this: *const seal_SecretKey, context: [u64; 2usize])
        -> bool;
}
extern "C" {
    ///Saves the SecretKey to an output stream. The output is in binary format
    ///and not human-readable. The output stream must have the "binary" flag set.
    ///
    ///@param[in] stream The stream to save the SecretKey to
    ///@throws std::exception if the plaintext could not be written to stream
    #[link_name = "\u{1}_ZNK4seal9SecretKey4saveERSo"]
    pub fn seal_SecretKey_save(this: *const seal_SecretKey, stream: *mut std_ostream);
}
extern "C" {
    ///Loads a SecretKey from an input stream overwriting the current SecretKey.
    ///No checking of the validity of the SecretKey data against encryption
    ///parameters is performed. This function should not be used unless the
    ///SecretKey comes from a fully trusted source.
    ///
    ///@param[in] stream The stream to load the SecretKey from
    ///@throws std::exception if a valid SecretKey could not be read from stream
    #[link_name = "\u{1}_ZN4seal9SecretKey11unsafe_loadERSi"]
    pub fn seal_SecretKey_unsafe_load(this: *mut seal_SecretKey, stream: *mut std_istream);
}
extern "C" {
    ///Loads a SecretKey from an input stream overwriting the current SecretKey.
    ///The loaded SecretKey is verified to be valid for the given SEALContext.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] stream The stream to load the SecretKey from
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::exception if a valid SecretKey could not be read from stream
    ///@throws std::invalid_argument if the loaded SecretKey is invalid for the
    ///context
    #[link_name = "\u{1}_ZN4seal9SecretKey4loadESt10shared_ptrINS_11SEALContextEERSi"]
    pub fn seal_SecretKey_load(
        this: *mut seal_SecretKey,
        context: [u64; 2usize],
        stream: *mut std_istream,
    );
}
extern "C" {
    ///Returns a reference to parms_id.
    ///
    ///@see EncryptionParameters for more information about parms_id.
    #[link_name = "\u{1}_ZN4seal9SecretKey8parms_idEv"]
    pub fn seal_SecretKey_parms_id(this: *mut seal_SecretKey) -> *mut [u64; 4usize];
}
extern "C" {
    ///Returns a const reference to parms_id.
    ///
    ///@see EncryptionParameters for more information about parms_id.
    #[link_name = "\u{1}_ZNK4seal9SecretKey8parms_idEv"]
    pub fn seal_SecretKey_parms_id1(this: *const seal_SecretKey) -> *mut [u64; 4usize];
}
extern "C" {
    ///Returns the currently used MemoryPoolHandle.
    #[link_name = "\u{1}_ZNK4seal9SecretKey4poolEv"]
    pub fn seal_SecretKey_pool(this: *const seal_SecretKey) -> seal_MemoryPoolHandle;
}
extern "C" {
    ///Creates an empty secret key.
    #[link_name = "\u{1}_ZN4seal9SecretKeyC1Ev"]
    pub fn seal_SecretKey_SecretKey(this: *mut seal_SecretKey);
}
extern "C" {
    ///Creates a new SecretKey by copying an old one.
    ///
    ///@param[in] copy The SecretKey to copy from
    #[link_name = "\u{1}_ZN4seal9SecretKeyC1ERKS0_"]
    pub fn seal_SecretKey_SecretKey1(this: *mut seal_SecretKey, copy: *const seal_SecretKey);
}
extern "C" {
    ///Creates a new SecretKey by moving an old one.
    ///
    ///@param[in] source The SecretKey to move from
    #[link_name = "\u{1}_ZN4seal9SecretKeyC1EOS0_"]
    pub fn seal_SecretKey_SecretKey2(this: *mut seal_SecretKey, source: *mut seal_SecretKey);
}
extern "C" {
    ///Overwrites the key data by random data and destroys the SecretKey object.
    #[link_name = "\u{1}_ZN4seal9SecretKeyD1Ev"]
    pub fn seal_SecretKey_SecretKey_destructor(this: *mut seal_SecretKey);
}
impl Default for seal_SecretKey {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_SecretKey {
    #[inline]
    pub unsafe fn data(&mut self) -> *mut seal_Plaintext {
        seal_SecretKey_data(self)
    }
    #[inline]
    pub unsafe fn data1(&self) -> *mut seal_Plaintext {
        seal_SecretKey_data1(self)
    }
    #[inline]
    pub unsafe fn is_valid_for(&self, context: [u64; 2usize]) -> bool {
        seal_SecretKey_is_valid_for(self, context)
    }
    #[inline]
    pub unsafe fn save(&self, stream: *mut std_ostream) {
        seal_SecretKey_save(self, stream)
    }
    #[inline]
    pub unsafe fn unsafe_load(&mut self, stream: *mut std_istream) {
        seal_SecretKey_unsafe_load(self, stream)
    }
    #[inline]
    pub unsafe fn load(&mut self, context: [u64; 2usize], stream: *mut std_istream) {
        seal_SecretKey_load(self, context, stream)
    }
    #[inline]
    pub unsafe fn parms_id(&mut self) -> *mut [u64; 4usize] {
        seal_SecretKey_parms_id(self)
    }
    #[inline]
    pub unsafe fn parms_id1(&self) -> *mut [u64; 4usize] {
        seal_SecretKey_parms_id1(self)
    }
    #[inline]
    pub unsafe fn pool(&self) -> seal_MemoryPoolHandle {
        seal_SecretKey_pool(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_SecretKey_SecretKey(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_SecretKey) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_SecretKey_SecretKey1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_SecretKey) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_SecretKey_SecretKey2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        seal_SecretKey_SecretKey_destructor(self)
    }
}
///Decrypts Ciphertext objects into Plaintext objects. Constructing a Decryptor
///requires a SEALContext with valid encryption parameters, and the secret key.
///The Decryptor is also used to compute the invariant noise budget in a given
///ciphertext.
///
///@par Overloads
///For the decrypt function we provide two overloads concerning the memory pool
///used in allocations needed during the operation. In one overload the global
///memory pool is used for this purpose, and in another overload the user can
///supply a MemoryPoolHandle to be used instead. This is to allow one single
///Decryptor to be used concurrently by several threads without running into
///thread contention in allocations taking place during operations. For example,
///one can share one single Decryptor across any number of threads, but in each
///thread call the decrypt function by giving it a thread-local MemoryPoolHandle
///to use. It is important for a developer to understand how this works to avoid
///unnecessary performance bottlenecks.
///
///
///@par NTT form
///When using the BFV scheme (scheme_type::BFV), all plaintext and ciphertexts
///should remain by default in the usual coefficient representation, i.e. not in
///NTT form. When using the CKKS scheme (scheme_type::CKKS), all plaintexts and
///ciphertexts should remain by default in NTT form. We call these scheme-specific
///NTT states the "default NTT form". Decryption requires the input ciphertexts
///to be in the default NTT form, and will throw an exception if this is not the
///case.
#[repr(C)]
#[derive(Debug)]
pub struct seal_Decryptor {
    ///We use a fresh memory pool with `clear_on_destruction' enabled
    pub pool_: seal_MemoryPoolHandle,
    pub context_: [u64; 2usize],
    pub secret_key_: seal_util_Pointer<u64>,
    pub secret_key_array_size_: usize,
    pub secret_key_array_: seal_util_Pointer<u64>,
    pub secret_key_array_locker_: seal_util_ReaderWriterLocker,
}
#[test]
fn bindgen_test_layout_seal_Decryptor() {
    assert_eq!(
        ::std::mem::size_of::<seal_Decryptor>(),
        160usize,
        concat!("Size of: ", stringify!(seal_Decryptor))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_Decryptor>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_Decryptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Decryptor>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Decryptor),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Decryptor>())).context_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Decryptor),
            "::",
            stringify!(context_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Decryptor>())).secret_key_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Decryptor),
            "::",
            stringify!(secret_key_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_Decryptor>())).secret_key_array_size_ as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Decryptor),
            "::",
            stringify!(secret_key_array_size_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_Decryptor>())).secret_key_array_ as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Decryptor),
            "::",
            stringify!(secret_key_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_Decryptor>())).secret_key_array_locker_ as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Decryptor),
            "::",
            stringify!(secret_key_array_locker_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal9Decryptor7decryptERKNS_10CiphertextERNS_9PlaintextE"]
    pub fn seal_Decryptor_decrypt(
        this: *mut seal_Decryptor,
        encrypted: *const seal_Ciphertext,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal9Decryptor22invariant_noise_budgetERKNS_10CiphertextE"]
    pub fn seal_Decryptor_invariant_noise_budget(
        this: *mut seal_Decryptor,
        encrypted: *const seal_Ciphertext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///Creates a Decryptor instance initialized with the specified SEALContext
    ///and secret key.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] secret_key The secret key
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::invalid_argument if secret_key is not valid
    #[link_name = "\u{1}_ZN4seal9DecryptorC1ESt10shared_ptrINS_11SEALContextEERKNS_9SecretKeyE"]
    pub fn seal_Decryptor_Decryptor(
        this: *mut seal_Decryptor,
        context: [u64; 2usize],
        secret_key: *const seal_SecretKey,
    );
}
impl Default for seal_Decryptor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_Decryptor {
    #[inline]
    pub unsafe fn decrypt(
        &mut self,
        encrypted: *const seal_Ciphertext,
        destination: *mut seal_Plaintext,
    ) {
        seal_Decryptor_decrypt(self, encrypted, destination)
    }
    #[inline]
    pub unsafe fn invariant_noise_budget(
        &mut self,
        encrypted: *const seal_Ciphertext,
    ) -> ::std::os::raw::c_int {
        seal_Decryptor_invariant_noise_budget(self, encrypted)
    }
    #[inline]
    pub unsafe fn new(context: [u64; 2usize], secret_key: *const seal_SecretKey) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Decryptor_Decryptor(&mut __bindgen_tmp, context, secret_key);
        __bindgen_tmp
    }
}
extern "C" {
    ///Returns the default coefficients modulus for a given polynomial modulus degree.
    ///The polynomial modulus and the coefficient modulus obtained in this way should
    ///provide approdimately 128 bits of security against the best known attacks,
    ///assuming the standard deviation of the noise distribution is left to its default
    ///value.
    ///
    ///@param[in] poly_modulus_degree The degree of the polynomial modulus
    ///@throws std::out_of_range if poly_modulus_degree is not 1024, 2048, 4096, 8192, 16384, or 32768
    #[link_name = "\u{1}_ZN4seal17coeff_modulus_128Em"]
    pub fn seal_coeff_modulus_128(poly_modulus_degree: usize) -> [u64; 3usize];
}
extern "C" {
    ///Returns the default coefficients modulus for a given polynomial modulus degree.
    ///The polynomial modulus and the coefficient modulus obtained in this way should
    ///provide approdimately 192 bits of security against the best known attacks,
    ///assuming the standard deviation of the noise distribution is left to its default
    ///value.
    ///
    ///@param[in] poly_modulus_degree The degree of the polynomial modulus
    ///@throws std::out_of_range if poly_modulus_degree is not 1024, 2048, 4096, 8192, 16384, or 32768
    #[link_name = "\u{1}_ZN4seal17coeff_modulus_192Em"]
    pub fn seal_coeff_modulus_192(poly_modulus_degree: usize) -> [u64; 3usize];
}
extern "C" {
    ///Returns the default coefficients modulus for a given polynomial modulus degree.
    ///The polynomial modulus and the coefficient modulus obtained in this way should
    ///provide approdimately 256 bits of security against the best known attacks,
    ///assuming the standard deviation of the noise distribution is left to its default
    ///value.
    ///
    ///@param[in] poly_modulus_degree The degree of the polynomial modulus
    ///@throws std::out_of_range if poly_modulus_degree is not 1024, 2048, 4096, 8192, 16384, or 32768
    #[link_name = "\u{1}_ZN4seal17coeff_modulus_256Em"]
    pub fn seal_coeff_modulus_256(poly_modulus_degree: usize) -> [u64; 3usize];
}
extern "C" {
    ///Returns a 60-bit coefficient modulus prime.
    ///
    ///@param[in] index The list index of the prime
    ///@throws std::out_of_range if index is not within [0, 64)
    #[link_name = "\u{1}_ZN4seal16small_mods_60bitEm"]
    pub fn seal_small_mods_60bit(
        index: usize,
    ) -> seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///Returns a 50-bit coefficient modulus prime.
    ///
    ///@param[in] index The list index of the prime
    ///@throws std::out_of_range if index is not within [0, 64)
    #[link_name = "\u{1}_ZN4seal16small_mods_50bitEm"]
    pub fn seal_small_mods_50bit(
        index: usize,
    ) -> seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///Returns a 40-bit coefficient modulus prime.
    ///
    ///@param[in] index The list index of the prime
    ///@throws std::out_of_range if index is not within [0, 64)
    #[link_name = "\u{1}_ZN4seal16small_mods_40bitEm"]
    pub fn seal_small_mods_40bit(
        index: usize,
    ) -> seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///Returns a 30-bit coefficient modulus prime.
    ///
    ///@param[in] index The list index of the prime
    ///@throws std::out_of_range if index is not within [0, 64)
    #[link_name = "\u{1}_ZN4seal16small_mods_30bitEm"]
    pub fn seal_small_mods_30bit(
        index: usize,
    ) -> seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///Returns the largest allowed decomposition bit count (60).
    #[link_name = "\u{1}_ZN4seal7dbc_maxEv"]
    pub fn seal_dbc_max() -> ::std::os::raw::c_int;
}
extern "C" {
    ///Returns the smallest allowed decomposition bit count (1).
    #[link_name = "\u{1}_ZN4seal7dbc_minEv"]
    pub fn seal_dbc_min() -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct seal_AbstractIntegerEncoder__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct seal_AbstractIntegerEncoder {
    pub vtable_: *const seal_AbstractIntegerEncoder__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_seal_AbstractIntegerEncoder() {
    assert_eq!(
        ::std::mem::size_of::<seal_AbstractIntegerEncoder>(),
        8usize,
        concat!("Size of: ", stringify!(seal_AbstractIntegerEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_AbstractIntegerEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_AbstractIntegerEncoder))
    );
}
impl Default for seal_AbstractIntegerEncoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal22AbstractIntegerEncoderD1Ev"]
    pub fn seal_AbstractIntegerEncoder_AbstractIntegerEncoder_destructor(
        this: *mut seal_AbstractIntegerEncoder,
    );
}
#[repr(C)]
pub struct seal_AbstractFractionalEncoder__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct seal_AbstractFractionalEncoder {
    pub vtable_: *const seal_AbstractFractionalEncoder__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_seal_AbstractFractionalEncoder() {
    assert_eq!(
        ::std::mem::size_of::<seal_AbstractFractionalEncoder>(),
        8usize,
        concat!("Size of: ", stringify!(seal_AbstractFractionalEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_AbstractFractionalEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_AbstractFractionalEncoder))
    );
}
impl Default for seal_AbstractFractionalEncoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4seal25AbstractFractionalEncoderD1Ev"]
    pub fn seal_AbstractFractionalEncoder_AbstractFractionalEncoder_destructor(
        this: *mut seal_AbstractFractionalEncoder,
    );
}
///Encodes integers into plaintext polynomials that Encryptor can encrypt. An instance of
///the BinaryEncoder class converts an integer into a plaintext polynomial by placing its
///binary digits as the coefficients of the polynomial. Decoding the integer amounts to
///evaluating the plaintext polynomial at X=2.
///
///Addition and multiplication on the integer side translate into addition and multiplication
///on the encoded plaintext polynomial side, provided that the length of the polynomial
///never grows to be of the size of the polynomial modulus (poly_modulus), and that the
///coefficients of the plaintext polynomials appearing throughout the computations never
///experience coefficients larger than the plaintext modulus (plain_modulus).
///
///@par Negative Integers
///Negative integers are represented by using -1 instead of 1 in the binary representation,
///and the negative coefficients are stored in the plaintext polynomials as unsigned integers
///that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
///would be stored as a polynomial coefficient plain_modulus-1.
///
///@see BinaryFractionalEncoder for encoding real numbers.
///@see BalancedEncoder for encoding using base-b representation for b greater than 2.
///@see IntegerEncoder for a common interface to all integer encoders.
#[repr(C)]
#[derive(Debug)]
pub struct seal_BinaryEncoder {
    pub _base: seal_AbstractIntegerEncoder,
    pub pool_: seal_MemoryPoolHandle,
    pub plain_modulus_: seal_util_global_variables_internal_mods_SmallModulus,
    pub coeff_neg_threshold_: u64,
    pub neg_one_: u64,
}
#[test]
fn bindgen_test_layout_seal_BinaryEncoder() {
    assert_eq!(
        ::std::mem::size_of::<seal_BinaryEncoder>(),
        88usize,
        concat!("Size of: ", stringify!(seal_BinaryEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_BinaryEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_BinaryEncoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_BinaryEncoder>())).pool_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BinaryEncoder),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BinaryEncoder>())).plain_modulus_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BinaryEncoder),
            "::",
            stringify!(plain_modulus_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BinaryEncoder>())).coeff_neg_threshold_ as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BinaryEncoder),
            "::",
            stringify!(coeff_neg_threshold_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_BinaryEncoder>())).neg_one_ as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BinaryEncoder),
            "::",
            stringify!(neg_one_)
        )
    );
}
extern "C" {
    ///Creates a BinaryEncoder object. The constructor takes as input a reference
    ///to the plaintext modulus (represented by SmallModulus).
    ///
    ///@param[in] plain_modulus The plaintext modulus (represented by SmallModulus)
    ///@throws std::invalid_argument if plain_modulus is not at least 2
    #[link_name = "\u{1}_ZN4seal13BinaryEncoderC1ERKNS_12SmallModulusE"]
    pub fn seal_BinaryEncoder_BinaryEncoder(
        this: *mut seal_BinaryEncoder,
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    );
}
extern "C" {
    ///Creates a copy of a BinaryEncoder.
    ///
    ///@param[in] copy The BinaryEncoder to copy from
    #[link_name = "\u{1}_ZN4seal13BinaryEncoderC1ERKS0_"]
    pub fn seal_BinaryEncoder_BinaryEncoder1(
        this: *mut seal_BinaryEncoder,
        copy: *const seal_BinaryEncoder,
    );
}
extern "C" {
    ///Creates a new BinaryEncoder by moving an old one.
    ///
    ///@param[in] source The BinaryEncoder to move from
    #[link_name = "\u{1}_ZN4seal13BinaryEncoderC1EOS0_"]
    pub fn seal_BinaryEncoder_BinaryEncoder2(
        this: *mut seal_BinaryEncoder,
        source: *mut seal_BinaryEncoder,
    );
}
impl Default for seal_BinaryEncoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_BinaryEncoder {
    #[inline]
    pub unsafe fn new(
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BinaryEncoder_BinaryEncoder(&mut __bindgen_tmp, plain_modulus);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_BinaryEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BinaryEncoder_BinaryEncoder1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_BinaryEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BinaryEncoder_BinaryEncoder2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the BinaryEncoder.
    #[link_name = "\u{1}_ZN4seal13BinaryEncoderD1Ev"]
    pub fn seal_BinaryEncoder_BinaryEncoder_destructor(this: *mut seal_BinaryEncoder);
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder6encodeEm"]
    pub fn seal_BinaryEncoder_encode(
        this: *mut ::std::os::raw::c_void,
        value: u64,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder6encodeEmRNS_9PlaintextE"]
    pub fn seal_BinaryEncoder_encode1(
        this: *mut ::std::os::raw::c_void,
        value: u64,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::uint32_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=2.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if the output does not fit in std::uint32_t
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder13decode_uint32ERKNS_9PlaintextE"]
    pub fn seal_BinaryEncoder_decode_uint32(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> u32;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::uint64_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=2.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if the output does not fit in std::uint64_t
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder13decode_uint64ERKNS_9PlaintextE"]
    pub fn seal_BinaryEncoder_decode_uint64(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> u64;
}
extern "C" {
    ///Encodes a signed integer (represented by std::uint64_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers are represented by using -1 instead of 1 in the binary representation,
    ///and the negative coefficients are stored in the plaintext polynomials as unsigned integers
    ///that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
    ///would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder6encodeEl"]
    pub fn seal_BinaryEncoder_encode2(
        this: *mut ::std::os::raw::c_void,
        value: i64,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes a signed integer (represented by std::int64_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers are represented by using -1 instead of 1 in the binary representation,
    ///and the negative coefficients are stored in the plaintext polynomials as unsigned integers
    ///that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
    ///would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder6encodeElRNS_9PlaintextE"]
    pub fn seal_BinaryEncoder_encode3(
        this: *mut ::std::os::raw::c_void,
        value: i64,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder6encodeERKNS_7BigUIntE"]
    pub fn seal_BinaryEncoder_encode4(
        this: *mut ::std::os::raw::c_void,
        value: *const seal_BigUInt,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder6encodeERKNS_7BigUIntERNS_9PlaintextE"]
    pub fn seal_BinaryEncoder_encode5(
        this: *mut ::std::os::raw::c_void,
        value: *const seal_BigUInt,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::int32_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=2.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in std::int32_t
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder12decode_int32ERKNS_9PlaintextE"]
    pub fn seal_BinaryEncoder_decode_int32(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> i32;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::int64_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=2.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in std::int64_t
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder12decode_int64ERKNS_9PlaintextE"]
    pub fn seal_BinaryEncoder_decode_int64(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> i64;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as BigUInt.
    ///Mathematically this amounts to evaluating the input polynomial at X=2.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output is negative
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder14decode_biguintERKNS_9PlaintextE"]
    pub fn seal_BinaryEncoder_decode_biguint(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> seal_BigUInt;
}
extern "C" {
    ///Decodes a plaintext polynomial and stores the result in a given BigUInt.
    ///Mathematically this amounts to evaluating the input polynomial at X=2.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@param[out] destination The BigUInt to overwrite with the decoding
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in destination
    ///@throws std::invalid_argument if the output is negative
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder14decode_biguintERKNS_9PlaintextERNS_7BigUIntE"]
    pub fn seal_BinaryEncoder_decode_biguint1(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
        destination: *mut seal_BigUInt,
    );
}
extern "C" {
    ///Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers are represented by using -1 instead of 1 in the binary representation,
    ///and the negative coefficients are stored in the plaintext polynomials as unsigned integers
    ///that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
    ///would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder6encodeEi"]
    pub fn seal_BinaryEncoder_encode6(
        this: *mut ::std::os::raw::c_void,
        value: i32,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder6encodeEj"]
    pub fn seal_BinaryEncoder_encode7(
        this: *mut ::std::os::raw::c_void,
        value: u32,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers are represented by using -1 instead of 1 in the binary representation,
    ///and the negative coefficients are stored in the plaintext polynomials as unsigned integers
    ///that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
    ///would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder6encodeEiRNS_9PlaintextE"]
    pub fn seal_BinaryEncoder_encode8(
        this: *mut ::std::os::raw::c_void,
        value: i32,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal13BinaryEncoder6encodeEjRNS_9PlaintextE"]
    pub fn seal_BinaryEncoder_encode9(
        this: *mut ::std::os::raw::c_void,
        value: u32,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Returns a reference to the plaintext modulus.
    #[link_name = "\u{1}_ZNK4seal13BinaryEncoder13plain_modulusEv"]
    pub fn seal_BinaryEncoder_plain_modulus(
        this: *mut ::std::os::raw::c_void,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///<summary>Returns the base used for encoding (2).</summary>
    #[link_name = "\u{1}_ZNK4seal13BinaryEncoder4baseEv"]
    pub fn seal_BinaryEncoder_base(this: *mut ::std::os::raw::c_void) -> u64;
}
///Encodes integers into plaintext polynomials that Encryptor can encrypt. An instance of
///the BalancedEncoder class converts an integer into a plaintext polynomial by placing its
///digits in balanced base-b representation as the coefficients of the polynomial. The base
///b must be a positive integer at least 3 (which is the default value). When b is odd,
///digits in such a balanced representation are integers in the range
///-(b-1)/2,...,(b-1)/2. When b is even, digits are integers in the range -b/2,..., b/2-1.
///Note that the default value 3 for the base b allows for more compact representation than
///BinaryEncoder without increasing the sizes of the coefficients of freshly encoded plaintext
///polynomials. A larger base allows for an even more compact representation at the cost of
///having larger coefficients in freshly encoded plaintext polynomials. Decoding the integer
///amounts to evaluating the plaintext polynomial at X=b.
///
///Addition and multiplication on the integer side translate into addition and multiplication
///on the encoded plaintext polynomial side, provided that the length of the polynomial
///never grows to be of the size of the polynomial modulus (poly_modulus), and that the
///coefficients of the plaintext polynomials appearing throughout the computations never
///experience coefficients larger than the plaintext modulus (plain_modulus).
///
///@par Negative Integers
///Negative integers in the balanced base-b encoding are represented the same way as
///positive integers, namely, both positive and negative integers can have both positive and negative
///digits in their balanced base-b representation. Negative coefficients are stored in the
///plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
///Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.
///
///@see BalancedFractionalEncoder for encoding real numbers.
///@see BinaryEncoder for encoding using the binary representation.
///@see IntegerEncoder for a common interface to all integer encoders.
#[repr(C)]
#[derive(Debug)]
pub struct seal_BalancedEncoder {
    pub _base: seal_AbstractIntegerEncoder,
    pub pool_: seal_MemoryPoolHandle,
    pub plain_modulus_: seal_util_global_variables_internal_mods_SmallModulus,
    pub base_: u64,
    pub coeff_neg_threshold_: u64,
}
#[test]
fn bindgen_test_layout_seal_BalancedEncoder() {
    assert_eq!(
        ::std::mem::size_of::<seal_BalancedEncoder>(),
        88usize,
        concat!("Size of: ", stringify!(seal_BalancedEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_BalancedEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_BalancedEncoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_BalancedEncoder>())).pool_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BalancedEncoder),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BalancedEncoder>())).plain_modulus_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BalancedEncoder),
            "::",
            stringify!(plain_modulus_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_BalancedEncoder>())).base_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BalancedEncoder),
            "::",
            stringify!(base_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BalancedEncoder>())).coeff_neg_threshold_ as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BalancedEncoder),
            "::",
            stringify!(coeff_neg_threshold_)
        )
    );
}
extern "C" {
    ///Creates a BalancedEncoder object. The constructor takes as input a reference
    ///to the plaintext modulus (represented by SmallModulus), and optionally an integer,
    ///at least 3, that is used as a base in the encoding.
    ///
    ///@param[in] plain_modulus The plaintext modulus (represented by SmallModulus)
    ///@param[in] base The base to be used for encoding (default value is 3)
    ///@throws std::invalid_argument if base is not an integer and at least 3
    ///@throws std::invalid_argument if plain_modulus is not at least base
    #[link_name = "\u{1}_ZN4seal15BalancedEncoderC1ERKNS_12SmallModulusEm"]
    pub fn seal_BalancedEncoder_BalancedEncoder(
        this: *mut seal_BalancedEncoder,
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        base: u64,
    );
}
extern "C" {
    ///Creates a copy of a BalancedEncoder.
    ///
    ///@param[in] copy The BalancedEncoder to copy from
    #[link_name = "\u{1}_ZN4seal15BalancedEncoderC1ERKS0_"]
    pub fn seal_BalancedEncoder_BalancedEncoder1(
        this: *mut seal_BalancedEncoder,
        copy: *const seal_BalancedEncoder,
    );
}
extern "C" {
    ///Creates a new BalancedEncoder by moving an old one.
    ///
    ///@param[in] source The BalancedEncoder to move from
    #[link_name = "\u{1}_ZN4seal15BalancedEncoderC1EOS0_"]
    pub fn seal_BalancedEncoder_BalancedEncoder2(
        this: *mut seal_BalancedEncoder,
        source: *mut seal_BalancedEncoder,
    );
}
impl Default for seal_BalancedEncoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_BalancedEncoder {
    #[inline]
    pub unsafe fn new(
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        base: u64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BalancedEncoder_BalancedEncoder(&mut __bindgen_tmp, plain_modulus, base);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_BalancedEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BalancedEncoder_BalancedEncoder1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_BalancedEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BalancedEncoder_BalancedEncoder2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the BalancedEncoder.
    #[link_name = "\u{1}_ZN4seal15BalancedEncoderD1Ev"]
    pub fn seal_BalancedEncoder_BalancedEncoder_destructor(this: *mut seal_BalancedEncoder);
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder6encodeEm"]
    pub fn seal_BalancedEncoder_encode(
        this: *mut ::std::os::raw::c_void,
        value: u64,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder6encodeEmRNS_9PlaintextE"]
    pub fn seal_BalancedEncoder_encode1(
        this: *mut ::std::os::raw::c_void,
        value: u64,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::uint32_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in std::uint32_t
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder13decode_uint32ERKNS_9PlaintextE"]
    pub fn seal_BalancedEncoder_decode_uint32(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> u32;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::uint64_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in std::uint64_t
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder13decode_uint64ERKNS_9PlaintextE"]
    pub fn seal_BalancedEncoder_decode_uint64(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> u64;
}
extern "C" {
    ///Encodes a signed integer (represented by std::int64_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers in the balanced base-b encoding are represented the same way as
    ///positive integers, namely, both positive and negative integers can have both positive and negative
    ///digits in their balanced base-b representation. Negative coefficients are stored in the
    ///plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
    ///Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder6encodeEl"]
    pub fn seal_BalancedEncoder_encode2(
        this: *mut ::std::os::raw::c_void,
        value: i64,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes a signed integer (represented by std::int64_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers in the balanced base-b encoding are represented the same way as
    ///positive integers, namely, both positive and negative integers can have both positive and negative
    ///digits in their balanced base-b representation. Negative coefficients are stored in the
    ///plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
    ///Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder6encodeElRNS_9PlaintextE"]
    pub fn seal_BalancedEncoder_encode3(
        this: *mut ::std::os::raw::c_void,
        value: i64,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder6encodeERKNS_7BigUIntE"]
    pub fn seal_BalancedEncoder_encode4(
        this: *mut ::std::os::raw::c_void,
        value: *const seal_BigUInt,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder6encodeERKNS_7BigUIntERNS_9PlaintextE"]
    pub fn seal_BalancedEncoder_encode5(
        this: *mut ::std::os::raw::c_void,
        value: *const seal_BigUInt,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::int32_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in std::int32_t
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder12decode_int32ERKNS_9PlaintextE"]
    pub fn seal_BalancedEncoder_decode_int32(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> i32;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::int64_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in std::int64_t
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder12decode_int64ERKNS_9PlaintextE"]
    pub fn seal_BalancedEncoder_decode_int64(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> i64;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as BigUInt.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output is negative
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder14decode_biguintERKNS_9PlaintextE"]
    pub fn seal_BalancedEncoder_decode_biguint(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> seal_BigUInt;
}
extern "C" {
    ///Decodes a plaintext polynomial and stores the result in a given BigUInt.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@param[out] destination The BigUInt to overwrite with the decoding
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in destination
    ///@throws std::invalid_argument if the output is negative
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder14decode_biguintERKNS_9PlaintextERNS_7BigUIntE"]
    pub fn seal_BalancedEncoder_decode_biguint1(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
        destination: *mut seal_BigUInt,
    );
}
extern "C" {
    ///Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers in the balanced base-b encoding are represented the same way as
    ///positive integers, namely, both positive and negative integers can have both positive and negative
    ///digits in their balanced base-b representation. Negative coefficients are stored in the
    ///plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
    ///Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder6encodeEi"]
    pub fn seal_BalancedEncoder_encode6(
        this: *mut ::std::os::raw::c_void,
        value: i32,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder6encodeEj"]
    pub fn seal_BalancedEncoder_encode7(
        this: *mut ::std::os::raw::c_void,
        value: u32,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers in the balanced base-b encoding are represented the same way as
    ///positive integers, namely, both positive and negative integers can have both positive and negative
    ///digits in their balanced base-b representation. Negative coefficients are stored in the
    ///plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
    ///Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder6encodeEiRNS_9PlaintextE"]
    pub fn seal_BalancedEncoder_encode8(
        this: *mut ::std::os::raw::c_void,
        value: i32,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal15BalancedEncoder6encodeEjRNS_9PlaintextE"]
    pub fn seal_BalancedEncoder_encode9(
        this: *mut ::std::os::raw::c_void,
        value: u32,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Returns a reference to the plaintext modulus.
    #[link_name = "\u{1}_ZNK4seal15BalancedEncoder13plain_modulusEv"]
    pub fn seal_BalancedEncoder_plain_modulus(
        this: *mut ::std::os::raw::c_void,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///Returns the base used for encoding.
    #[link_name = "\u{1}_ZNK4seal15BalancedEncoder4baseEv"]
    pub fn seal_BalancedEncoder_base(this: *mut ::std::os::raw::c_void) -> u64;
}
///Encodes floating point numbers into plaintext polynomials that Encryptor can encrypt.
///An instance of the BinaryFractionalEncoder class converts a double-precision floating-point
///number into a plaintext polynomial by computing its binary representation, encoding the
///integral part as in BinaryEncoder, and the fractional part as the highest degree
///terms of the plaintext polynomial, with signs inverted. Decoding the polynomial
///back into a double amounts to evaluating the low degree part at X=2, negating the
///coefficients of the high degree part and evaluating it at X=1/2.
///
///Addition and multiplication on the double side translate into addition and multiplication
///on the encoded plaintext polynomial side, provided that the integral part never mixes
///with the fractional part in the plaintext polynomials, and that the
///coefficients of the plaintext polynomials appearing throughout the computations never
///experience coefficients larger than the plaintext modulus (plain_modulus).
///
///@par Integral and Fractional Parts
///When homomorphic multiplications are performed, the integral part "grows up" to higher
///degree coefficients of the plaintext polynomial space, and the fractional part "grows down"
///from the top degree coefficients towards the lower degree coefficients. For decoding to work,
///these parts must not interfere with each other. When setting up the BinaryFractionalEncoder,
///one must specify how many coefficients of a plaintext polynomial are reserved for the integral
///part and how many for the fractional. The sum of these numbers can be at most equal to the
///degree of the polynomial modulus minus one. If homomorphic multiplications are performed, it is
///also necessary to leave enough room for the fractional part to "grow down".
///
///@par Negative Integers
///Negative integers are represented by using -1 instead of 1 in the binary representation,
///and the negative coefficients are stored in the plaintext polynomials as unsigned integers
///that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
///would be stored as a polynomial coefficient plain_modulus-1.
///
///@see BinaryEncoder for encoding integers.
///@see BalancedFractionalEncoder for encoding using base-b representation for b greater than 2.
///@see FractionalEncoder for a common interface to all fractional encoders.
#[repr(C)]
#[derive(Debug)]
pub struct seal_BinaryFractionalEncoder {
    pub _base: seal_AbstractFractionalEncoder,
    pub pool_: seal_MemoryPoolHandle,
    pub encoder_: seal_BinaryEncoder,
    pub fraction_coeff_count_: usize,
    pub integer_coeff_count_: usize,
    pub poly_modulus_degree_: usize,
}
#[test]
fn bindgen_test_layout_seal_BinaryFractionalEncoder() {
    assert_eq!(
        ::std::mem::size_of::<seal_BinaryFractionalEncoder>(),
        136usize,
        concat!("Size of: ", stringify!(seal_BinaryFractionalEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_BinaryFractionalEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_BinaryFractionalEncoder))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BinaryFractionalEncoder>())).pool_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BinaryFractionalEncoder),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BinaryFractionalEncoder>())).encoder_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BinaryFractionalEncoder),
            "::",
            stringify!(encoder_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BinaryFractionalEncoder>())).fraction_coeff_count_
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BinaryFractionalEncoder),
            "::",
            stringify!(fraction_coeff_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BinaryFractionalEncoder>())).integer_coeff_count_
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BinaryFractionalEncoder),
            "::",
            stringify!(integer_coeff_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BinaryFractionalEncoder>())).poly_modulus_degree_
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BinaryFractionalEncoder),
            "::",
            stringify!(poly_modulus_degree_)
        )
    );
}
extern "C" {
    ///Creates a new BinaryFractionalEncoder object. The constructor takes as input a reference
    ///to the plaintext modulus, the degree of the polynomial modulus, and the numbers of
    ///coefficients that are reserved for the integral and fractional parts. The coefficients
    ///for the integral part are counted starting from the low-degree end of the polynomial,
    ///and the coefficients for the fractional part are counted from the high-degree end.
    ///
    ///@param[in] plain_modulus The plaintext modulus (represented by SmallModulus)
    ///@param[in] poly_modulus_degree The degree of the polynomial modulus
    ///@param[in] integer_coeff_count The number of polynomial coefficients reserved for the integral part
    ///@param[in] fraction_coeff_count The number of polynomial coefficients reserved for the fractional part
    ///@throws std::invalid_argument if plain_modulus_degree is invalid
    ///@throws std::invalid_argument if integer_coeff_count is not strictly positive
    ///@throws std::invalid_argument if fraction_coeff_count is not strictly positive
    ///@throws std::invalid_argument if poly_modulus_degree is too small for the integral and fractional parts
    #[link_name = "\u{1}_ZN4seal23BinaryFractionalEncoderC1ERKNS_12SmallModulusEmmm"]
    pub fn seal_BinaryFractionalEncoder_BinaryFractionalEncoder(
        this: *mut seal_BinaryFractionalEncoder,
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        poly_modulus_degree: usize,
        integer_coeff_count: usize,
        fraction_coeff_count: usize,
    );
}
extern "C" {
    ///Creates a copy of a BinaryFractionalEncoder.
    ///
    ///@param[in] copy The BinaryFractionalEncoder to copy from
    #[link_name = "\u{1}_ZN4seal23BinaryFractionalEncoderC1ERKS0_"]
    pub fn seal_BinaryFractionalEncoder_BinaryFractionalEncoder1(
        this: *mut seal_BinaryFractionalEncoder,
        copy: *const seal_BinaryFractionalEncoder,
    );
}
extern "C" {
    ///Creates a new BinaryFractionalEncoder by moving an old one.
    ///
    ///@param[in] source The BinaryFractionalEncoder to move from
    #[link_name = "\u{1}_ZN4seal23BinaryFractionalEncoderC1EOS0_"]
    pub fn seal_BinaryFractionalEncoder_BinaryFractionalEncoder2(
        this: *mut seal_BinaryFractionalEncoder,
        source: *mut seal_BinaryFractionalEncoder,
    );
}
impl Default for seal_BinaryFractionalEncoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_BinaryFractionalEncoder {
    #[inline]
    pub unsafe fn new(
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        poly_modulus_degree: usize,
        integer_coeff_count: usize,
        fraction_coeff_count: usize,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BinaryFractionalEncoder_BinaryFractionalEncoder(
            &mut __bindgen_tmp,
            plain_modulus,
            poly_modulus_degree,
            integer_coeff_count,
            fraction_coeff_count,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_BinaryFractionalEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BinaryFractionalEncoder_BinaryFractionalEncoder1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_BinaryFractionalEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BinaryFractionalEncoder_BinaryFractionalEncoder2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the BinaryFractionalEncoder.
    #[link_name = "\u{1}_ZN4seal23BinaryFractionalEncoderD1Ev"]
    pub fn seal_BinaryFractionalEncoder_BinaryFractionalEncoder_destructor(
        this: *mut seal_BinaryFractionalEncoder,
    );
}
extern "C" {
    ///Encodes a double precision floating point number into a plaintext polynomial.
    ///
    ///@param[in] value The double-precision floating-point number to encode
    #[link_name = "\u{1}_ZN4seal23BinaryFractionalEncoder6encodeEd"]
    pub fn seal_BinaryFractionalEncoder_encode(
        this: *mut ::std::os::raw::c_void,
        value: f64,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as a double-precision
    ///floating-point number.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the integral part does not fit in std::int64_t
    #[link_name = "\u{1}_ZN4seal23BinaryFractionalEncoder6decodeERKNS_9PlaintextE"]
    pub fn seal_BinaryFractionalEncoder_decode(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> f64;
}
extern "C" {
    ///Returns a reference to the plaintext modulus.
    #[link_name = "\u{1}_ZNK4seal23BinaryFractionalEncoder13plain_modulusEv"]
    pub fn seal_BinaryFractionalEncoder_plain_modulus(
        this: *mut ::std::os::raw::c_void,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///Returns the degree of the polynomial modulus.
    #[link_name = "\u{1}_ZNK4seal23BinaryFractionalEncoder19poly_modulus_degreeEv"]
    pub fn seal_BinaryFractionalEncoder_poly_modulus_degree(
        this: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    ///Returns the base used for encoding (2).
    #[link_name = "\u{1}_ZNK4seal23BinaryFractionalEncoder4baseEv"]
    pub fn seal_BinaryFractionalEncoder_base(this: *mut ::std::os::raw::c_void) -> u64;
}
extern "C" {
    ///Returns the number of coefficients reserved for the fractional part.
    #[link_name = "\u{1}_ZNK4seal23BinaryFractionalEncoder20fraction_coeff_countEv"]
    pub fn seal_BinaryFractionalEncoder_fraction_coeff_count(
        this: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    ///Returns the number of coefficients reserved for the integral part.
    #[link_name = "\u{1}_ZNK4seal23BinaryFractionalEncoder19integer_coeff_countEv"]
    pub fn seal_BinaryFractionalEncoder_integer_coeff_count(
        this: *mut ::std::os::raw::c_void,
    ) -> usize;
}
///Encodes floating point numbers into plaintext polynomials that Encryptor can encrypt.
///An instance of the BalancedFractionalEncoder class converts a double-precision floating-point
///number into a plaintext polynomial by computing its balanced base-b representation, encoding the
///integral part as in BalancedEncoder, and the fractional part as the highest degree
///terms of the plaintext polynomial, with signs inverted. For an even base b, the
///coefficients of the polynomial are in the range -b/2,...,b/2-1. Decoding the polynomial back
///into a double amounts to evaluating the low degree part at X=b, negating the coefficients
///of the high degree part and evaluating it at X=1/b.
///
///Addition and multiplication on the double side translate into addition and multiplication
///on the encoded plaintext polynomial side, provided that the integral part never mixes
///with the fractional part in the plaintext polynomials, and that the
///coefficients of the plaintext polynomials appearing throughout the computations never
///experience coefficients larger than the plaintext modulus (plain_modulus).
///
///@par Integral and Fractional Parts
///When homomorphic multiplications are performed, the integral part "grows up" to higher
///degree coefficients of the plaintext polynomial space, and the fractional part "grows down"
///from the top degree coefficients towards the lower degree coefficients. For decoding to work,
///these parts must not interfere with each other. When setting up the BalancedFractionalEncoder,
///one must specify how many coefficients of a plaintext polynomial are reserved for the integral
///part and how many for the fractional. The sum of these numbers can be at most equal to the
///degree of the polynomial modulus minus one. If homomorphic multiplications are performed, it is
///also necessary to leave enough room for the fractional part to "grow down".
///
///@par Negative Integers
///Negative integers in the balanced base-b encoding are represented the same way as
///positive integers, namely, both positive and negative integers can have both positive and negative
///digits in their balanced base-b representation. Negative coefficients are stored in the
///plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
///Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.
///
///@see BalancedEncoder for encoding integers.
///@see BinaryFractionalEncoder for encoding using the binary representation.
///@see FractionalEncoder for a common interface to all fractional encoders.
#[repr(C)]
#[derive(Debug)]
pub struct seal_BalancedFractionalEncoder {
    pub _base: seal_AbstractFractionalEncoder,
    pub pool_: seal_MemoryPoolHandle,
    pub encoder_: seal_BalancedEncoder,
    pub fraction_coeff_count_: usize,
    pub integer_coeff_count_: usize,
    pub poly_modulus_degree_: usize,
}
#[test]
fn bindgen_test_layout_seal_BalancedFractionalEncoder() {
    assert_eq!(
        ::std::mem::size_of::<seal_BalancedFractionalEncoder>(),
        136usize,
        concat!("Size of: ", stringify!(seal_BalancedFractionalEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_BalancedFractionalEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_BalancedFractionalEncoder))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BalancedFractionalEncoder>())).pool_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BalancedFractionalEncoder),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BalancedFractionalEncoder>())).encoder_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BalancedFractionalEncoder),
            "::",
            stringify!(encoder_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BalancedFractionalEncoder>())).fraction_coeff_count_
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BalancedFractionalEncoder),
            "::",
            stringify!(fraction_coeff_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BalancedFractionalEncoder>())).integer_coeff_count_
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BalancedFractionalEncoder),
            "::",
            stringify!(integer_coeff_count_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BalancedFractionalEncoder>())).poly_modulus_degree_
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BalancedFractionalEncoder),
            "::",
            stringify!(poly_modulus_degree_)
        )
    );
}
extern "C" {
    ///Creates a new BalancedFractionalEncoder object. The constructor takes as input a reference
    ///to the plaintext modulus, the degree of the polynomial modulus, and the numbers of
    ///coefficients that are reserved for the integral and fractional parts, and optionally
    ///an integer, at least 3, that is used as the base in the encoding. The coefficients for the
    ///integral part are counted starting from the low-degree end of the polynomial, and the
    ///coefficients for the fractional part are counted from the high-degree end.
    ///
    ///@param[in] plain_modulus The plaintext modulus (represented by SmallModulus)
    ///@param[in] poly_modulus_degree The degree of the polynomial modulus
    ///@param[in] integer_coeff_count The number of polynomial coefficients reserved for the integral part
    ///@param[in] fraction_coeff_count The number of polynomial coefficients reserved for the fractional part
    ///@param[in] base The base to be used for encoding (default value is 3)
    ///@throws std::invalid_argument if plain_modulus is not at least base
    ///@throws std::invalid_argument if integer_coeff_count is not strictly positive
    ///@throws std::invalid_argument if fraction_coeff_count is not strictly positive
    ///@throws std::invalid_argument if poly_modulus_degree is too small for the integral and fractional parts
    ///@throws std::invalid_argument if base is not an integer and at least 3
    #[link_name = "\u{1}_ZN4seal25BalancedFractionalEncoderC1ERKNS_12SmallModulusEmmmm"]
    pub fn seal_BalancedFractionalEncoder_BalancedFractionalEncoder(
        this: *mut seal_BalancedFractionalEncoder,
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        poly_modulus_degree: usize,
        integer_coeff_count: usize,
        fraction_coeff_count: usize,
        base: u64,
    );
}
extern "C" {
    ///Creates a copy of a BalancedFractionalEncoder.
    ///
    ///@param[in] copy The BalancedFractionalEncoder to copy from
    #[link_name = "\u{1}_ZN4seal25BalancedFractionalEncoderC1ERKS0_"]
    pub fn seal_BalancedFractionalEncoder_BalancedFractionalEncoder1(
        this: *mut seal_BalancedFractionalEncoder,
        copy: *const seal_BalancedFractionalEncoder,
    );
}
extern "C" {
    ///Creates a new BalancedFractionalEncoder by moving an old one.
    ///
    ///@param[in] source The BalancedFractionalEncoder to move from
    #[link_name = "\u{1}_ZN4seal25BalancedFractionalEncoderC1EOS0_"]
    pub fn seal_BalancedFractionalEncoder_BalancedFractionalEncoder2(
        this: *mut seal_BalancedFractionalEncoder,
        source: *mut seal_BalancedFractionalEncoder,
    );
}
impl Default for seal_BalancedFractionalEncoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_BalancedFractionalEncoder {
    #[inline]
    pub unsafe fn new(
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        poly_modulus_degree: usize,
        integer_coeff_count: usize,
        fraction_coeff_count: usize,
        base: u64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BalancedFractionalEncoder_BalancedFractionalEncoder(
            &mut __bindgen_tmp,
            plain_modulus,
            poly_modulus_degree,
            integer_coeff_count,
            fraction_coeff_count,
            base,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_BalancedFractionalEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BalancedFractionalEncoder_BalancedFractionalEncoder1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_BalancedFractionalEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BalancedFractionalEncoder_BalancedFractionalEncoder2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the BalancedFractionalEncoder.
    #[link_name = "\u{1}_ZN4seal25BalancedFractionalEncoderD1Ev"]
    pub fn seal_BalancedFractionalEncoder_BalancedFractionalEncoder_destructor(
        this: *mut seal_BalancedFractionalEncoder,
    );
}
extern "C" {
    ///Encodes a double precision floating point number into a plaintext polynomial.
    ///
    ///@param[in] value The double-precision floating-point number to encode
    #[link_name = "\u{1}_ZN4seal25BalancedFractionalEncoder6encodeEd"]
    pub fn seal_BalancedFractionalEncoder_encode(
        this: *mut ::std::os::raw::c_void,
        value: f64,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as a double-precision
    ///floating-point number.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the integral part does not fit in std::int64_t
    #[link_name = "\u{1}_ZN4seal25BalancedFractionalEncoder6decodeERKNS_9PlaintextE"]
    pub fn seal_BalancedFractionalEncoder_decode(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> f64;
}
extern "C" {
    ///Returns a reference to the plaintext modulus.
    #[link_name = "\u{1}_ZNK4seal25BalancedFractionalEncoder13plain_modulusEv"]
    pub fn seal_BalancedFractionalEncoder_plain_modulus(
        this: *mut ::std::os::raw::c_void,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///Returns the degree of the polynomial modulus.
    #[link_name = "\u{1}_ZNK4seal25BalancedFractionalEncoder19poly_modulus_degreeEv"]
    pub fn seal_BalancedFractionalEncoder_poly_modulus_degree(
        this: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    ///Returns the base used for encoding.
    #[link_name = "\u{1}_ZNK4seal25BalancedFractionalEncoder4baseEv"]
    pub fn seal_BalancedFractionalEncoder_base(this: *mut ::std::os::raw::c_void) -> u64;
}
extern "C" {
    ///Returns the number of coefficients reserved for the fractional part.
    #[link_name = "\u{1}_ZNK4seal25BalancedFractionalEncoder20fraction_coeff_countEv"]
    pub fn seal_BalancedFractionalEncoder_fraction_coeff_count(
        this: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    ///Returns the number of coefficients reserved for the integral part.
    #[link_name = "\u{1}_ZNK4seal25BalancedFractionalEncoder19integer_coeff_countEv"]
    pub fn seal_BalancedFractionalEncoder_integer_coeff_count(
        this: *mut ::std::os::raw::c_void,
    ) -> usize;
}
///Encodes integers into plaintext polynomials that Encryptor can encrypt. An instance of
///the IntegerEncoder class converts an integer into a plaintext polynomial by placing its
///digits in balanced base-b representation as the coefficients of the polynomial. The base
///b must be a positive integer at least 2 (which is the default value). When b is odd,
///digits in such a balanced representation are integers in the range -(b-1)/2,...,(b-1)/2.
///When b is even, digits are integers in the range -b/2,...,b/2-1. When b is 2, the
///coefficients are either all non-negative (0 and 1), or all non-positive (0 and -1). A larger
///base allows for more compact representation at the cost of having larger coefficients in
///freshly encoded plaintext polynomials. Decoding the integer amounts to evaluating the
///plaintext polynomial at X=b.
///
///Addition and multiplication on the integer side translate into addition and multiplication
///on the encoded plaintext polynomial side, provided that the length of the polynomial
///never grows to be of the size of the polynomial modulus (poly_modulus), and that the
///coefficients of the plaintext polynomials appearing throughout the computations never
///experience coefficients larger than the plaintext modulus (plain_modulus).
///
///@par Negative Integers
///Negative integers in the base-b encoding are represented the same way as positive integers,
///namely, both positive and negative integers can have both positive and negative digits in their
///base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
///integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
///would be stored as a polynomial coefficient plain_modulus-1.
///
///@par BinaryEncoder and BalancedEncoder
///Under the hood IntegerEncoder uses either the BinaryEncoder or the BalancedEncoder classes
///to do the encoding. The first one is used when the base is 2, and the second one when the
///base is at least 3. Currently the BinaryEncoder and BalancedEncoder classes can also be used
///directly, but this might change in future releases.
///
///@see BinaryEncoder for encoding using the binary representation.
///@see BalancedEncoder for encoding using base-b representation for b greater than 2.
///@see FractionalEncoder for encoding real numbers.
#[repr(C)]
#[derive(Debug)]
pub struct seal_IntegerEncoder {
    pub _base: seal_AbstractIntegerEncoder,
    pub encoder_: *mut seal_AbstractIntegerEncoder,
}
#[test]
fn bindgen_test_layout_seal_IntegerEncoder() {
    assert_eq!(
        ::std::mem::size_of::<seal_IntegerEncoder>(),
        16usize,
        concat!("Size of: ", stringify!(seal_IntegerEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_IntegerEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_IntegerEncoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_IntegerEncoder>())).encoder_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_IntegerEncoder),
            "::",
            stringify!(encoder_)
        )
    );
}
extern "C" {
    ///Creates an IntegerEncoder object. The constructor takes as input a reference
    ///to the plaintext modulus (represented by SmallModulus), and optionally an integer,
    ///at least 2, that is used as a base in the encoding.
    ///
    ///@param[in] plain_modulus The plaintext modulus (represented by SmallModulus)
    ///@param[in] base The base to be used for encoding (default value is 2)
    ///@throws std::invalid_argument if base is not an integer and at least 2
    ///@throws std::invalid_argument if plain_modulus is not at least base
    #[link_name = "\u{1}_ZN4seal14IntegerEncoderC1ERKNS_12SmallModulusEm"]
    pub fn seal_IntegerEncoder_IntegerEncoder(
        this: *mut seal_IntegerEncoder,
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        base: u64,
    );
}
extern "C" {
    ///Creates a copy of a IntegerEncoder.
    ///
    ///@param[in] copy The IntegerEncoder to copy from
    #[link_name = "\u{1}_ZN4seal14IntegerEncoderC1ERKS0_"]
    pub fn seal_IntegerEncoder_IntegerEncoder1(
        this: *mut seal_IntegerEncoder,
        copy: *const seal_IntegerEncoder,
    );
}
extern "C" {
    ///Creates a new IntegerEncoder by moving an old one.
    ///
    ///@param[in] source The IntegerEncoder to move from
    #[link_name = "\u{1}_ZN4seal14IntegerEncoderC1EOS0_"]
    pub fn seal_IntegerEncoder_IntegerEncoder2(
        this: *mut seal_IntegerEncoder,
        source: *mut seal_IntegerEncoder,
    );
}
impl Default for seal_IntegerEncoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_IntegerEncoder {
    #[inline]
    pub unsafe fn new(
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        base: u64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_IntegerEncoder_IntegerEncoder(&mut __bindgen_tmp, plain_modulus, base);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_IntegerEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_IntegerEncoder_IntegerEncoder1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_IntegerEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_IntegerEncoder_IntegerEncoder2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the IntegerEncoder.
    #[link_name = "\u{1}_ZN4seal14IntegerEncoderD1Ev"]
    pub fn seal_IntegerEncoder_IntegerEncoder_destructor(this: *mut seal_IntegerEncoder);
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder6encodeEm"]
    pub fn seal_IntegerEncoder_encode(
        this: *mut ::std::os::raw::c_void,
        value: u64,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder6encodeEmRNS_9PlaintextE"]
    pub fn seal_IntegerEncoder_encode1(
        this: *mut ::std::os::raw::c_void,
        value: u64,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::uint32_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in std::uint32_t
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder13decode_uint32ERKNS_9PlaintextE"]
    pub fn seal_IntegerEncoder_decode_uint32(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> u32;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::uint64_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in std::uint64_t
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder13decode_uint64ERKNS_9PlaintextE"]
    pub fn seal_IntegerEncoder_decode_uint64(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> u64;
}
extern "C" {
    ///Encodes a signed integer (represented by std::int64_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers in the base-b encoding are represented the same way as positive integers,
    ///namely, both positive and negative integers can have both positive and negative digits in their
    ///base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
    ///integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
    ///would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder6encodeEl"]
    pub fn seal_IntegerEncoder_encode2(
        this: *mut ::std::os::raw::c_void,
        value: i64,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes a signed integer (represented by std::int64_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers in the base-b encoding are represented the same way as positive integers,
    ///namely, both positive and negative integers can have both positive and negative digits in their
    ///base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
    ///integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
    ///would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder6encodeElRNS_9PlaintextE"]
    pub fn seal_IntegerEncoder_encode3(
        this: *mut ::std::os::raw::c_void,
        value: i64,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder6encodeERKNS_7BigUIntE"]
    pub fn seal_IntegerEncoder_encode4(
        this: *mut ::std::os::raw::c_void,
        value: *const seal_BigUInt,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder6encodeERKNS_7BigUIntERNS_9PlaintextE"]
    pub fn seal_IntegerEncoder_encode5(
        this: *mut ::std::os::raw::c_void,
        value: *const seal_BigUInt,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::int32_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in std::int32_t
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder12decode_int32ERKNS_9PlaintextE"]
    pub fn seal_IntegerEncoder_decode_int32(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> i32;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as std::int64_t.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in std::int64_t
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder12decode_int64ERKNS_9PlaintextE"]
    pub fn seal_IntegerEncoder_decode_int64(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> i64;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as BigUInt.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output is negative
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder14decode_biguintERKNS_9PlaintextE"]
    pub fn seal_IntegerEncoder_decode_biguint(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> seal_BigUInt;
}
extern "C" {
    ///Decodes a plaintext polynomial and stores the result in a given BigUInt.
    ///Mathematically this amounts to evaluating the input polynomial at X=base.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@param[out] destination The BigUInt to overwrite with the decoding
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the output does not fit in destination
    ///@throws std::invalid_argument if the output is negative
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder14decode_biguintERKNS_9PlaintextERNS_7BigUIntE"]
    pub fn seal_IntegerEncoder_decode_biguint1(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
        destination: *mut seal_BigUInt,
    );
}
extern "C" {
    ///Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers in the base-b encoding are represented the same way as positive integers,
    ///namely, both positive and negative integers can have both positive and negative digits in their
    ///base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
    ///integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
    ///would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder6encodeEi"]
    pub fn seal_IntegerEncoder_encode6(
        this: *mut ::std::os::raw::c_void,
        value: i32,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder6encodeEj"]
    pub fn seal_IntegerEncoder_encode7(
        this: *mut ::std::os::raw::c_void,
        value: u32,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.
    ///
    ///@par Negative Integers
    ///Negative integers in the base-b encoding are represented the same way as positive integers,
    ///namely, both positive and negative integers can have both positive and negative digits in their
    ///base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
    ///integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
    ///would be stored as a polynomial coefficient plain_modulus-1.
    ///
    ///@param[in] value The signed integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder6encodeEiRNS_9PlaintextE"]
    pub fn seal_IntegerEncoder_encode8(
        this: *mut ::std::os::raw::c_void,
        value: i32,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.
    ///
    ///@param[in] value The unsigned integer to encode
    ///@param[out] destination The plaintext to overwrite with the encoding
    #[link_name = "\u{1}_ZN4seal14IntegerEncoder6encodeEjRNS_9PlaintextE"]
    pub fn seal_IntegerEncoder_encode9(
        this: *mut ::std::os::raw::c_void,
        value: u32,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Returns a reference to the plaintext modulus.
    #[link_name = "\u{1}_ZNK4seal14IntegerEncoder13plain_modulusEv"]
    pub fn seal_IntegerEncoder_plain_modulus(
        this: *mut ::std::os::raw::c_void,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///Returns the base used for encoding.
    #[link_name = "\u{1}_ZNK4seal14IntegerEncoder4baseEv"]
    pub fn seal_IntegerEncoder_base(this: *mut ::std::os::raw::c_void) -> u64;
}
///Encodes floating point numbers into plaintext polynomials that Encryptor can encrypt.
///An instance of the FractionalEncoder class converts a double-precision floating-point
///number into a plaintext polynomial by computing its balanced base-b representation,
///encoding the integral part as in IntegerEncoder, and the fractional part as the highest
///degree terms of the plaintext polynomial, with signs inverted. For an even base b, the
///coefficients of the polynomial are in the range -b/2,...,b/2-1. When b is 2, the
///coefficients are either all non-negative (0 and 1), or all non-positive (0 and -1).
///Decoding the polynomial back into a double amounts to evaluating the low degree part
///at X=b, negating the coefficients of the high degree part and evaluating it at X=1/b.
///
///Addition and multiplication on the double side translate into addition and multiplication
///on the encoded plaintext polynomial side, provided that the integral part never mixes
///with the fractional part in the plaintext polynomials, and that the
///coefficients of the plaintext polynomials appearing throughout the computations never
///experience coefficients larger than the plaintext modulus (plain_modulus).
///
///@par Integral and Fractional Parts
///When homomorphic multiplications are performed, the integral part "grows up" to higher
///degree coefficients of the plaintext polynomial space, and the fractional part "grows down"
///from the top degree coefficients towards the lower degree coefficients. For decoding to work,
///these parts must not interfere with each other. When setting up the BalancedFractionalEncoder,
///one must specify how many coefficients of a plaintext polynomial are reserved for the integral
///part and how many for the fractional. The sum of these numbers can be at most equal to the
///degree of the polynomial modulus minus one. If homomorphic multiplications are performed, it is
///also necessary to leave enough room for the fractional part to "grow down".
///
///@par Negative Integers
///Negative integers in the base-b encoding are represented the same way as positive integers,
///namely, both positive and negative integers can have both positive and negative digits in their
///base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
///integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
///would be stored as a polynomial coefficient plain_modulus-1.
///
///@par BinaryFractionalEncoder and BalancedFractionalEncoder
///Under the hood FractionalEncoder uses either the BinaryFractionalEncoder or the
///BalancedFractionalEncoder classes to do the encoding. The first one is used when the base is 2,
///and the second one when the base is at least 3. Currently the BinaryFractionalEncoder and
///BalancedFractionalEncoder classes can also be used directly, but this might change in future releases.
///
///@see BinaryFractionalEncoder for encoding using the binary representation.
///@see BalancedFractionalEncoder for encoding using base-b representation for b greater than 2.
///@see IntegerEncoder for encoding integers.
#[repr(C)]
#[derive(Debug)]
pub struct seal_FractionalEncoder {
    pub _base: seal_AbstractFractionalEncoder,
    pub encoder_: *mut seal_AbstractFractionalEncoder,
}
#[test]
fn bindgen_test_layout_seal_FractionalEncoder() {
    assert_eq!(
        ::std::mem::size_of::<seal_FractionalEncoder>(),
        16usize,
        concat!("Size of: ", stringify!(seal_FractionalEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_FractionalEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_FractionalEncoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_FractionalEncoder>())).encoder_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_FractionalEncoder),
            "::",
            stringify!(encoder_)
        )
    );
}
extern "C" {
    ///Creates a new FractionalEncoder object. The constructor takes as input a reference
    ///to the plaintext modulus, the degree of the polynomial modulus, and the numbers of
    ///coefficients that are reserved for the integral and fractional parts, and optionally
    ///an integer, at least 2, that is used as the base in the encoding. The coefficients
    ///for the integral part are counted starting from the low-degree end of the polynomial,
    ///and the coefficients for the fractional part are counted from the high-degree end.
    ///
    ///@param[in] plain_modulus The plaintext modulus (represented by SmallModulus)
    ///@param[in] poly_modulus_degree The degree of the polynomial modulus
    ///@param[in] integer_coeff_count The number of polynomial coefficients reserved for the integral part
    ///@param[in] fraction_coeff_count The number of polynomial coefficients reserved for the fractional part
    ///@param[in] base The base to be used for encoding (default value is 2)
    ///@throws std::invalid_argument if plain_modulus is not at least base
    ///@throws std::invalid_argument if integer_coeff_count is not strictly positive
    ///@throws std::invalid_argument if fraction_coeff_count is not strictly positive
    ///@throws std::invalid_argument if poly_modulus_degree is too small for the integral and fractional parts
    ///@throws std::invalid_argument if base is not an integer and at least 2
    #[link_name = "\u{1}_ZN4seal17FractionalEncoderC1ERKNS_12SmallModulusEmmmm"]
    pub fn seal_FractionalEncoder_FractionalEncoder(
        this: *mut seal_FractionalEncoder,
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        poly_modulus_degree: usize,
        integer_coeff_count: usize,
        fraction_coeff_count: usize,
        base: u64,
    );
}
extern "C" {
    ///Creates a copy of a FractionalEncoder.
    ///
    ///@param[in] copy The FractionalEncoder to copy from
    #[link_name = "\u{1}_ZN4seal17FractionalEncoderC1ERKS0_"]
    pub fn seal_FractionalEncoder_FractionalEncoder1(
        this: *mut seal_FractionalEncoder,
        copy: *const seal_FractionalEncoder,
    );
}
extern "C" {
    ///Creates a new FractionalEncoder by moving an old one.
    ///
    ///@param[in] source The FractionalEncoder to move from
    #[link_name = "\u{1}_ZN4seal17FractionalEncoderC1EOS0_"]
    pub fn seal_FractionalEncoder_FractionalEncoder2(
        this: *mut seal_FractionalEncoder,
        source: *mut seal_FractionalEncoder,
    );
}
impl Default for seal_FractionalEncoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_FractionalEncoder {
    #[inline]
    pub unsafe fn new(
        plain_modulus: *const seal_util_global_variables_internal_mods_SmallModulus,
        poly_modulus_degree: usize,
        integer_coeff_count: usize,
        fraction_coeff_count: usize,
        base: u64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_FractionalEncoder_FractionalEncoder(
            &mut __bindgen_tmp,
            plain_modulus,
            poly_modulus_degree,
            integer_coeff_count,
            fraction_coeff_count,
            base,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_FractionalEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_FractionalEncoder_FractionalEncoder1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_FractionalEncoder) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_FractionalEncoder_FractionalEncoder2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
extern "C" {
    ///Destroys the FractionalEncoder.
    #[link_name = "\u{1}_ZN4seal17FractionalEncoderD1Ev"]
    pub fn seal_FractionalEncoder_FractionalEncoder_destructor(this: *mut seal_FractionalEncoder);
}
extern "C" {
    ///Encodes a double precision floating point number into a plaintext polynomial.
    ///
    ///@param[in] value The double-precision floating-point number to encode
    #[link_name = "\u{1}_ZN4seal17FractionalEncoder6encodeEd"]
    pub fn seal_FractionalEncoder_encode(
        this: *mut ::std::os::raw::c_void,
        value: f64,
    ) -> seal_Plaintext;
}
extern "C" {
    ///Decodes a plaintext polynomial and returns the result as a double-precision
    ///floating-point number.
    ///
    ///@param[in] plain The plaintext to be decoded
    ///@throws std::invalid_argument if plain does not represent a valid plaintext polynomial
    ///@throws std::invalid_argument if the integral part does not fit in std::int64_t
    #[link_name = "\u{1}_ZN4seal17FractionalEncoder6decodeERKNS_9PlaintextE"]
    pub fn seal_FractionalEncoder_decode(
        this: *mut ::std::os::raw::c_void,
        plain: *const seal_Plaintext,
    ) -> f64;
}
extern "C" {
    ///Returns a reference to the plaintext modulus.
    #[link_name = "\u{1}_ZNK4seal17FractionalEncoder13plain_modulusEv"]
    pub fn seal_FractionalEncoder_plain_modulus(
        this: *mut ::std::os::raw::c_void,
    ) -> *const seal_util_global_variables_internal_mods_SmallModulus;
}
extern "C" {
    ///Returns the degree of the polynomial modulus.
    #[link_name = "\u{1}_ZNK4seal17FractionalEncoder19poly_modulus_degreeEv"]
    pub fn seal_FractionalEncoder_poly_modulus_degree(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    ///Returns the base used for encoding.
    #[link_name = "\u{1}_ZNK4seal17FractionalEncoder4baseEv"]
    pub fn seal_FractionalEncoder_base(this: *mut ::std::os::raw::c_void) -> u64;
}
extern "C" {
    ///Returns the number of coefficients reserved for the fractional part.
    #[link_name = "\u{1}_ZNK4seal17FractionalEncoder20fraction_coeff_countEv"]
    pub fn seal_FractionalEncoder_fraction_coeff_count(this: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    ///Returns the number of coefficients reserved for the integral part.
    #[link_name = "\u{1}_ZNK4seal17FractionalEncoder19integer_coeff_countEv"]
    pub fn seal_FractionalEncoder_integer_coeff_count(this: *mut ::std::os::raw::c_void) -> usize;
}
///Class to store a public key.
///
///@par Thread Safety
///In general, reading from PublicKey is thread-safe as long as no other thread
///is concurrently mutating it. This is due to the underlying data structure
///storing the public key not being thread-safe.
///
///@see KeyGenerator for the class that generates the public key.
///@see SecretKey for the class that stores the secret key.
///@see RelinKeys for the class that stores the relinearization keys.
///@see GaloisKeys for the class that stores the Galois keys.
#[repr(C)]
#[derive(Debug)]
pub struct seal_PublicKey {
    pub pk_: seal_Ciphertext,
}
#[test]
fn bindgen_test_layout_seal_PublicKey() {
    assert_eq!(
        ::std::mem::size_of::<seal_PublicKey>(),
        144usize,
        concat!("Size of: ", stringify!(seal_PublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_PublicKey>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_PublicKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_PublicKey>())).pk_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_PublicKey),
            "::",
            stringify!(pk_)
        )
    );
}
extern "C" {
    ///Returns a reference to the underlying data.
    #[link_name = "\u{1}_ZN4seal9PublicKey4dataEv"]
    pub fn seal_PublicKey_data(this: *mut seal_PublicKey) -> *mut seal_Ciphertext;
}
extern "C" {
    ///Returns a const reference to the underlying data.
    #[link_name = "\u{1}_ZNK4seal9PublicKey4dataEv"]
    pub fn seal_PublicKey_data1(this: *const seal_PublicKey) -> *mut seal_Ciphertext;
}
extern "C" {
    ///Check whether the current PublicKey is valid for a given SEALContext. If
    ///the given SEALContext is not set, the encryption parameters are invalid,
    ///or the PublicKey data does not match the SEALContext, this function returns
    ///false. Otherwise, returns true.
    ///
    ///@param[in] context The SEALContext
    #[link_name = "\u{1}_ZNK4seal9PublicKey12is_valid_forESt10shared_ptrINS_11SEALContextEE"]
    pub fn seal_PublicKey_is_valid_for(this: *const seal_PublicKey, context: [u64; 2usize])
        -> bool;
}
extern "C" {
    ///Saves the PublicKey to an output stream. The output is in binary format
    ///and not human-readable. The output stream must have the "binary" flag set.
    ///
    ///@param[in] stream The stream to save the PublicKey to
    ///@throws std::exception if the PublicKey could not be written to stream
    #[link_name = "\u{1}_ZNK4seal9PublicKey4saveERSo"]
    pub fn seal_PublicKey_save(this: *const seal_PublicKey, stream: *mut std_ostream);
}
extern "C" {
    ///Loads a PublicKey from an input stream overwriting the current PublicKey.
    ///No checking of the validity of the PublicKey data against encryption
    ///parameters is performed. This function should not be used unless the
    ///PublicKey comes from a fully trusted source.
    ///
    ///@param[in] stream The stream to load the PublicKey from
    ///@throws std::exception if a valid PublicKey could not be read from stream
    #[link_name = "\u{1}_ZN4seal9PublicKey11unsafe_loadERSi"]
    pub fn seal_PublicKey_unsafe_load(this: *mut seal_PublicKey, stream: *mut std_istream);
}
extern "C" {
    ///Loads a PublicKey from an input stream overwriting the current PublicKey.
    ///The loaded PublicKey is verified to be valid for the given SEALContext.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] stream The stream to load the PublicKey from
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::exception if a valid PublicKey could not be read from stream
    ///@throws std::invalid_argument if the loaded PublicKey is invalid for the
    ///context
    #[link_name = "\u{1}_ZN4seal9PublicKey4loadESt10shared_ptrINS_11SEALContextEERSi"]
    pub fn seal_PublicKey_load(
        this: *mut seal_PublicKey,
        context: [u64; 2usize],
        stream: *mut std_istream,
    );
}
extern "C" {
    ///Returns a reference to parms_id.
    #[link_name = "\u{1}_ZN4seal9PublicKey8parms_idEv"]
    pub fn seal_PublicKey_parms_id(this: *mut seal_PublicKey) -> *mut [u64; 4usize];
}
extern "C" {
    ///Returns a const reference to parms_id.
    #[link_name = "\u{1}_ZNK4seal9PublicKey8parms_idEv"]
    pub fn seal_PublicKey_parms_id1(this: *const seal_PublicKey) -> *mut [u64; 4usize];
}
extern "C" {
    ///Returns the currently used MemoryPoolHandle.
    #[link_name = "\u{1}_ZNK4seal9PublicKey4poolEv"]
    pub fn seal_PublicKey_pool(this: *const seal_PublicKey) -> seal_MemoryPoolHandle;
}
extern "C" {
    ///Creates an empty public key.
    #[link_name = "\u{1}_ZN4seal9PublicKeyC1Ev"]
    pub fn seal_PublicKey_PublicKey(this: *mut seal_PublicKey);
}
extern "C" {
    ///Creates a new PublicKey by copying an old one.
    ///
    ///@param[in] copy The PublicKey to copy from
    #[link_name = "\u{1}_ZN4seal9PublicKeyC1ERKS0_"]
    pub fn seal_PublicKey_PublicKey1(this: *mut seal_PublicKey, copy: *const seal_PublicKey);
}
extern "C" {
    ///Creates a new PublicKey by moving an old one.
    ///
    ///@param[in] source The PublicKey to move from
    #[link_name = "\u{1}_ZN4seal9PublicKeyC1EOS0_"]
    pub fn seal_PublicKey_PublicKey2(this: *mut seal_PublicKey, source: *mut seal_PublicKey);
}
impl Default for seal_PublicKey {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_PublicKey {
    #[inline]
    pub unsafe fn data(&mut self) -> *mut seal_Ciphertext {
        seal_PublicKey_data(self)
    }
    #[inline]
    pub unsafe fn data1(&self) -> *mut seal_Ciphertext {
        seal_PublicKey_data1(self)
    }
    #[inline]
    pub unsafe fn is_valid_for(&self, context: [u64; 2usize]) -> bool {
        seal_PublicKey_is_valid_for(self, context)
    }
    #[inline]
    pub unsafe fn save(&self, stream: *mut std_ostream) {
        seal_PublicKey_save(self, stream)
    }
    #[inline]
    pub unsafe fn unsafe_load(&mut self, stream: *mut std_istream) {
        seal_PublicKey_unsafe_load(self, stream)
    }
    #[inline]
    pub unsafe fn load(&mut self, context: [u64; 2usize], stream: *mut std_istream) {
        seal_PublicKey_load(self, context, stream)
    }
    #[inline]
    pub unsafe fn parms_id(&mut self) -> *mut [u64; 4usize] {
        seal_PublicKey_parms_id(self)
    }
    #[inline]
    pub unsafe fn parms_id1(&self) -> *mut [u64; 4usize] {
        seal_PublicKey_parms_id1(self)
    }
    #[inline]
    pub unsafe fn pool(&self) -> seal_MemoryPoolHandle {
        seal_PublicKey_pool(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_PublicKey_PublicKey(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_PublicKey) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_PublicKey_PublicKey1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_PublicKey) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_PublicKey_PublicKey2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
///Encrypts Plaintext objects into Ciphertext objects. Constructing an Encryptor
///requires a SEALContext with valid encryption parameters, and the public key.
///
///@par Overloads
///For the encrypt function we provide two overloads concerning the memory pool
///used in allocations needed during the operation. In one overload the global
///memory pool is used for this purpose, and in another overload the user can
///supply a MemoryPoolHandle to to be used instead. This is to allow one single
///Encryptor to be used concurrently by several threads without running into thread
///contention in allocations taking place during operations. For example, one can
///share one single Encryptor across any number of threads, but in each thread
///call the encrypt function by giving it a thread-local MemoryPoolHandle to use.
///It is important for a developer to understand how this works to avoid unnecessary
///performance bottlenecks.
///
///@par NTT form
///When using the BFV scheme (scheme_type::BFV), all plaintext and ciphertexts should
///remain by default in the usual coefficient representation, i.e. not in NTT form.
///When using the CKKS scheme (scheme_type::CKKS), all plaintexts and ciphertexts
///should remain by default in NTT form. We call these scheme-specific NTT states
///the "default NTT form". Decryption requires the input ciphertexts to be in
///the default NTT form, and will throw an exception if this is not the case.
#[repr(C)]
#[derive(Debug)]
pub struct seal_Encryptor {
    pub pool_: seal_MemoryPoolHandle,
    pub context_: [u64; 2usize],
    pub public_key_: seal_util_Pointer<u64>,
}
#[test]
fn bindgen_test_layout_seal_Encryptor() {
    assert_eq!(
        ::std::mem::size_of::<seal_Encryptor>(),
        64usize,
        concat!("Size of: ", stringify!(seal_Encryptor))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_Encryptor>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_Encryptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Encryptor>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Encryptor),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Encryptor>())).context_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Encryptor),
            "::",
            stringify!(context_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Encryptor>())).public_key_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Encryptor),
            "::",
            stringify!(public_key_)
        )
    );
}
extern "C" {
    ///Encrypts a Plaintext and stores the result in the destination parameter.
    ///Dynamic memory allocations in the process are allocated from the memory
    ///pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] plain The plaintext to encrypt
    ///@param[out] destination The ciphertext to overwrite with the encrypted plaintext
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if plain is not valid for the encryption parameters
    ///@throws std::invalid_argument if plain is not in default NTT form
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Encryptor7encryptERKNS_9PlaintextERNS_10CiphertextENS_16MemoryPoolHandleE"]
    pub fn seal_Encryptor_encrypt(
        this: *mut seal_Encryptor,
        plain: *const seal_Plaintext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Creates an Encryptor instance initialized with the specified SEALContext
    ///and public key.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] public_key The public key
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::invalid_argument if public_key is not valid
    #[link_name = "\u{1}_ZN4seal9EncryptorC1ESt10shared_ptrINS_11SEALContextEERKNS_9PublicKeyE"]
    pub fn seal_Encryptor_Encryptor(
        this: *mut seal_Encryptor,
        context: [u64; 2usize],
        public_key: *const seal_PublicKey,
    );
}
impl Default for seal_Encryptor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_Encryptor {
    #[inline]
    pub unsafe fn encrypt(
        &mut self,
        plain: *const seal_Plaintext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Encryptor_encrypt(self, plain, destination, pool)
    }
    #[inline]
    pub unsafe fn new(context: [u64; 2usize], public_key: *const seal_PublicKey) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Encryptor_Encryptor(&mut __bindgen_tmp, context, public_key);
        __bindgen_tmp
    }
}
///Class to store relinearization keys. An relinearization key has type
///std::vector<Ciphertext>.
///An instance of the RelinKeys class stores internally an std::vector of
///relinearization keys.
///
///@par Relinearization
///Concretely, an relinearization key corresponding to a power K of the secret
///key can be used in the relinearization operation to change a ciphertext of size
///K+1 to size K. Recall that the smallest possible size for a ciphertext is 2,
///so the first relinearization key is corresponds to the square of the secret
///key. The second relinearization key corresponds to the cube of the secret key,
///and so on. For example, to relinearize a ciphertext of size 7 back to size 2,
///one would need 5 relinearization keys, although it is hard to imagine a situation
///where it makes sense to have size 7 ciphertexts, as operating on such objects
///would be very slow. Most commonly only one relinearization key is needed, and
///relinearization is performed after every multiplication.
///
///@par Decomposition Bit Count
///Decomposition bit count (dbc) is a parameter that describes a performance
///trade-off in the relinearization process. Namely, in the relinearization process
///the polynomials in the ciphertexts (with large coefficients) get decomposed
///into a smaller base 2^dbc, coefficient-wise. Each of the decomposition factors
///corresponds to a piece of data in the relinearization key, so the smaller the
///dbc is, the larger the relinearization keys are. Moreover, a smaller dbc results
///in less invariant noise budget being consumed in the relinearization process.
///However, using a large dbc is much faster, and often one would want to optimize
///the dbc to be as large as possible for performance. The dbc is upper-bounded
///by the value of 60, and lower-bounded by the value of 1.
///
///@par Thread Safety
///In general, reading from RelinKeys is thread-safe as long as no other thread
///is concurrently mutating it. This is due to the underlying data structure
///storing the relinearization keys not being thread-safe.
///
///
///@see SecretKey for the class that stores the secret key.
///@see PublicKey for the class that stores the public key.
///@see GaloisKeys for the class that stores the Galois keys.
///@see KeyGenerator for the class that generates the relinearization keys.
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_RelinKeys {
    pub pool_: seal_MemoryPoolHandle,
    pub parms_id_: seal_parms_id_type,
    ///The vector of relinearization keys.
    pub keys_: [u64; 3usize],
    pub decomposition_bit_count_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_seal_RelinKeys() {
    assert_eq!(
        ::std::mem::size_of::<seal_RelinKeys>(),
        80usize,
        concat!("Size of: ", stringify!(seal_RelinKeys))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_RelinKeys>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_RelinKeys))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_RelinKeys>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_RelinKeys),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_RelinKeys>())).parms_id_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_RelinKeys),
            "::",
            stringify!(parms_id_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_RelinKeys>())).keys_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_RelinKeys),
            "::",
            stringify!(keys_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_RelinKeys>())).decomposition_bit_count_ as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_RelinKeys),
            "::",
            stringify!(decomposition_bit_count_)
        )
    );
}
extern "C" {
    ///Returns the current number of relinearization keys.
    #[link_name = "\u{1}_ZNK4seal9RelinKeys4sizeEv"]
    pub fn seal_RelinKeys_size(this: *const seal_RelinKeys) -> usize;
}
extern "C" {
    ///Returns the decomposition bit count.
    #[link_name = "\u{1}_ZNK4seal9RelinKeys23decomposition_bit_countEv"]
    pub fn seal_RelinKeys_decomposition_bit_count(
        this: *const seal_RelinKeys,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///Returns a reference to the relinearization keys data.
    #[link_name = "\u{1}_ZN4seal9RelinKeys4dataEv"]
    pub fn seal_RelinKeys_data(this: *mut seal_RelinKeys) -> *mut [u64; 3usize];
}
extern "C" {
    ///Returns a const reference to the relinearization keys data.
    #[link_name = "\u{1}_ZNK4seal9RelinKeys4dataEv"]
    pub fn seal_RelinKeys_data1(this: *const seal_RelinKeys) -> *mut [u64; 3usize];
}
extern "C" {
    ///Returns a const reference to an relinearization key. The returned
    ///relinearization key corresponds to the given power of the secret key.
    ///
    ///
    ///@param[in] key_power The power of the secret key
    ///@throw std::invalid_argument if the key corresponding to key_power does
    ///not exist
    #[link_name = "\u{1}_ZNK4seal9RelinKeys3keyEm"]
    pub fn seal_RelinKeys_key(this: *const seal_RelinKeys, key_power: usize) -> *mut [u64; 3usize];
}
extern "C" {
    ///Returns whether an relinearization key corresponding to a given power of
    ///the secret key exists.
    ///
    ///@param[in] key_power The power of the secret key
    #[link_name = "\u{1}_ZNK4seal9RelinKeys7has_keyEm"]
    pub fn seal_RelinKeys_has_key(this: *const seal_RelinKeys, key_power: usize) -> bool;
}
extern "C" {
    ///Returns a reference to parms_id.
    ///
    ///@see EncryptionParameters for more information about parms_id.
    #[link_name = "\u{1}_ZN4seal9RelinKeys8parms_idEv"]
    pub fn seal_RelinKeys_parms_id(this: *mut seal_RelinKeys) -> *mut [u64; 4usize];
}
extern "C" {
    ///Returns a const reference to parms_id.
    ///
    ///@see EncryptionParameters for more information about parms_id.
    #[link_name = "\u{1}_ZNK4seal9RelinKeys8parms_idEv"]
    pub fn seal_RelinKeys_parms_id1(this: *const seal_RelinKeys) -> *mut [u64; 4usize];
}
extern "C" {
    ///Check whether the current RelinKeys is valid for a given SEALContext. If
    ///the given SEALContext is not set, the encryption parameters are invalid,
    ///or the RelinKeys data does not match the SEALContext, this function returns
    ///false. Otherwise, returns true.
    ///
    ///@param[in] context The SEALContext
    #[link_name = "\u{1}_ZNK4seal9RelinKeys12is_valid_forESt10shared_ptrINS_11SEALContextEE"]
    pub fn seal_RelinKeys_is_valid_for(this: *const seal_RelinKeys, context: [u64; 2usize])
        -> bool;
}
extern "C" {
    ///Saves the RelinKeys instance to an output stream. The output is in binary
    ///format and not human-readable. The output stream must have the "binary"
    ///flag set.
    ///
    ///@param[in] stream The stream to save the RelinKeys to
    ///@throws std::exception if the RelinKeys could not be written to stream
    #[link_name = "\u{1}_ZNK4seal9RelinKeys4saveERSo"]
    pub fn seal_RelinKeys_save(this: *const seal_RelinKeys, stream: *mut std_ostream);
}
extern "C" {
    ///Loads a RelinKeys from an input stream overwriting the current RelinKeys.
    ///No checking of the validity of the RelinKeys data against encryption
    ///parameters is performed. This function should not be used unless the
    ///RelinKeys comes from a fully trusted source.
    ///
    ///@param[in] stream The stream to load the RelinKeys from
    ///@throws std::exception if a valid RelinKeys could not be read from stream
    #[link_name = "\u{1}_ZN4seal9RelinKeys11unsafe_loadERSi"]
    pub fn seal_RelinKeys_unsafe_load(this: *mut seal_RelinKeys, stream: *mut std_istream);
}
extern "C" {
    ///Loads a RelinKeys from an input stream overwriting the current RelinKeys.
    ///The loaded RelinKeys is verified to be valid for the given SEALContext.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] stream The stream to load the RelinKeys from
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::exception if a valid RelinKeys could not be read from stream
    ///@throws std::invalid_argument if the loaded RelinKeys is invalid for the
    ///context
    #[link_name = "\u{1}_ZN4seal9RelinKeys4loadESt10shared_ptrINS_11SEALContextEERSi"]
    pub fn seal_RelinKeys_load(
        this: *mut seal_RelinKeys,
        context: [u64; 2usize],
        stream: *mut std_istream,
    );
}
extern "C" {
    ///Returns the currently used MemoryPoolHandle.
    #[link_name = "\u{1}_ZNK4seal9RelinKeys4poolEv"]
    pub fn seal_RelinKeys_pool(this: *const seal_RelinKeys) -> seal_MemoryPoolHandle;
}
extern "C" {
    ///Creates an empty set of relinearization keys.
    #[link_name = "\u{1}_ZN4seal9RelinKeysC1Ev"]
    pub fn seal_RelinKeys_RelinKeys(this: *mut seal_RelinKeys);
}
extern "C" {
    ///Creates a new RelinKeys instance by copying a given instance.
    ///
    ///@param[in] copy The RelinKeys to copy from
    #[link_name = "\u{1}_ZN4seal9RelinKeysC1ERKS0_"]
    pub fn seal_RelinKeys_RelinKeys1(this: *mut seal_RelinKeys, copy: *const seal_RelinKeys);
}
extern "C" {
    ///Creates a new RelinKeys instance by moving a given instance.
    ///
    ///@param[in] source The RelinKeys to move from
    #[link_name = "\u{1}_ZN4seal9RelinKeysC1EOS0_"]
    pub fn seal_RelinKeys_RelinKeys2(this: *mut seal_RelinKeys, source: *mut seal_RelinKeys);
}
impl seal_RelinKeys {
    #[inline]
    pub unsafe fn size(&self) -> usize {
        seal_RelinKeys_size(self)
    }
    #[inline]
    pub unsafe fn decomposition_bit_count(&self) -> ::std::os::raw::c_int {
        seal_RelinKeys_decomposition_bit_count(self)
    }
    #[inline]
    pub unsafe fn data(&mut self) -> *mut [u64; 3usize] {
        seal_RelinKeys_data(self)
    }
    #[inline]
    pub unsafe fn data1(&self) -> *mut [u64; 3usize] {
        seal_RelinKeys_data1(self)
    }
    #[inline]
    pub unsafe fn key(&self, key_power: usize) -> *mut [u64; 3usize] {
        seal_RelinKeys_key(self, key_power)
    }
    #[inline]
    pub unsafe fn has_key(&self, key_power: usize) -> bool {
        seal_RelinKeys_has_key(self, key_power)
    }
    #[inline]
    pub unsafe fn parms_id(&mut self) -> *mut [u64; 4usize] {
        seal_RelinKeys_parms_id(self)
    }
    #[inline]
    pub unsafe fn parms_id1(&self) -> *mut [u64; 4usize] {
        seal_RelinKeys_parms_id1(self)
    }
    #[inline]
    pub unsafe fn is_valid_for(&self, context: [u64; 2usize]) -> bool {
        seal_RelinKeys_is_valid_for(self, context)
    }
    #[inline]
    pub unsafe fn save(&self, stream: *mut std_ostream) {
        seal_RelinKeys_save(self, stream)
    }
    #[inline]
    pub unsafe fn unsafe_load(&mut self, stream: *mut std_istream) {
        seal_RelinKeys_unsafe_load(self, stream)
    }
    #[inline]
    pub unsafe fn load(&mut self, context: [u64; 2usize], stream: *mut std_istream) {
        seal_RelinKeys_load(self, context, stream)
    }
    #[inline]
    pub unsafe fn pool(&self) -> seal_MemoryPoolHandle {
        seal_RelinKeys_pool(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_RelinKeys_RelinKeys(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_RelinKeys) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_RelinKeys_RelinKeys1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_RelinKeys) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_RelinKeys_RelinKeys2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
///Class to store Galois keys.
///
///@par Slot Rotations
///Galois keys are used together with batching (BatchEncoder). If the polynomial modulus
///is a polynomial of degree N, in batching the idea is to view a plaintext polynomial as
///a 2-by-(N/2) matrix of integers modulo plaintext modulus. Normal homomorphic computations
///operate on such encrypted matrices element (slot) wise. However, special rotation
///operations allow us to also rotate the matrix rows cyclically in either direction, and
///rotate the columns (swap the rows). These operations require the Galois keys.
///
///@par Decomposition Bit Count
///Decomposition bit count (dbc) is a parameter that describes a performance trade-off in
///the rotation operation. Its function is exactly the same as in relinearization. Namely,
///the polynomials in the ciphertexts (with large coefficients) get decomposed into a smaller
///base 2^dbc, coefficient-wise. Each of the decomposition factors corresponds to a piece of
///data in the Galois keys, so the smaller the dbc is, the larger the Galois keys are.
///Moreover, a smaller dbc results in less invariant noise budget being consumed in the
///rotation operation. However, using a large dbc is much faster, and often one would want
///to optimize the dbc to be as large as possible for performance. The dbc is upper-bounded
///by the value of 60, and lower-bounded by the value of 1.
///
///@par Thread Safety
///In general, reading from GaloisKeys is thread-safe as long as no other thread is
///concurrently mutating it. This is due to the underlying data structure storing the
///Galois keys not being thread-safe.
///
///@see SecretKey for the class that stores the secret key.
///@see PublicKey for the class that stores the public key.
///@see RelinKeys for the class that stores the relinearization keys.
///@see KeyGenerator for the class that generates the Galois keys.
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_GaloisKeys {
    pub pool_: seal_MemoryPoolHandle,
    pub parms_id_: seal_parms_id_type,
    ///The vector of Galois keys.
    pub keys_: [u64; 3usize],
    pub decomposition_bit_count_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_seal_GaloisKeys() {
    assert_eq!(
        ::std::mem::size_of::<seal_GaloisKeys>(),
        80usize,
        concat!("Size of: ", stringify!(seal_GaloisKeys))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_GaloisKeys>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_GaloisKeys))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_GaloisKeys>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_GaloisKeys),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_GaloisKeys>())).parms_id_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_GaloisKeys),
            "::",
            stringify!(parms_id_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_GaloisKeys>())).keys_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_GaloisKeys),
            "::",
            stringify!(keys_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_GaloisKeys>())).decomposition_bit_count_ as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_GaloisKeys),
            "::",
            stringify!(decomposition_bit_count_)
        )
    );
}
extern "C" {
    ///Returns the current number of Galois keys.
    #[link_name = "\u{1}_ZNK4seal10GaloisKeys4sizeEv"]
    pub fn seal_GaloisKeys_size(this: *const seal_GaloisKeys) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4seal10GaloisKeys23decomposition_bit_countEv"]
    pub fn seal_GaloisKeys_decomposition_bit_count(
        this: *const seal_GaloisKeys,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///Returns a reference to the Galois keys data.
    #[link_name = "\u{1}_ZN4seal10GaloisKeys4dataEv"]
    pub fn seal_GaloisKeys_data(this: *mut seal_GaloisKeys) -> *mut [u64; 3usize];
}
extern "C" {
    ///Returns a const reference to the Galois keys data.
    #[link_name = "\u{1}_ZNK4seal10GaloisKeys4dataEv"]
    pub fn seal_GaloisKeys_data1(this: *const seal_GaloisKeys) -> *mut [u64; 3usize];
}
extern "C" {
    ///Returns a const reference to a Galois key. The returned Galois key corresponds
    ///to the given Galois element.
    ///
    ///@param[in] galois_elt The Galois element
    ///@throw std::invalid_argument if the key corresponding to galois_elt does not exist
    #[link_name = "\u{1}_ZNK4seal10GaloisKeys3keyEm"]
    pub fn seal_GaloisKeys_key(this: *const seal_GaloisKeys, galois_elt: u64)
        -> *mut [u64; 3usize];
}
extern "C" {
    ///Returns whether a Galois key corresponding to a given Galois element exists.
    ///
    ///@param[in] galois_elt The Galois element
    ///@throw std::invalid_argument if Galois element is not valid
    #[link_name = "\u{1}_ZNK4seal10GaloisKeys7has_keyEm"]
    pub fn seal_GaloisKeys_has_key(this: *const seal_GaloisKeys, galois_elt: u64) -> bool;
}
extern "C" {
    ///Returns a reference to parms_id.
    ///
    ///@see EncryptionParameters for more information about parms_id.
    #[link_name = "\u{1}_ZN4seal10GaloisKeys8parms_idEv"]
    pub fn seal_GaloisKeys_parms_id(this: *mut seal_GaloisKeys) -> *mut [u64; 4usize];
}
extern "C" {
    ///Returns a const reference to parms_id.
    ///
    ///@see EncryptionParameters for more information about parms_id.
    #[link_name = "\u{1}_ZNK4seal10GaloisKeys8parms_idEv"]
    pub fn seal_GaloisKeys_parms_id1(this: *const seal_GaloisKeys) -> *mut [u64; 4usize];
}
extern "C" {
    ///Check whether the current GaloisKeys is valid for a given SEALContext. If
    ///the given SEALContext is not set, the encryption parameters are invalid,
    ///or the GaloisKeys data does not match the SEALContext, this function returns
    ///false. Otherwise, returns true.
    ///
    ///@param[in] context The SEALContext
    #[link_name = "\u{1}_ZNK4seal10GaloisKeys12is_valid_forESt10shared_ptrINS_11SEALContextEE"]
    pub fn seal_GaloisKeys_is_valid_for(
        this: *const seal_GaloisKeys,
        context: [u64; 2usize],
    ) -> bool;
}
extern "C" {
    ///Saves the GaloisKeys instance to an output stream. The output is in binary
    ///format and not human-readable. The output stream must have the "binary"
    ///flag set.
    ///
    ///@param[in] stream The stream to save the GaloisKeys to
    ///@throws std::exception if the GaloisKeys could not be written to stream
    #[link_name = "\u{1}_ZNK4seal10GaloisKeys4saveERSo"]
    pub fn seal_GaloisKeys_save(this: *const seal_GaloisKeys, stream: *mut std_ostream);
}
extern "C" {
    ///Loads a GaloisKeys from an input stream overwriting the current GaloisKeys.
    ///No checking of the validity of the GaloisKeys data against encryption
    ///parameters is performed. This function should not be used unless the
    ///GaloisKeys comes from a fully trusted source.
    ///
    ///@param[in] stream The stream to load the GaloisKeys from
    ///@throws std::exception if a valid GaloisKeys could not be read from stream
    #[link_name = "\u{1}_ZN4seal10GaloisKeys11unsafe_loadERSi"]
    pub fn seal_GaloisKeys_unsafe_load(this: *mut seal_GaloisKeys, stream: *mut std_istream);
}
extern "C" {
    ///Loads a GaloisKeys from an input stream overwriting the current GaloisKeys.
    ///The loaded GaloisKeys is verified to be valid for the given SEALContext.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] stream The stream to load the GaloisKeys from
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    ///@throws std::exception if a valid GaloisKeys could not be read from stream
    ///@throws std::invalid_argument if the loaded GaloisKeys is invalid for the
    ///context
    #[link_name = "\u{1}_ZN4seal10GaloisKeys4loadESt10shared_ptrINS_11SEALContextEERSi"]
    pub fn seal_GaloisKeys_load(
        this: *mut seal_GaloisKeys,
        context: [u64; 2usize],
        stream: *mut std_istream,
    );
}
extern "C" {
    ///Returns the currently used MemoryPoolHandle.
    #[link_name = "\u{1}_ZNK4seal10GaloisKeys4poolEv"]
    pub fn seal_GaloisKeys_pool(this: *const seal_GaloisKeys) -> seal_MemoryPoolHandle;
}
extern "C" {
    ///Creates an empty set of Galois keys.
    #[link_name = "\u{1}_ZN4seal10GaloisKeysC1Ev"]
    pub fn seal_GaloisKeys_GaloisKeys(this: *mut seal_GaloisKeys);
}
extern "C" {
    ///Creates a new GaloisKeys instance by copying a given instance.
    ///
    ///@param[in] copy The GaloisKeys to copy from
    #[link_name = "\u{1}_ZN4seal10GaloisKeysC1ERKS0_"]
    pub fn seal_GaloisKeys_GaloisKeys1(this: *mut seal_GaloisKeys, copy: *const seal_GaloisKeys);
}
extern "C" {
    ///Creates a new GaloisKeys instance by moving a given instance.
    ///
    ///@param[in] source The GaloisKeys to move from
    #[link_name = "\u{1}_ZN4seal10GaloisKeysC1EOS0_"]
    pub fn seal_GaloisKeys_GaloisKeys2(this: *mut seal_GaloisKeys, source: *mut seal_GaloisKeys);
}
impl seal_GaloisKeys {
    #[inline]
    pub unsafe fn size(&self) -> usize {
        seal_GaloisKeys_size(self)
    }
    #[inline]
    pub unsafe fn decomposition_bit_count(&self) -> ::std::os::raw::c_int {
        seal_GaloisKeys_decomposition_bit_count(self)
    }
    #[inline]
    pub unsafe fn data(&mut self) -> *mut [u64; 3usize] {
        seal_GaloisKeys_data(self)
    }
    #[inline]
    pub unsafe fn data1(&self) -> *mut [u64; 3usize] {
        seal_GaloisKeys_data1(self)
    }
    #[inline]
    pub unsafe fn key(&self, galois_elt: u64) -> *mut [u64; 3usize] {
        seal_GaloisKeys_key(self, galois_elt)
    }
    #[inline]
    pub unsafe fn has_key(&self, galois_elt: u64) -> bool {
        seal_GaloisKeys_has_key(self, galois_elt)
    }
    #[inline]
    pub unsafe fn parms_id(&mut self) -> *mut [u64; 4usize] {
        seal_GaloisKeys_parms_id(self)
    }
    #[inline]
    pub unsafe fn parms_id1(&self) -> *mut [u64; 4usize] {
        seal_GaloisKeys_parms_id1(self)
    }
    #[inline]
    pub unsafe fn is_valid_for(&self, context: [u64; 2usize]) -> bool {
        seal_GaloisKeys_is_valid_for(self, context)
    }
    #[inline]
    pub unsafe fn save(&self, stream: *mut std_ostream) {
        seal_GaloisKeys_save(self, stream)
    }
    #[inline]
    pub unsafe fn unsafe_load(&mut self, stream: *mut std_istream) {
        seal_GaloisKeys_unsafe_load(self, stream)
    }
    #[inline]
    pub unsafe fn load(&mut self, context: [u64; 2usize], stream: *mut std_istream) {
        seal_GaloisKeys_load(self, context, stream)
    }
    #[inline]
    pub unsafe fn pool(&self) -> seal_MemoryPoolHandle {
        seal_GaloisKeys_pool(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_GaloisKeys_GaloisKeys(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(copy: *const seal_GaloisKeys) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_GaloisKeys_GaloisKeys1(&mut __bindgen_tmp, copy);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(source: *mut seal_GaloisKeys) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_GaloisKeys_GaloisKeys2(&mut __bindgen_tmp, source);
        __bindgen_tmp
    }
}
///Provides operations on ciphertexts. Due to the properties of the encryption
///scheme, the arithmetic operations pass through the encryption layer to the
///underlying plaintext, changing it according to the type of the operation. Since
///the plaintext elements are fundamentally polynomials in the polynomial quotient
///ring Z_T[x]/(X^N+1), where T is the plaintext modulus and X^N+1 is the polynomial
///modulus, this is the ring where the arithmetic operations will take place.
///BatchEncoder (batching) provider an alternative possibly more convenient view
///of the plaintext elements as 2-by-(N2/2) matrices of integers modulo the plaintext
///modulus. In the batching view the arithmetic operations act on the matrices
///element-wise. Some of the operations only apply in the batching view, such as
///matrix row and column rotations. Other operations such as relinearization have
///no semantic meaning but are necessary for performance reasons.
///
///@par Arithmetic Operations
///The core operations are arithmetic operations, in particular multiplication
///and addition of ciphertexts. In addition to these, we also provide negation,
///subtraction, squaring, exponentiation, and multiplication and addition of
///several ciphertexts for convenience. in many cases some of the inputs to a
///computation are plaintext elements rather than ciphertexts. For this we
///provide fast "plain" operations: plain addition, plain subtraction, and plain
///multiplication.
///
///@par Relinearization
///One of the most important non-arithmetic operations is relinearization, which
///takes as input a ciphertext of size K+1 and relinearization keys (at least K-1
///keys are needed), and changes the size of the ciphertext down to 2 (minimum size).
///For most use-cases only one relinearization key suffices, in which case
///relinearization should be performed after every multiplication. Homomorphic
///multiplication of ciphertexts of size K+1 and L+1 outputs a ciphertext of size
///K+L+1, and the computational cost of multiplication is proportional to K*L.
///Plain multiplication and addition operations of any type do not change the
///size. The performance of relinearization is determined by the decomposition
///bit count that the relinearization keys were generated with.
///
///@par Rotations
///When batching is enabled, we provide operations for rotating the plaintext matrix
///rows cyclically left or right, and for rotating the columns (swapping the rows).
///Rotations require Galois keys to have been generated, and their performance
///depends on the decomposition bit count that the Galois keys were generated with.
///
///@par Other Operations
///We also provide operations for transforming ciphertexts to NTT form and back,
///and for transforming plaintext polynomials to NTT form. These can be used in
///a very fast plain multiplication variant, that assumes the inputs to be in NTT
///form. Since the NTT has to be done in any case in plain multiplication, this
///function can be used when e.g. one plaintext input is used in several plain
///multiplication, and transforming it several times would not make sense.
///
///@par NTT form
///When using the BFV scheme (scheme_type::BFV), all plaintexts and ciphertexts
///should remain by default in the usual coefficient representation, i.e. not
///in NTT form. When using the CKKS scheme (scheme_type::CKKS), all plaintexts
///and ciphertexts should remain by default in NTT form. We call these scheme-
///specific NTT states the "default NTT form". Some functions, such as add, work
///even if the inputs are not in the default state, but others, such as multiply,
///will throw an exception. The output of all evaluation functions will be in
///the same state as the input(s), with the exception of the transform_to_ntt
///and transform_from_ntt functions, which change the state. Ideally, unless these
///two functions are called, all other functions should "just work".
///
///@see EncryptionParameters for more details on encryption parameters.
///@see BatchEncoder for more details on batching
///@see RelinKeys for more details on relinearization keys.
///@see GaloisKeys for more details on Galois keys.
#[repr(C)]
#[derive(Debug, Default)]
pub struct seal_Evaluator {
    pub context_: [u64; 2usize],
    pub Zmstar_to_generator_: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_seal_Evaluator() {
    assert_eq!(
        ::std::mem::size_of::<seal_Evaluator>(),
        64usize,
        concat!("Size of: ", stringify!(seal_Evaluator))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_Evaluator>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_Evaluator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_Evaluator>())).context_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Evaluator),
            "::",
            stringify!(context_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_Evaluator>())).Zmstar_to_generator_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_Evaluator),
            "::",
            stringify!(Zmstar_to_generator_)
        )
    );
}
extern "C" {
    ///Negates a ciphertext.
    ///
    ///@param[in] encrypted The ciphertext to negate
    ///@throws std::invalid_argument if encrypted is not valid for the encryption
    ///parameters
    #[link_name = "\u{1}_ZN4seal9Evaluator14negate_inplaceERNS_10CiphertextE"]
    pub fn seal_Evaluator_negate_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
    );
}
extern "C" {
    ///Negates a ciphertext and stores the result in the destination parameter.
    ///
    ///@param[in] encrypted The ciphertext to negate
    ///@param[out] destination The ciphertext to overwrite with the negated result
    ///@throws std::invalid_argument if encrypted is not valid for the encryption
    ///parameters
    #[link_name = "\u{1}_ZN4seal9Evaluator6negateERKNS_10CiphertextERS1_"]
    pub fn seal_Evaluator_negate(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
    );
}
extern "C" {
    ///Adds two ciphertexts. This function adds together encrypted1 and encrypted2
    ///and stores the result in encrypted1.
    ///
    ///@param[in] encrypted1 The first ciphertext to add
    ///@param[in] encrypted2 The second ciphertext to add
    ///@throws std::invalid_argument if encrypted1 or encrypted2 is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if encrypted1 and encrypted2 are in different
    ///NTT forms
    ///@throws std::invalid_argument if encrypted1 and encrypted2 have different scale
    #[link_name = "\u{1}_ZN4seal9Evaluator11add_inplaceERNS_10CiphertextERKS1_"]
    pub fn seal_Evaluator_add_inplace(
        this: *mut seal_Evaluator,
        encrypted1: *mut seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
    );
}
extern "C" {
    ///Adds two ciphertexts. This function adds together encrypted1 and encrypted2
    ///and stores the result in the destination parameter.
    ///
    ///@param[in] encrypted1 The first ciphertext to add
    ///@param[in] encrypted2 The second ciphertext to add
    ///@param[out] destination The ciphertext to overwrite with the addition result
    ///@throws std::invalid_argument if encrypted1 or encrypted2 is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if encrypted1 and encrypted2 are in different
    ///NTT forms
    ///@throws std::invalid_argument if encrypted1 and encrypted2 have different scale
    #[link_name = "\u{1}_ZN4seal9Evaluator3addERKNS_10CiphertextES3_RS1_"]
    pub fn seal_Evaluator_add(
        this: *mut seal_Evaluator,
        encrypted1: *const seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
    );
}
extern "C" {
    ///Adds together a vector of ciphertexts and stores the result in the destination
    ///parameter.
    ///
    ///@param[in] encrypteds The ciphertexts to add
    ///@param[out] destination The ciphertext to overwrite with the addition result
    ///@throws std::invalid_argument if encrypteds is empty
    ///@throws std::invalid_argument if the encrypteds are not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if encrypteds are in different NTT forms
    ///@throws std::invalid_argument if encrypteds have different scale
    ///@throws std::invalid_argument if destination is one of encrypteds
    #[link_name = "\u{1}_ZN4seal9Evaluator8add_manyERKSt6vectorINS_10CiphertextESaIS2_EERS2_"]
    pub fn seal_Evaluator_add_many(
        this: *mut seal_Evaluator,
        encrypteds: *const [u64; 3usize],
        destination: *mut seal_Ciphertext,
    );
}
extern "C" {
    ///Subtracts two ciphertexts. This function computes the difference of encrypted1
    ///and encrypted2, and stores the result in encrypted1.
    ///
    ///@param[in] encrypted1 The ciphertext to subtract from
    ///@param[in] encrypted2 The ciphertext to subtract
    ///@throws std::invalid_argument if encrypted1 or encrypted2 is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted1 and encrypted2 are in different
    ///NTT forms
    ///@throws std::invalid_argument if encrypted1 and encrypted2 have different scale
    #[link_name = "\u{1}_ZN4seal9Evaluator11sub_inplaceERNS_10CiphertextERKS1_"]
    pub fn seal_Evaluator_sub_inplace(
        this: *mut seal_Evaluator,
        encrypted1: *mut seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
    );
}
extern "C" {
    ///Subtracts two ciphertexts. This function computes the difference of encrypted1
    ///and encrypted2 and stores the result in the destination parameter.
    ///
    ///@param[in] encrypted1 The ciphertext to subtract from
    ///@param[in] encrypted2 The ciphertext to subtract
    ///@param[out] destination The ciphertext to overwrite with the subtraction result
    ///@throws std::invalid_argument if encrypted1 or encrypted2 is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted1 and encrypted2 are in different
    ///NTT forms
    ///@throws std::invalid_argument if encrypted1 and encrypted2 have different scale
    #[link_name = "\u{1}_ZN4seal9Evaluator3subERKNS_10CiphertextES3_RS1_"]
    pub fn seal_Evaluator_sub(
        this: *mut seal_Evaluator,
        encrypted1: *const seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
    );
}
extern "C" {
    ///Multiplies two ciphertexts. This functions computes the product of encrypted1
    ///and encrypted2 and stores the result in encrypted1. Dynamic memory allocations
    ///in the process are allocated from the memory pool pointed to by the given
    ///MemoryPoolHandle.
    ///
    ///@param[in] encrypted1 The first ciphertext to multiply
    ///@param[in] encrypted2 The second ciphertext to multiply
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if encrypted1 or encrypted2 is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted1 or encrypted2 is not in the default
    ///NTT form
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the output scale
    ///is too large for the encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator16multiply_inplaceERNS_10CiphertextERKS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_multiply_inplace(
        this: *mut seal_Evaluator,
        encrypted1: *mut seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Multiplies two ciphertexts. This functions computes the product of encrypted1
    ///and encrypted2 and stores the result in the destination parameter. Dynamic
    ///memory allocations in the process are allocated from the memory pool pointed
    ///to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted1 The first ciphertext to multiply
    ///@param[in] encrypted2 The second ciphertext to multiply
    ///@param[out] destination The ciphertext to overwrite with the multiplication result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if encrypted1 or encrypted2 is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted1 or encrypted2 is not in the default
    ///NTT form
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the output scale
    ///is too large for the encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator8multiplyERKNS_10CiphertextES3_RS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_multiply(
        this: *mut seal_Evaluator,
        encrypted1: *const seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Squares a ciphertext. This functions computes the square of encrypted. Dynamic
    ///memory allocations in the process are allocated from the memory pool pointed
    ///to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to square
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if encrypted is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the output scale
    ///is too large for the encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator14square_inplaceERNS_10CiphertextENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_square_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Squares a ciphertext. This functions computes the square of encrypted and
    ///stores the result in the destination parameter. Dynamic memory allocations
    ///in the process are allocated from the memory pool pointed to by the given
    ///MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to square
    ///@param[out] destination The ciphertext to overwrite with the square
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if encrypted is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the output scale
    ///is too large for the encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator6squareERKNS_10CiphertextERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_square(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Relinearizes a ciphertext. This functions relinearizes encrypted, reducing
    ///its size down to 2. If the size of encrypted is K+1, the given relinearization
    ///keys need to have size at least K-1. Dynamic memory allocations in the
    ///process are allocated from the memory pool pointed to by the given
    ///MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to relinearize
    ///@param[in] relin_keys The relinearization keys
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if encrypted or relin_keys is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if relin_keys do not correspond to the top level
    ///parameters in the current context
    ///@throws std::invalid_argument if the size of relin_keys is too small
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator19relinearize_inplaceERNS_10CiphertextERKNS_9RelinKeysENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_relinearize_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        relin_keys: *const seal_RelinKeys,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Relinearizes a ciphertext. This functions relinearizes encrypted, reducing
    ///its size down to 2, and stores the result in the destination parameter.
    ///If the size of encrypted is K+1, the given relinearization keys need to
    ///have size at least K-1. Dynamic memory allocations in the process are allocated
    ///from the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to relinearize
    ///@param[in] relin_keys The relinearization keys
    ///@param[out] destination The ciphertext to overwrite with the relinearized result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if encrypted or relin_keys is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if relin_keys do not correspond to the top level
    ///parameters in the current context
    ///@throws std::invalid_argument if the size of relin_keys is too small
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator11relinearizeERKNS_10CiphertextERKNS_9RelinKeysERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_relinearize(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        relin_keys: *const seal_RelinKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Given a ciphertext encrypted modulo q_1...q_k, this function switches the
    ///modulus down to q_1...q_{k-1} and stores the result in the destination
    ///parameter. Dynamic memory allocations in the process are allocated from
    ///the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to be switched to a smaller modulus
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@param[out] destination The ciphertext to overwrite with the modulus switched result
    ///@throws std::invalid_argument if encrypted is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if encrypted is already at lowest level
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the scale is too
    ///large for the new encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator18mod_switch_to_nextERKNS_10CiphertextERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_mod_switch_to_next(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Given a ciphertext encrypted modulo q_1...q_k, this function switches the
    ///modulus down to q_1...q_{k-1}. Dynamic memory allocations in the process
    ///are allocated from the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to be switched to a smaller modulus
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if encrypted is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if encrypted is already at lowest level
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the scale is too
    ///large for the new encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator26mod_switch_to_next_inplaceERNS_10CiphertextENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_mod_switch_to_next_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Modulus switches an NTT transformed plaintext from modulo q_1...q_k down
    ///to modulo q_1...q_{k-1}.
    ///
    ///@param[in] plain The plaintext to be switched to a smaller modulus
    ///@throws std::invalid_argument if plain is not in NTT form
    ///@throws std::invalid_argument if plain is not valid for the encryption parameters
    ///@throws std::invalid_argument if plain is already at lowest level
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the scale is too
    ///large for the new encryption parameters
    #[link_name = "\u{1}_ZN4seal9Evaluator26mod_switch_to_next_inplaceERNS_9PlaintextE"]
    pub fn seal_Evaluator_mod_switch_to_next_inplace1(
        this: *mut seal_Evaluator,
        plain: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Modulus switches an NTT transformed plaintext from modulo q_1...q_k down
    ///to modulo q_1...q_{k-1} and stores the result in the destination parameter.
    ///
    ///@param[in] plain The plaintext to be switched to a smaller modulus
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@param[out] destination The plaintext to overwrite with the modulus switched result
    ///@throws std::invalid_argument if plain is not in NTT form
    ///@throws std::invalid_argument if plain is not valid for the encryption parameters
    ///@throws std::invalid_argument if plain is already at lowest level
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the scale is too
    ///large for the new encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator18mod_switch_to_nextERKNS_9PlaintextERS1_"]
    pub fn seal_Evaluator_mod_switch_to_next1(
        this: *mut seal_Evaluator,
        plain: *const seal_Plaintext,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Given a ciphertext encrypted modulo q_1...q_k, this function switches the
    ///modulus down until the parameters reach the given parms_id. Dynamic memory
    ///allocations in the process are allocated from the memory pool pointed to
    ///by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to be switched to a smaller modulus
    ///@param[in] parms_id The target parms_id
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if encrypted is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if parms_id is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is already at lower level in modulus chain
    ///than the parameters corresponding to parms_id
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the scale is too
    ///large for the new encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator21mod_switch_to_inplaceERNS_10CiphertextESt5arrayImLm4EENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_mod_switch_to_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        parms_id: seal_parms_id_type,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Given a ciphertext encrypted modulo q_1...q_k, this function switches the
    ///modulus down until the parameters reach the given parms_id and stores the
    ///result in the destination parameter. Dynamic memory allocations in the process
    ///are allocated from the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to be switched to a smaller modulus
    ///@param[in] parms_id The target parms_id
    ///@param[out] destination The ciphertext to overwrite with the modulus switched result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if encrypted is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if parms_id is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is already at lower level in modulus chain
    ///than the parameters corresponding to parms_id
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the scale is too
    ///large for the new encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator13mod_switch_toERKNS_10CiphertextESt5arrayImLm4EERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_mod_switch_to(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        parms_id: seal_parms_id_type,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Given an NTT transformed plaintext modulo q_1...q_k, this function switches
    ///the modulus down until the parameters reach the given parms_id.
    ///
    ///@param[in] plain The plaintext to be switched to a smaller modulus
    ///@param[in] parms_id The target parms_id
    ///@throws std::invalid_argument if plain is not in NTT form
    ///@throws std::invalid_argument if plain is not valid for the encryption parameters
    ///@throws std::invalid_argument if parms_id is not valid for the encryption parameters
    ///@throws std::invalid_argument if plain is already at lower level in modulus chain
    ///than the parameters corresponding to parms_id
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the scale is too
    ///large for the new encryption parameters
    #[link_name = "\u{1}_ZN4seal9Evaluator21mod_switch_to_inplaceERNS_9PlaintextESt5arrayImLm4EE"]
    pub fn seal_Evaluator_mod_switch_to_inplace1(
        this: *mut seal_Evaluator,
        plain: *mut seal_Plaintext,
        parms_id: seal_parms_id_type,
    );
}
extern "C" {
    ///Given an NTT transformed plaintext modulo q_1...q_k, this function switches
    ///the modulus down until the parameters reach the given parms_id and stores
    ///the result in the destination parameter.
    ///
    ///@param[in] plain The plaintext to be switched to a smaller modulus
    ///@param[in] parms_id The target parms_id
    ///@param[out] destination The plaintext to overwrite with the modulus switched result
    ///@throws std::invalid_argument if plain is not in NTT form
    ///@throws std::invalid_argument if plain is not valid for the encryption parameters
    ///@throws std::invalid_argument if parms_id is not valid for the encryption parameters
    ///@throws std::invalid_argument if plain is already at lower level in modulus chain
    ///than the parameters corresponding to parms_id
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the scale is too
    ///large for the new encryption parameters
    #[link_name = "\u{1}_ZN4seal9Evaluator13mod_switch_toERKNS_9PlaintextESt5arrayImLm4EERS1_"]
    pub fn seal_Evaluator_mod_switch_to1(
        this: *mut seal_Evaluator,
        plain: *const seal_Plaintext,
        parms_id: seal_parms_id_type,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Given a ciphertext encrypted modulo q_1...q_k, this function switches the
    ///modulus down to q_1...q_{k-1}, scales the message down accordingly, and
    ///stores the result in the destination parameter. Dynamic memory allocations
    ///in the process are allocated from the memory pool pointed to by the given
    ///MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to be switched to a smaller modulus
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@param[out] destination The ciphertext to overwrite with the modulus switched result
    ///@throws std::invalid_argument if the scheme is invalid for rescaling
    ///@throws std::invalid_argument if encrypted is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if encrypted is already at lowest level
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator15rescale_to_nextERKNS_10CiphertextERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_rescale_to_next(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Given a ciphertext encrypted modulo q_1...q_k, this function switches the
    ///modulus down to q_1...q_{k-1} and scales the message down accordingly. Dynamic
    ///memory allocations in the process are allocated from the memory pool pointed
    ///to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to be switched to a smaller modulus
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if the scheme is invalid for rescaling
    ///@throws std::invalid_argument if encrypted is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if encrypted is already at lowest level
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator23rescale_to_next_inplaceERNS_10CiphertextENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_rescale_to_next_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Given a ciphertext encrypted modulo q_1...q_k, this function switches the
    ///modulus down until the parameters reach the given parms_id and scales the
    ///message down accordingly. Dynamic memory allocations in the process are
    ///allocated from the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to be switched to a smaller modulus
    ///@param[in] parms_id The target parms_id
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if the scheme is invalid for rescaling
    ///@throws std::invalid_argument if encrypted is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if parms_id is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is already at lower level in modulus chain
    ///than the parameters corresponding to parms_id
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator18rescale_to_inplaceERNS_10CiphertextESt5arrayImLm4EENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_rescale_to_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        parms_id: seal_parms_id_type,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Given a ciphertext encrypted modulo q_1...q_k, this function switches the
    ///modulus down until the parameters reach the given parms_id, scales the message
    ///down accordingly, and stores the result in the destination parameter. Dynamic
    ///memory allocations in the process are allocated from the memory pool pointed
    ///to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to be switched to a smaller modulus
    ///@param[in] parms_id The target parms_id
    ///@param[out] destination The ciphertext to overwrite with the modulus switched result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if the scheme is invalid for rescaling
    ///@throws std::invalid_argument if encrypted is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if parms_id is not valid for the encryption parameters
    ///@throws std::invalid_argument if encrypted is already at lower level in modulus chain
    ///than the parameters corresponding to parms_id
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator10rescale_toERKNS_10CiphertextESt5arrayImLm4EERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_rescale_to(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        parms_id: seal_parms_id_type,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Multiplies several ciphertexts together. This function computes the product
    ///of several ciphertext given as an std::vector and stores the result in the
    ///destination parameter. The multiplication is done in a depth-optimal order,
    ///and relinearization is performed automatically after every multiplication
    ///in the process. In relinearization the given relinearization keys are used.
    ///Dynamic memory allocations in the process are allocated from the memory
    ///pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypteds The ciphertexts to multiply
    ///@param[in] relin_keys The relinearization keys
    ///@param[out] destination The ciphertext to overwrite with the multiplication result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::logic_error if scheme is not scheme_type::BFV
    ///@throws std::invalid_argument if encrypteds is empty
    ///@throws std::invalid_argument if the ciphertexts or relin_keys are not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if encrypteds are not in the default NTT form
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the output scale
    ///is too large for the encryption parameters
    ///@throws std::invalid_argument if the size of relin_keys is too small
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator13multiply_manyERSt6vectorINS_10CiphertextESaIS2_EERKNS_9RelinKeysERS2_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_multiply_many(
        this: *mut seal_Evaluator,
        encrypteds: *mut [u64; 3usize],
        relin_keys: *const seal_RelinKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Exponentiates a ciphertext. This functions raises encrypted to a power.
    ///Dynamic memory allocations in the process are allocated from the memory
    ///pool pointed to by the given MemoryPoolHandle. The exponentiation is done
    ///in a depth-optimal order, and relinearization is performed automatically
    ///after every multiplication in the process. In relinearization the given
    ///relinearization keys are used.
    ///
    ///@param[in] encrypted The ciphertext to exponentiate
    ///@param[in] exponent The power to raise the ciphertext to
    ///@param[in] relin_keys The relinearization keys
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::logic_error if scheme is not scheme_type::BFV
    ///@throws std::invalid_argument if encrypted or relin_keys is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the output scale
    ///is too large for the encryption parameters
    ///@throws std::invalid_argument if exponent is zero
    ///@throws std::invalid_argument if the size of relin_keys is too small
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator20exponentiate_inplaceERNS_10CiphertextEmRKNS_9RelinKeysENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_exponentiate_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        exponent: u64,
        relin_keys: *const seal_RelinKeys,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Exponentiates a ciphertext. This functions raises encrypted to a power and
    ///stores the result in the destination parameter. Dynamic memory allocations
    ///in the process are allocated from the memory pool pointed to by the given
    ///MemoryPoolHandle. The exponentiation is done in a depth-optimal order, and
    ///relinearization is performed automatically after every multiplication in
    ///the process. In relinearization the given relinearization keys are used.
    ///
    ///@param[in] encrypted The ciphertext to exponentiate
    ///@param[in] exponent The power to raise the ciphertext to
    ///@param[in] relin_keys The relinearization keys
    ///@param[out] destination The ciphertext to overwrite with the power
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::logic_error if scheme is not scheme_type::BFV
    ///@throws std::invalid_argument if encrypted or relin_keys is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the output scale
    ///is too large for the encryption parameters
    ///@throws std::invalid_argument if exponent is zero
    ///@throws std::invalid_argument if the size of relin_keys is too small
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator12exponentiateERKNS_10CiphertextEmRKNS_9RelinKeysERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_exponentiate(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        exponent: u64,
        relin_keys: *const seal_RelinKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Adds a ciphertext and a plaintext. This function adds a plaintext to
    ///a ciphertext. For the operation to be valid, the plaintext must have less
    ///than degree(poly_modulus) many non-zero coefficients, and each coefficient
    ///must be less than the plaintext modulus, i.e. the plaintext must be a valid
    ///plaintext under the current encryption parameters.
    ///
    ///@param[in] encrypted The ciphertext to add
    ///@param[in] plain The plaintext to add
    ///@throws std::invalid_argument if encrypted or plain is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted or plain is in NTT form
    #[link_name = "\u{1}_ZN4seal9Evaluator17add_plain_inplaceERNS_10CiphertextERKNS_9PlaintextE"]
    pub fn seal_Evaluator_add_plain_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        plain: *const seal_Plaintext,
    );
}
extern "C" {
    ///Adds a ciphertext and a plaintext. This function adds a plaintext to
    ///a ciphertext and stores the result in the destination parameter. For the
    ///operation to be valid, the plaintext must have less than degree(poly_modulus)
    ///many non-zero coefficients, and each coefficient must be less than the
    ///plaintext modulus, i.e. the plaintext must be a valid plaintext under the
    ///current encryption parameters.
    ///
    ///@param[in] encrypted The ciphertext to add
    ///@param[in] plain The plaintext to add
    ///@param[out] destination The ciphertext to overwrite with the addition result
    ///@throws std::invalid_argument if encrypted or plain is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted or plain is in NTT form
    #[link_name = "\u{1}_ZN4seal9Evaluator9add_plainERKNS_10CiphertextERKNS_9PlaintextERS1_"]
    pub fn seal_Evaluator_add_plain(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        plain: *const seal_Plaintext,
        destination: *mut seal_Ciphertext,
    );
}
extern "C" {
    ///Subtracts a plaintext from a ciphertext. This function subtracts a plaintext
    ///from a ciphertext. For the operation to be valid, the plaintext must have
    ///less than degree(poly_modulus) many non-zero coefficients, and each coefficient
    ///must be less than the plaintext modulus, i.e. the plaintext must be a valid
    ///plaintext under the current encryption parameters.
    ///
    ///@param[in] encrypted The ciphertext to subtract from
    ///@param[in] plain The plaintext to subtract
    ///@throws std::invalid_argument if encrypted or plain is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted or plain is in NTT form
    #[link_name = "\u{1}_ZN4seal9Evaluator17sub_plain_inplaceERNS_10CiphertextERKNS_9PlaintextE"]
    pub fn seal_Evaluator_sub_plain_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        plain: *const seal_Plaintext,
    );
}
extern "C" {
    ///Subtracts a plaintext from a ciphertext. This function subtracts a plaintext
    ///from a ciphertext and stores the result in the destination parameter. For
    ///the operation to be valid, the plaintext must have less than degree(poly_modulus)
    ///many non-zero coefficients, and each coefficient must be less than the plaintext
    ///modulus, i.e. the plaintext must be a valid plaintext under the current
    ///encryption parameters.
    ///
    ///@param[in] encrypted The ciphertext to subtract from
    ///@param[in] plain The plaintext to subtract
    ///@param[out] destination The ciphertext to overwrite with the subtraction result
    ///@throws std::invalid_argument if encrypted or plain is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if encrypted or plain is in NTT form
    #[link_name = "\u{1}_ZN4seal9Evaluator9sub_plainERKNS_10CiphertextERKNS_9PlaintextERS1_"]
    pub fn seal_Evaluator_sub_plain(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        plain: *const seal_Plaintext,
        destination: *mut seal_Ciphertext,
    );
}
extern "C" {
    ///Multiplies a ciphertext with a plaintext. This function multiplies a ciphertext
    ///with a plaintext. For the operation to be valid, the plaintext must have
    ///less than degree(poly_modulus) many non-zero coefficients, and each coefficient
    ///must be less than the plaintext modulus, i.e. the plaintext must be a valid
    ///plaintext under the current encryption parameters. Moreover, the plaintext
    ///cannot be identially 0. Dynamic memory allocations in the process are allocated
    ///from the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to multiply
    ///@param[in] plain The plaintext to multiply
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if the encrypted or plain is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if encrypted and plain are in different NTT forms
    ///@throws std::invalid_argument if plain is zero
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the output
    ///scale is too large for the encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator22multiply_plain_inplaceERNS_10CiphertextERKNS_9PlaintextENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_multiply_plain_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        plain: *const seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Multiplies a ciphertext with a plaintext. This function multiplies
    ///a ciphertext with a plaintext and stores the result in the destination
    ///parameter. For the operation to be valid, the plaintext must have less
    ///than degree (poly_modulus) many non-zero coefficients, and each coefficient
    ///must be less than the plaintext modulus, i.e. the plaintext must be a valid
    ///plaintext under the current encryption parameters. Moreover, the plaintext
    ///cannot be identially 0. Dynamic memory allocations in the process are allocated
    ///from the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to multiply
    ///@param[in] plain The plaintext to multiply
    ///@param[out] destination The ciphertext to overwrite with the multiplication result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if the encrypted or plain is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if encrypted and plain are in different NTT forms
    ///@throws std::invalid_argument if plain is zero
    ///@throws std::invalid_argument if, when using scheme_type::CKKS, the output
    ///scale is too large for the encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator14multiply_plainERKNS_10CiphertextERKNS_9PlaintextERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_multiply_plain(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        plain: *const seal_Plaintext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Transforms a plaintext to NTT domain. This functions applies the Number
    ///Theoretic Transform to a plaintext by first embedding integers modulo the
    ///plaintext modulus to integers modulo the coefficient modulus and then
    ///performing David Harvey's NTT on the resulting polynomial. The transformation
    ///is done with respect to encryption parameters corresponding to a given parms_id.
    ///For the operation to be valid, the plaintext must have degree less than
    ///poly_modulus_degree and each coefficient must be less than the plaintext
    ///modulus, i.e. the plaintext must be a valid plaintext under the current
    ///encryption parameters. Dynamic memory allocations in the process are allocated
    ///from the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] plain The plaintext to transform
    ///@param[in] parms_id The parms_id with respect to which the NTT is done
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if plain is already in NTT form
    ///@throws std::invalid_argument if plain or parms_id is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator24transform_to_ntt_inplaceERNS_9PlaintextESt5arrayImLm4EENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_transform_to_ntt_inplace(
        this: *mut seal_Evaluator,
        plain: *mut seal_Plaintext,
        parms_id: seal_parms_id_type,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Transforms a plaintext to NTT domain. This functions applies the Number
    ///Theoretic Transform to a plaintext by first embedding integers modulo the
    ///plaintext modulus to integers modulo the coefficient modulus and then
    ///performing David Harvey's NTT on the resulting polynomial. The transformation
    ///is done with respect to encryption parameters corresponding to a given
    ///parms_id. The result is stored in the destination_ntt parameter. For the
    ///operation to be valid, the plaintext must have degree less than poly_modulus_degree
    ///and each coefficient must be less than the plaintext modulus, i.e. the plaintext
    ///must be a valid plaintext under the current encryption parameters. Dynamic
    ///memory allocations in the process are allocated from the memory pool pointed
    ///to by the given MemoryPoolHandle.
    ///
    ///@param[in] plain The plaintext to transform
    ///@param[in] parms_id The parms_id with respect to which the NTT is done
    ///@param[out] destinationNTT The plaintext to overwrite with the transformed result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if plain is already in NTT form
    ///@throws std::invalid_argument if plain or parms_id is not valid for the
    ///encryption parameters
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator16transform_to_nttERKNS_9PlaintextESt5arrayImLm4EERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_transform_to_ntt(
        this: *mut seal_Evaluator,
        plain: *const seal_Plaintext,
        parms_id: seal_parms_id_type,
        destination_ntt: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Transforms a ciphertext to NTT domain. This functions applies David Harvey's
    ///Number Theoretic Transform separately to each polynomial of a ciphertext.
    ///
    ///@param[in] encrypted The ciphertext to transform
    ///@throws std::invalid_argument if encrypted is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if encrypted is already in NTT form
    #[link_name = "\u{1}_ZN4seal9Evaluator24transform_to_ntt_inplaceERNS_10CiphertextE"]
    pub fn seal_Evaluator_transform_to_ntt_inplace1(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
    );
}
extern "C" {
    ///Transforms a ciphertext to NTT domain. This functions applies David Harvey's
    ///Number Theoretic Transform separately to each polynomial of a ciphertext.
    ///The result is stored in the destination_ntt parameter.
    ///
    ///@param[in] encrypted The ciphertext to transform
    ///@param[out] destination_ntt The ciphertext to overwrite with the transformed result
    ///@throws std::invalid_argument if encrypted is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if encrypted is already in NTT form
    #[link_name = "\u{1}_ZN4seal9Evaluator16transform_to_nttERKNS_10CiphertextERS1_"]
    pub fn seal_Evaluator_transform_to_ntt1(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        destination_ntt: *mut seal_Ciphertext,
    );
}
extern "C" {
    ///Transforms a ciphertext back from NTT domain. This functions applies the
    ///inverse of David Harvey's Number Theoretic Transform separately to each
    ///polynomial of a ciphertext.
    ///
    ///@param[in] encrypted_ntt The ciphertext to transform
    ///@throws std::invalid_argument if encrypted_ntt is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if encrypted_ntt is not in NTT form
    #[link_name = "\u{1}_ZN4seal9Evaluator26transform_from_ntt_inplaceERNS_10CiphertextE"]
    pub fn seal_Evaluator_transform_from_ntt_inplace(
        this: *mut seal_Evaluator,
        encrypted_ntt: *mut seal_Ciphertext,
    );
}
extern "C" {
    ///Transforms a ciphertext back from NTT domain. This functions applies the
    ///inverse of David Harvey's Number Theoretic Transform separately to each
    ///polynomial of a ciphertext. The result is stored in the destination parameter.
    ///
    ///@param[in] encrypted_ntt The ciphertext to transform
    ///@param[out] destination The ciphertext to overwrite with the transformed result
    ///@throws std::invalid_argument if encrypted_ntt is not valid for the encryption
    ///parameters
    ///@throws std::invalid_argument if encrypted_ntt is not in NTT form
    #[link_name = "\u{1}_ZN4seal9Evaluator18transform_from_nttERKNS_10CiphertextERS1_"]
    pub fn seal_Evaluator_transform_from_ntt(
        this: *mut seal_Evaluator,
        encrypted_ntt: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
    );
}
extern "C" {
    ///Applies a Galois automorphism to a ciphertext. To evaluate the Galois
    ///automorphism, an appropriate set of Galois keys must also be provided.
    ///Dynamic memory allocations in the process are allocated from the memory
    ///pool pointed to by the given MemoryPoolHandle.
    ///
    ///
    ///The desired Galois automorphism is given as a Galois element, and must be
    ///an odd integer in the interval [1, M-1], where M = 2*N, and N = degree(poly_modulus).
    ///Used with batching, a Galois element 3^i % M corresponds to a cyclic row
    ///rotation i steps to the left, and a Galois element 3^(N/2-i) % M corresponds
    ///to a cyclic row rotation i steps to the right. The Galois element M-1 corresponds
    ///to a column rotation (row swap) in BFV, and complex conjugation in CKKS.
    ///In the polynomial view (not batching), a Galois automorphism by a Galois
    ///element p changes Enc(plain(x)) to Enc(plain(x^p)).
    ///
    ///@param[in] encrypted The ciphertext to apply the Galois automorphism to
    ///@param[in] galois_elt The Galois element
    ///@param[in] galois_keys The Galois keys
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if encrypted or galois_keys is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if galois_keys do not correspond to the top
    ///level parameters in the current context
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if the Galois element is not valid
    ///@throws std::invalid_argument if necessary Galois keys are not present
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator20apply_galois_inplaceERNS_10CiphertextEmRKNS_10GaloisKeysENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_apply_galois_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        galois_elt: u64,
        galois_keys: *const seal_GaloisKeys,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Applies a Galois automorphism to a ciphertext and writes the result to the
    ///destination parameter. To evaluate the Galois automorphism, an appropriate
    ///set of Galois keys must also be provided. Dynamic memory allocations in
    ///the process are allocated from the memory pool pointed to by the given
    ///MemoryPoolHandle.
    ///
    ///The desired Galois automorphism is given as a Galois element, and must be
    ///an odd integer in the interval [1, M-1], where M = 2*N, and N = degree(poly_modulus).
    ///Used with batching, a Galois element 3^i % M corresponds to a cyclic row
    ///rotation i steps to the left, and a Galois element 3^(N/2-i) % M corresponds
    ///to a cyclic row rotation i steps to the right. The Galois element M-1 corresponds
    ///to a column rotation (row swap) in BFV, and complex conjugation in CKKS.
    ///In the polynomial view (not batching), a Galois automorphism by a Galois
    ///element p changes Enc(plain(x)) to Enc(plain(x^p)).
    ///
    ///@param[in] encrypted The ciphertext to apply the Galois automorphism to
    ///@param[in] galois_elt The Galois element
    ///@param[in] galois_keys The Galois keys
    ///@param[out] destination The ciphertext to overwrite with the result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if encrypted or galois_keys is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if galois_keys do not correspond to the top
    ///level parameters in the current context
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if the Galois element is not valid
    ///@throws std::invalid_argument if necessary Galois keys are not present
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator12apply_galoisERKNS_10CiphertextEmRKNS_10GaloisKeysERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_apply_galois(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        galois_elt: u64,
        galois_keys: *const seal_GaloisKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Rotates plaintext matrix rows cyclically. When batching is used with the
    ///BFV scheme, this function rotates the encrypted plaintext matrix rows
    ///cyclically to the left (steps > 0) or to the right (steps < 0). Since
    ///the size of the batched matrix is 2-by-(N/2), where N is the degree of
    ///the polynomial modulus, the number of steps to rotate must have absolute
    ///value at most N/2-1. Dynamic memory allocations in the process are allocated
    ///from the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///
    ///@param[in] encrypted The ciphertext to rotate
    ///@param[in] steps The number of steps to rotate (negative left, positive right)
    ///@param[in] galois_keys The Galois keys
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::logic_error if scheme is not scheme_type::BFV
    ///@throws std::logic_error if the encryption parameters do not support batching
    ///@throws std::invalid_argument if encrypted or galois_keys is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if galois_keys do not correspond to the top
    ///level parameters in the current context
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if steps has too big absolute value
    ///@throws std::invalid_argument if necessary Galois keys are not present
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator19rotate_rows_inplaceERNS_10CiphertextEiRKNS_10GaloisKeysENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_rotate_rows_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        steps: ::std::os::raw::c_int,
        galois_keys: *const seal_GaloisKeys,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Rotates plaintext matrix rows cyclically. When batching is used with the
    ///BFV scheme, this function rotates the encrypted plaintext matrix rows
    ///cyclically to the left (steps > 0) or to the right (steps < 0) and writes
    ///the result to the destination parameter. Since the size of the batched
    ///matrix is 2-by-(N/2), where N is the degree of the polynomial modulus,
    ///the number of steps to rotate must have absolute value at most N/2-1. Dynamic
    ///memory allocations in the process are allocated from the memory pool pointed
    ///to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to rotate
    ///@param[in] steps The number of steps to rotate (negative left, positive right)
    ///@param[in] galois_keys The Galois keys
    ///@param[out] destination The ciphertext to overwrite with the rotated result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::logic_error if scheme is not scheme_type::BFV
    ///@throws std::logic_error if the encryption parameters do not support batching
    ///@throws std::invalid_argument if encrypted or galois_keys is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if galois_keys do not correspond to the top
    ///level parameters in the current context
    ///@throws std::invalid_argument if encrypted is in NTT form
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if steps has too big absolute value
    ///@throws std::invalid_argument if necessary Galois keys are not present
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator11rotate_rowsERKNS_10CiphertextEiRKNS_10GaloisKeysERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_rotate_rows(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        steps: ::std::os::raw::c_int,
        galois_keys: *const seal_GaloisKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Rotates plaintext matrix columns cyclically. When batching is used with
    ///the BFV scheme, this function rotates the encrypted plaintext matrix
    ///columns cyclically. Since the size of the batched matrix is 2-by-(N/2),
    ///where N is the degree of the polynomial modulus, this means simply swapping
    ///the two rows. Dynamic memory allocations in the process are allocated from
    ///the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///
    ///@param[in] encrypted The ciphertext to rotate
    ///@param[in] galois_keys The Galois keys
    ///@param[out] destination The ciphertext to overwrite with the rotated result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::logic_error if scheme is not scheme_type::BFV
    ///@throws std::logic_error if the encryption parameters do not support batching
    ///@throws std::invalid_argument if encrypted or galois_keys is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if galois_keys do not correspond to the top
    ///level parameters in the current context
    ///@throws std::invalid_argument if encrypted is in NTT form
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if necessary Galois keys are not present
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator22rotate_columns_inplaceERNS_10CiphertextERKNS_10GaloisKeysENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_rotate_columns_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        galois_keys: *const seal_GaloisKeys,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Rotates plaintext matrix columns cyclically. When batching is used with
    ///the BFV scheme, this function rotates the encrypted plaintext matrix columns
    ///cyclically, and writes the result to the destination parameter. Since the
    ///size of the batched matrix is 2-by-(N/2), where N is the degree of the
    ///polynomial modulus, this means simply swapping the two rows. Dynamic memory
    ///allocations in the process are allocated from the memory pool pointed to
    ///by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to rotate
    ///@param[in] galois_keys The Galois keys
    ///@param[out] destination The ciphertext to overwrite with the rotated result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::logic_error if scheme is not scheme_type::BFV
    ///@throws std::logic_error if the encryption parameters do not support batching
    ///@throws std::invalid_argument if encrypted or galois_keys is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if galois_keys do not correspond to the top
    ///level parameters in the current context
    ///@throws std::invalid_argument if encrypted is in NTT form
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if necessary Galois keys are not present
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator14rotate_columnsERKNS_10CiphertextERKNS_10GaloisKeysERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_rotate_columns(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        galois_keys: *const seal_GaloisKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Rotates plaintext vector cyclically. When using the CKKS scheme, this function
    ///rotates the encrypted plaintext vector cyclically to the left (steps > 0)
    ///or to the right (steps < 0). Since the size of the batched matrix is
    ///2-by-(N/2), where N is the degree of the polynomial modulus, the number
    ///of steps to rotate must have absolute value at most N/2-1. Dynamic memory
    ///allocations in the process are allocated from the memory pool pointed to
    ///by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to rotate
    ///@param[in] steps The number of steps to rotate (negative left, positive right)
    ///@param[in] galois_keys The Galois keys
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::logic_error if scheme is not scheme_type::CKKS
    ///@throws std::invalid_argument if encrypted or galois_keys is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if galois_keys do not correspond to the top
    ///level parameters in the current context
    ///@throws std::invalid_argument if encrypted is not in the default NTT form
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if steps has too big absolute value
    ///@throws std::invalid_argument if necessary Galois keys are not present
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator21rotate_vector_inplaceERNS_10CiphertextEiRKNS_10GaloisKeysENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_rotate_vector_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        steps: ::std::os::raw::c_int,
        galois_keys: *const seal_GaloisKeys,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Rotates plaintext vector cyclically. When using the CKKS scheme, this function
    ///rotates the encrypted plaintext vector cyclically to the left (steps > 0)
    ///or to the right (steps < 0) and writes the result to the destination parameter.
    ///Since the size of the batched matrix is 2-by-(N/2), where N is the degree
    ///of the polynomial modulus, the number of steps to rotate must have absolute
    ///value at most N/2-1. Dynamic memory allocations in the process are allocated
    ///from the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to rotate
    ///@param[in] steps The number of steps to rotate (negative left, positive right)
    ///@param[in] galois_keys The Galois keys
    ///@param[out] destination The ciphertext to overwrite with the rotated result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::logic_error if scheme is not scheme_type::CKKS
    ///@throws std::invalid_argument if encrypted or galois_keys is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if galois_keys do not correspond to the top
    ///level parameters in the current context
    ///@throws std::invalid_argument if encrypted is in NTT form
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if steps has too big absolute value
    ///@throws std::invalid_argument if necessary Galois keys are not present
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator13rotate_vectorERKNS_10CiphertextEiRKNS_10GaloisKeysERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_rotate_vector(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        steps: ::std::os::raw::c_int,
        galois_keys: *const seal_GaloisKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Complex conjugates plaintext slot values. When using the CKKS scheme, this
    ///function complex conjugates all values in the underlying plaintext. Dynamic
    ///memory allocations in the process are allocated from the memory pool pointed
    ///to by the given MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to rotate
    ///@param[in] galois_keys The Galois keys
    ///@param[out] destination The ciphertext to overwrite with the rotated result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::logic_error if scheme is not scheme_type::CKKS
    ///@throws std::invalid_argument if encrypted or galois_keys is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if galois_keys do not correspond to the top
    ///level parameters in the current context
    ///@throws std::invalid_argument if encrypted is in NTT form
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if necessary Galois keys are not present
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator25complex_conjugate_inplaceERNS_10CiphertextERKNS_10GaloisKeysENS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_complex_conjugate_inplace(
        this: *mut seal_Evaluator,
        encrypted: *mut seal_Ciphertext,
        galois_keys: *const seal_GaloisKeys,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Complex conjugates plaintext slot values. When using the CKKS scheme, this
    ///function complex conjugates all values in the underlying plaintext, and
    ///writes the result to the destination parameter. Dynamic memory allocations
    ///in the process are allocated from the memory pool pointed to by the given
    ///MemoryPoolHandle.
    ///
    ///@param[in] encrypted The ciphertext to rotate
    ///@param[in] galois_keys The Galois keys
    ///@param[out] destination The ciphertext to overwrite with the rotated result
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::logic_error if scheme is not scheme_type::CKKS
    ///@throws std::invalid_argument if encrypted or galois_keys is not valid for
    ///the encryption parameters
    ///@throws std::invalid_argument if galois_keys do not correspond to the top
    ///level parameters in the current context
    ///@throws std::invalid_argument if encrypted is in NTT form
    ///@throws std::invalid_argument if encrypted has size larger than 2
    ///@throws std::invalid_argument if necessary Galois keys are not present
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal9Evaluator17complex_conjugateERKNS_10CiphertextERKNS_10GaloisKeysERS1_NS_16MemoryPoolHandleE"]
    pub fn seal_Evaluator_complex_conjugate(
        this: *mut seal_Evaluator,
        encrypted: *const seal_Ciphertext,
        galois_keys: *const seal_GaloisKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Creates an Evaluator instance initialized with the specified SEALContext.
    ///
    ///@param[in] context The SEALContext
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    #[link_name = "\u{1}_ZN4seal9EvaluatorC1ESt10shared_ptrINS_11SEALContextEE"]
    pub fn seal_Evaluator_Evaluator(this: *mut seal_Evaluator, context: [u64; 2usize]);
}
impl seal_Evaluator {
    #[inline]
    pub unsafe fn negate_inplace(&mut self, encrypted: *mut seal_Ciphertext) {
        seal_Evaluator_negate_inplace(self, encrypted)
    }
    #[inline]
    pub unsafe fn negate(
        &mut self,
        encrypted: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
    ) {
        seal_Evaluator_negate(self, encrypted, destination)
    }
    #[inline]
    pub unsafe fn add_inplace(
        &mut self,
        encrypted1: *mut seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
    ) {
        seal_Evaluator_add_inplace(self, encrypted1, encrypted2)
    }
    #[inline]
    pub unsafe fn add(
        &mut self,
        encrypted1: *const seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
    ) {
        seal_Evaluator_add(self, encrypted1, encrypted2, destination)
    }
    #[inline]
    pub unsafe fn add_many(
        &mut self,
        encrypteds: *const [u64; 3usize],
        destination: *mut seal_Ciphertext,
    ) {
        seal_Evaluator_add_many(self, encrypteds, destination)
    }
    #[inline]
    pub unsafe fn sub_inplace(
        &mut self,
        encrypted1: *mut seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
    ) {
        seal_Evaluator_sub_inplace(self, encrypted1, encrypted2)
    }
    #[inline]
    pub unsafe fn sub(
        &mut self,
        encrypted1: *const seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
    ) {
        seal_Evaluator_sub(self, encrypted1, encrypted2, destination)
    }
    #[inline]
    pub unsafe fn multiply_inplace(
        &mut self,
        encrypted1: *mut seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_multiply_inplace(self, encrypted1, encrypted2, pool)
    }
    #[inline]
    pub unsafe fn multiply(
        &mut self,
        encrypted1: *const seal_Ciphertext,
        encrypted2: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_multiply(self, encrypted1, encrypted2, destination, pool)
    }
    #[inline]
    pub unsafe fn square_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_square_inplace(self, encrypted, pool)
    }
    #[inline]
    pub unsafe fn square(
        &mut self,
        encrypted: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_square(self, encrypted, destination, pool)
    }
    #[inline]
    pub unsafe fn relinearize_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        relin_keys: *const seal_RelinKeys,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_relinearize_inplace(self, encrypted, relin_keys, pool)
    }
    #[inline]
    pub unsafe fn relinearize(
        &mut self,
        encrypted: *const seal_Ciphertext,
        relin_keys: *const seal_RelinKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_relinearize(self, encrypted, relin_keys, destination, pool)
    }
    #[inline]
    pub unsafe fn mod_switch_to_next(
        &mut self,
        encrypted: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_mod_switch_to_next(self, encrypted, destination, pool)
    }
    #[inline]
    pub unsafe fn mod_switch_to_next_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_mod_switch_to_next_inplace(self, encrypted, pool)
    }
    #[inline]
    pub unsafe fn mod_switch_to_next_inplace1(&mut self, plain: *mut seal_Plaintext) {
        seal_Evaluator_mod_switch_to_next_inplace1(self, plain)
    }
    #[inline]
    pub unsafe fn mod_switch_to_next1(
        &mut self,
        plain: *const seal_Plaintext,
        destination: *mut seal_Plaintext,
    ) {
        seal_Evaluator_mod_switch_to_next1(self, plain, destination)
    }
    #[inline]
    pub unsafe fn mod_switch_to_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        parms_id: seal_parms_id_type,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_mod_switch_to_inplace(self, encrypted, parms_id, pool)
    }
    #[inline]
    pub unsafe fn mod_switch_to(
        &mut self,
        encrypted: *const seal_Ciphertext,
        parms_id: seal_parms_id_type,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_mod_switch_to(self, encrypted, parms_id, destination, pool)
    }
    #[inline]
    pub unsafe fn mod_switch_to_inplace1(
        &mut self,
        plain: *mut seal_Plaintext,
        parms_id: seal_parms_id_type,
    ) {
        seal_Evaluator_mod_switch_to_inplace1(self, plain, parms_id)
    }
    #[inline]
    pub unsafe fn mod_switch_to1(
        &mut self,
        plain: *const seal_Plaintext,
        parms_id: seal_parms_id_type,
        destination: *mut seal_Plaintext,
    ) {
        seal_Evaluator_mod_switch_to1(self, plain, parms_id, destination)
    }
    #[inline]
    pub unsafe fn rescale_to_next(
        &mut self,
        encrypted: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_rescale_to_next(self, encrypted, destination, pool)
    }
    #[inline]
    pub unsafe fn rescale_to_next_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_rescale_to_next_inplace(self, encrypted, pool)
    }
    #[inline]
    pub unsafe fn rescale_to_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        parms_id: seal_parms_id_type,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_rescale_to_inplace(self, encrypted, parms_id, pool)
    }
    #[inline]
    pub unsafe fn rescale_to(
        &mut self,
        encrypted: *const seal_Ciphertext,
        parms_id: seal_parms_id_type,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_rescale_to(self, encrypted, parms_id, destination, pool)
    }
    #[inline]
    pub unsafe fn multiply_many(
        &mut self,
        encrypteds: *mut [u64; 3usize],
        relin_keys: *const seal_RelinKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_multiply_many(self, encrypteds, relin_keys, destination, pool)
    }
    #[inline]
    pub unsafe fn exponentiate_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        exponent: u64,
        relin_keys: *const seal_RelinKeys,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_exponentiate_inplace(self, encrypted, exponent, relin_keys, pool)
    }
    #[inline]
    pub unsafe fn exponentiate(
        &mut self,
        encrypted: *const seal_Ciphertext,
        exponent: u64,
        relin_keys: *const seal_RelinKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_exponentiate(self, encrypted, exponent, relin_keys, destination, pool)
    }
    #[inline]
    pub unsafe fn add_plain_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        plain: *const seal_Plaintext,
    ) {
        seal_Evaluator_add_plain_inplace(self, encrypted, plain)
    }
    #[inline]
    pub unsafe fn add_plain(
        &mut self,
        encrypted: *const seal_Ciphertext,
        plain: *const seal_Plaintext,
        destination: *mut seal_Ciphertext,
    ) {
        seal_Evaluator_add_plain(self, encrypted, plain, destination)
    }
    #[inline]
    pub unsafe fn sub_plain_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        plain: *const seal_Plaintext,
    ) {
        seal_Evaluator_sub_plain_inplace(self, encrypted, plain)
    }
    #[inline]
    pub unsafe fn sub_plain(
        &mut self,
        encrypted: *const seal_Ciphertext,
        plain: *const seal_Plaintext,
        destination: *mut seal_Ciphertext,
    ) {
        seal_Evaluator_sub_plain(self, encrypted, plain, destination)
    }
    #[inline]
    pub unsafe fn multiply_plain_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        plain: *const seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_multiply_plain_inplace(self, encrypted, plain, pool)
    }
    #[inline]
    pub unsafe fn multiply_plain(
        &mut self,
        encrypted: *const seal_Ciphertext,
        plain: *const seal_Plaintext,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_multiply_plain(self, encrypted, plain, destination, pool)
    }
    #[inline]
    pub unsafe fn transform_to_ntt_inplace(
        &mut self,
        plain: *mut seal_Plaintext,
        parms_id: seal_parms_id_type,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_transform_to_ntt_inplace(self, plain, parms_id, pool)
    }
    #[inline]
    pub unsafe fn transform_to_ntt(
        &mut self,
        plain: *const seal_Plaintext,
        parms_id: seal_parms_id_type,
        destination_ntt: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_transform_to_ntt(self, plain, parms_id, destination_ntt, pool)
    }
    #[inline]
    pub unsafe fn transform_to_ntt_inplace1(&mut self, encrypted: *mut seal_Ciphertext) {
        seal_Evaluator_transform_to_ntt_inplace1(self, encrypted)
    }
    #[inline]
    pub unsafe fn transform_to_ntt1(
        &mut self,
        encrypted: *const seal_Ciphertext,
        destination_ntt: *mut seal_Ciphertext,
    ) {
        seal_Evaluator_transform_to_ntt1(self, encrypted, destination_ntt)
    }
    #[inline]
    pub unsafe fn transform_from_ntt_inplace(&mut self, encrypted_ntt: *mut seal_Ciphertext) {
        seal_Evaluator_transform_from_ntt_inplace(self, encrypted_ntt)
    }
    #[inline]
    pub unsafe fn transform_from_ntt(
        &mut self,
        encrypted_ntt: *const seal_Ciphertext,
        destination: *mut seal_Ciphertext,
    ) {
        seal_Evaluator_transform_from_ntt(self, encrypted_ntt, destination)
    }
    #[inline]
    pub unsafe fn apply_galois_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        galois_elt: u64,
        galois_keys: *const seal_GaloisKeys,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_apply_galois_inplace(self, encrypted, galois_elt, galois_keys, pool)
    }
    #[inline]
    pub unsafe fn apply_galois(
        &mut self,
        encrypted: *const seal_Ciphertext,
        galois_elt: u64,
        galois_keys: *const seal_GaloisKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_apply_galois(self, encrypted, galois_elt, galois_keys, destination, pool)
    }
    #[inline]
    pub unsafe fn rotate_rows_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        steps: ::std::os::raw::c_int,
        galois_keys: *const seal_GaloisKeys,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_rotate_rows_inplace(self, encrypted, steps, galois_keys, pool)
    }
    #[inline]
    pub unsafe fn rotate_rows(
        &mut self,
        encrypted: *const seal_Ciphertext,
        steps: ::std::os::raw::c_int,
        galois_keys: *const seal_GaloisKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_rotate_rows(self, encrypted, steps, galois_keys, destination, pool)
    }
    #[inline]
    pub unsafe fn rotate_columns_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        galois_keys: *const seal_GaloisKeys,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_rotate_columns_inplace(self, encrypted, galois_keys, pool)
    }
    #[inline]
    pub unsafe fn rotate_columns(
        &mut self,
        encrypted: *const seal_Ciphertext,
        galois_keys: *const seal_GaloisKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_rotate_columns(self, encrypted, galois_keys, destination, pool)
    }
    #[inline]
    pub unsafe fn rotate_vector_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        steps: ::std::os::raw::c_int,
        galois_keys: *const seal_GaloisKeys,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_rotate_vector_inplace(self, encrypted, steps, galois_keys, pool)
    }
    #[inline]
    pub unsafe fn rotate_vector(
        &mut self,
        encrypted: *const seal_Ciphertext,
        steps: ::std::os::raw::c_int,
        galois_keys: *const seal_GaloisKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_rotate_vector(self, encrypted, steps, galois_keys, destination, pool)
    }
    #[inline]
    pub unsafe fn complex_conjugate_inplace(
        &mut self,
        encrypted: *mut seal_Ciphertext,
        galois_keys: *const seal_GaloisKeys,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_complex_conjugate_inplace(self, encrypted, galois_keys, pool)
    }
    #[inline]
    pub unsafe fn complex_conjugate(
        &mut self,
        encrypted: *const seal_Ciphertext,
        galois_keys: *const seal_GaloisKeys,
        destination: *mut seal_Ciphertext,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_Evaluator_complex_conjugate(self, encrypted, galois_keys, destination, pool)
    }
    #[inline]
    pub unsafe fn new(context: [u64; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_Evaluator_Evaluator(&mut __bindgen_tmp, context);
        __bindgen_tmp
    }
}
///Generates matching secret key and public key. An existing KeyGenerator can
///also at any time be used to generate relinearization keys and Galois keys.
///Constructing a KeyGenerator requires only a SEALContext.
///
///@see EncryptionParameters for more details on encryption parameters.
///@see SecretKey for more details on secret key.
///@see PublicKey for more details on public key.
///@see RelinKeys for more details on relinearization keys.
///@see GaloisKeys for more details on Galois keys.
#[repr(C)]
#[derive(Debug)]
pub struct seal_KeyGenerator {
    ///We use a fresh memory pool with `clear_on_destruction' enabled
    pub pool_: seal_MemoryPoolHandle,
    pub context_: [u64; 2usize],
    pub public_key_: seal_PublicKey,
    pub secret_key_: seal_SecretKey,
    pub secret_key_array_size_: usize,
    pub secret_key_array_: seal_util_Pointer<u64>,
    pub secret_key_array_locker_: seal_util_ReaderWriterLocker,
    pub sk_generated_: bool,
    pub pk_generated_: bool,
}
#[test]
fn bindgen_test_layout_seal_KeyGenerator() {
    assert_eq!(
        ::std::mem::size_of::<seal_KeyGenerator>(),
        384usize,
        concat!("Size of: ", stringify!(seal_KeyGenerator))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_KeyGenerator>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_KeyGenerator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_KeyGenerator>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_KeyGenerator),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_KeyGenerator>())).context_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_KeyGenerator),
            "::",
            stringify!(context_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_KeyGenerator>())).public_key_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_KeyGenerator),
            "::",
            stringify!(public_key_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_KeyGenerator>())).secret_key_ as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_KeyGenerator),
            "::",
            stringify!(secret_key_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_KeyGenerator>())).secret_key_array_size_ as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_KeyGenerator),
            "::",
            stringify!(secret_key_array_size_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_KeyGenerator>())).secret_key_array_ as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_KeyGenerator),
            "::",
            stringify!(secret_key_array_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_KeyGenerator>())).secret_key_array_locker_ as *const _
                as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_KeyGenerator),
            "::",
            stringify!(secret_key_array_locker_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_KeyGenerator>())).sk_generated_ as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_KeyGenerator),
            "::",
            stringify!(sk_generated_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_KeyGenerator>())).pk_generated_ as *const _ as usize },
        377usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_KeyGenerator),
            "::",
            stringify!(pk_generated_)
        )
    );
}
extern "C" {
    ///Returns a const reference to the secret key.
    #[link_name = "\u{1}_ZNK4seal12KeyGenerator10secret_keyEv"]
    pub fn seal_KeyGenerator_secret_key(this: *const seal_KeyGenerator) -> *const seal_SecretKey;
}
extern "C" {
    ///Returns a const reference to the public key.
    #[link_name = "\u{1}_ZNK4seal12KeyGenerator10public_keyEv"]
    pub fn seal_KeyGenerator_public_key(this: *const seal_KeyGenerator) -> *const seal_PublicKey;
}
extern "C" {
    ///Generates and returns the specified number of relinearization keys.
    ///
    ///@param[in] decomposition_bit_count The decomposition bit count
    ///@param[in] count The number of relinearization keys to generate
    ///@throws std::invalid_argument if decomposition_bit_count is not within [1, 60]
    ///@throws std::invalid_argument if count is zero or too large
    #[link_name = "\u{1}_ZN4seal12KeyGenerator10relin_keysEim"]
    pub fn seal_KeyGenerator_relin_keys(
        this: *mut seal_KeyGenerator,
        decomposition_bit_count: ::std::os::raw::c_int,
        count: usize,
    ) -> seal_RelinKeys;
}
extern "C" {
    ///Generates and returns Galois keys. This function creates specific Galois
    ///keys that can be used to apply specific Galois automorphisms on encrypted
    ///data. The user needs to give as input a vector of Galois elements
    ///corresponding to the keys that are to be created.
    ///
    ///The Galois elements are odd integers in the interval [1, M-1], where
    ///M = 2*N, and N = degree(poly_modulus). Used with batching, a Galois element
    ///3^i % M corresponds to a cyclic row rotation i steps to the left, and
    ///a Galois element 3^(N/2-i) % M corresponds to a cyclic row rotation i
    ///steps to the right. The Galois element M-1 corresponds to a column rotation
    ///(row swap) in BFV, and complex conjugation in CKKS. In the polynomial view
    ///(not batching), a Galois automorphism by a Galois element p changes Enc(plain(x))
    ///to Enc(plain(x^p)).
    ///
    ///@param[in] decomposition_bit_count The decomposition bit count
    ///@param[in] galois_elts The Galois elements for which to generate keys
    ///@throws std::invalid_argument if decomposition_bit_count is not within [1, 60]
    ///@throws std::invalid_argument if the Galois elements are not valid
    #[link_name = "\u{1}_ZN4seal12KeyGenerator11galois_keysEiRKSt6vectorImSaImEE"]
    pub fn seal_KeyGenerator_galois_keys(
        this: *mut seal_KeyGenerator,
        decomposition_bit_count: ::std::os::raw::c_int,
        galois_elts: *const u8,
    ) -> seal_GaloisKeys;
}
extern "C" {
    ///Generates and returns Galois keys. This function creates specific Galois
    ///keys that can be used to apply specific Galois automorphisms on encrypted
    ///data. The user needs to give as input a vector of desired Galois rotation
    ///step counts, where negative step counts correspond to rotations to the
    ///right and positive step counts correspond to rotations to the left.
    ///A step count of zero can be used to indicate a column rotation in the BFV
    ///scheme complex conjugation in the CKKS scheme.
    ///
    ///@param[in] decomposition_bit_count The decomposition bit count
    ///@param[in] galois_elts The rotation step counts for which to generate keys
    ///@throws std::logic_error if the encryption parameters do not support batching
    ///and scheme is scheme_type::BFV
    ///@throws std::invalid_argument if decomposition_bit_count is not within [1, 60]
    ///@throws std::invalid_argument if the step counts are not valid
    #[link_name = "\u{1}_ZN4seal12KeyGenerator11galois_keysEiRKSt6vectorIiSaIiEE"]
    pub fn seal_KeyGenerator_galois_keys1(
        this: *mut seal_KeyGenerator,
        decomposition_bit_count: ::std::os::raw::c_int,
        steps: *const u8,
    ) -> seal_GaloisKeys;
}
extern "C" {
    ///Generates and returns Galois keys. This function creates logarithmically
    ///many (in degree of the polynomial modulus) Galois keys that is sufficient
    ///to apply any Galois automorphism (e.g. rotations) on encrypted data. Most
    ///users will want to use this overload of the function.
    ///
    ///@param[in] decomposition_bit_count The decomposition bit count
    ///@throws std::invalid_argument if decomposition_bit_count is not within [1, 60]
    #[link_name = "\u{1}_ZN4seal12KeyGenerator11galois_keysEi"]
    pub fn seal_KeyGenerator_galois_keys2(
        this: *mut seal_KeyGenerator,
        decomposition_bit_count: ::std::os::raw::c_int,
    ) -> seal_GaloisKeys;
}
extern "C" {
    ///Creates a KeyGenerator initialized with the specified SEALContext.
    ///
    ///@param[in] context The SEALContext
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid
    #[link_name = "\u{1}_ZN4seal12KeyGeneratorC1ESt10shared_ptrINS_11SEALContextEE"]
    pub fn seal_KeyGenerator_KeyGenerator(this: *mut seal_KeyGenerator, context: [u64; 2usize]);
}
extern "C" {
    ///Creates an KeyGenerator instance initialized with the specified SEALContext
    ///and specified previously secret key. This can e.g. be used to increase
    ///the number of relinearization keys from what had earlier been generated,
    ///or to generate Galois keys in case they had not been generated earlier.
    ///
    ///
    ///@param[in] context The SEALContext
    ///@param[in] secret_key A previously generated secret key
    ///@throws std::invalid_argument if encryption parameters are not valid
    ///@throws std::invalid_argument if secret_key or public_key is not valid
    ///for encryption parameters
    #[link_name = "\u{1}_ZN4seal12KeyGeneratorC1ESt10shared_ptrINS_11SEALContextEERKNS_9SecretKeyE"]
    pub fn seal_KeyGenerator_KeyGenerator1(
        this: *mut seal_KeyGenerator,
        context: [u64; 2usize],
        secret_key: *const seal_SecretKey,
    );
}
extern "C" {
    ///Creates an KeyGenerator instance initialized with the specified SEALContext
    ///and specified previously secret and public keys. This can e.g. be used
    ///to increase the number of relinearization keys from what had earlier been
    ///generated, or to generate Galois keys in case they had not been generated
    ///earlier.
    ///
    ///@param[in] context The SEALContext
    ///@param[in] secret_key A previously generated secret key
    ///@param[in] public_key A previously generated public key
    ///@throws std::invalid_argument if encryption parameters are not valid
    ///@throws std::invalid_argument if secret_key or public_key is not valid
    ///for encryption parameters
    #[link_name = "\u{1}_ZN4seal12KeyGeneratorC1ESt10shared_ptrINS_11SEALContextEERKNS_9SecretKeyERKNS_9PublicKeyE"]
    pub fn seal_KeyGenerator_KeyGenerator2(
        this: *mut seal_KeyGenerator,
        context: [u64; 2usize],
        secret_key: *const seal_SecretKey,
        public_key: *const seal_PublicKey,
    );
}
impl Default for seal_KeyGenerator {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_KeyGenerator {
    #[inline]
    pub unsafe fn secret_key(&self) -> *const seal_SecretKey {
        seal_KeyGenerator_secret_key(self)
    }
    #[inline]
    pub unsafe fn public_key(&self) -> *const seal_PublicKey {
        seal_KeyGenerator_public_key(self)
    }
    #[inline]
    pub unsafe fn relin_keys(
        &mut self,
        decomposition_bit_count: ::std::os::raw::c_int,
        count: usize,
    ) -> seal_RelinKeys {
        seal_KeyGenerator_relin_keys(self, decomposition_bit_count, count)
    }
    #[inline]
    pub unsafe fn galois_keys(
        &mut self,
        decomposition_bit_count: ::std::os::raw::c_int,
        galois_elts: *const u8,
    ) -> seal_GaloisKeys {
        seal_KeyGenerator_galois_keys(self, decomposition_bit_count, galois_elts)
    }
    #[inline]
    pub unsafe fn galois_keys1(
        &mut self,
        decomposition_bit_count: ::std::os::raw::c_int,
        steps: *const u8,
    ) -> seal_GaloisKeys {
        seal_KeyGenerator_galois_keys1(self, decomposition_bit_count, steps)
    }
    #[inline]
    pub unsafe fn galois_keys2(
        &mut self,
        decomposition_bit_count: ::std::os::raw::c_int,
    ) -> seal_GaloisKeys {
        seal_KeyGenerator_galois_keys2(self, decomposition_bit_count)
    }
    #[inline]
    pub unsafe fn new(context: [u64; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_KeyGenerator_KeyGenerator(&mut __bindgen_tmp, context);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(context: [u64; 2usize], secret_key: *const seal_SecretKey) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_KeyGenerator_KeyGenerator1(&mut __bindgen_tmp, context, secret_key);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(
        context: [u64; 2usize],
        secret_key: *const seal_SecretKey,
        public_key: *const seal_PublicKey,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_KeyGenerator_KeyGenerator2(&mut __bindgen_tmp, context, secret_key, public_key);
        __bindgen_tmp
    }
}
///Provides functionality for CRT batching. If the polynomial modulus degree is N, and
///the plaintext modulus is a prime number T such that T is congruent to 1 modulo 2N,
///then BatchEncoder allows the SEAL plaintext elements to be viewed as 2-by-(N/2)
///matrices of integers modulo T. Homomorphic operations performed on such encrypted
///matrices are applied coefficient (slot) wise, enabling powerful SIMD functionality
///for computations that are vectorizable. This functionality is often called "batching"
///in the homomorphic encryption literature.
///
///@par Mathematical Background
///Mathematically speaking, if the polynomial modulus is X^N+1, N is a power of two, and
///plain_modulus is a prime number T such that 2N divides T-1, then integers modulo T
///contain a primitive 2N-th root of unity and the polynomial X^N+1 splits into n distinct
///linear factors as X^N+1 = (X-a_1)*...*(X-a_N) mod T, where the constants a_1, ..., a_n
///are all the distinct primitive 2N-th roots of unity in integers modulo T. The Chinese
///Remainder Theorem (CRT) states that the plaintext space Z_T[X]/(X^N+1) in this case is
///isomorphic (as an algebra) to the N-fold direct product of fields Z_T. The isomorphism
///is easy to compute explicitly in both directions, which is what this class does.
///Furthermore, the Galois group of the extension is (Z/2NZ)* ~= Z/2Z x Z/(N/2) whose
///action on the primitive roots of unity is easy to describe. Since the batching slots
///correspond 1-to-1 to the primitive roots of unity, applying Galois automorphisms on the
///plaintext act by permuting the slots. By applying generators of the two cyclic
///subgroups of the Galois group, we can effectively view the plaintext as a 2-by-(N/2)
///matrix, and enable cyclic row rotations, and column rotations (row swaps).
///
///@par Valid Parameters
///Whether batching can be used depends on whether the plaintext modulus has been chosen
///appropriately. Thus, to construct a BatchEncoder the user must provide an instance
///of SEALContext such that its associated EncryptionParameterQualifiers object has the
///flags parameters_set and enable_batching set to true.
///
///@see EncryptionParameters for more information about encryption parameters.
///@see EncryptionParameterQualifiers for more information about parameter qualifiers.
///@see Evaluator for rotating rows and columns of encrypted matrices.
#[repr(C)]
#[derive(Debug)]
pub struct seal_BatchEncoder {
    pub pool_: seal_MemoryPoolHandle,
    pub context_: [u64; 2usize],
    pub slots_: usize,
    pub roots_of_unity_: seal_util_Pointer<u64>,
    pub matrix_reps_index_map_: seal_util_Pointer<u64>,
}
#[test]
fn bindgen_test_layout_seal_BatchEncoder() {
    assert_eq!(
        ::std::mem::size_of::<seal_BatchEncoder>(),
        104usize,
        concat!("Size of: ", stringify!(seal_BatchEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<seal_BatchEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(seal_BatchEncoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_BatchEncoder>())).pool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BatchEncoder),
            "::",
            stringify!(pool_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_BatchEncoder>())).context_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BatchEncoder),
            "::",
            stringify!(context_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seal_BatchEncoder>())).slots_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BatchEncoder),
            "::",
            stringify!(slots_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BatchEncoder>())).roots_of_unity_ as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BatchEncoder),
            "::",
            stringify!(roots_of_unity_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seal_BatchEncoder>())).matrix_reps_index_map_ as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seal_BatchEncoder),
            "::",
            stringify!(matrix_reps_index_map_)
        )
    );
}
extern "C" {
    ///Creates a SEAL plaintext from a given matrix. This function "batches" a given matrix
    ///of integers modulo the plaintext modulus into a SEAL plaintext element, and stores
    ///the result in the destination parameter. The input vector must have size at most equal
    ///to the degree of the polynomial modulus. The first half of the elements represent the
    ///first row of the matrix, and the second half represent the second row. The numbers
    ///in the matrix can be at most equal to the plaintext modulus for it to represent
    ///a valid SEAL plaintext.
    ///
    ///If the destination plaintext overlaps the input values in memory, the behavior of
    ///this function is undefined.
    ///
    ///@param[in] values The matrix of integers modulo plaintext modulus to batch
    ///@param[out] destination The plaintext polynomial to overwrite with the result
    ///@throws std::invalid_argument if values is too large
    #[link_name = "\u{1}_ZN4seal12BatchEncoder6encodeERKSt6vectorImSaImEERNS_9PlaintextE"]
    pub fn seal_BatchEncoder_encode(
        this: *mut seal_BatchEncoder,
        values: *const u8,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Creates a SEAL plaintext from a given matrix. This function "batches" a given matrix
    ///of integers modulo the plaintext modulus into a SEAL plaintext element, and stores
    ///the result in the destination parameter. The input vector must have size at most equal
    ///to the degree of the polynomial modulus. The first half of the elements represent the
    ///first row of the matrix, and the second half represent the second row. The numbers
    ///in the matrix can be at most equal to the plaintext modulus for it to represent
    ///a valid SEAL plaintext.
    ///
    ///If the destination plaintext overlaps the input values in memory, the behavior of
    ///this function is undefined.
    ///
    ///@param[in] values The matrix of integers modulo plaintext modulus to batch
    ///@param[out] destination The plaintext polynomial to overwrite with the result
    ///@throws std::invalid_argument if values is too large
    #[link_name = "\u{1}_ZN4seal12BatchEncoder6encodeERKSt6vectorIlSaIlEERNS_9PlaintextE"]
    pub fn seal_BatchEncoder_encode1(
        this: *mut seal_BatchEncoder,
        values: *const u8,
        destination: *mut seal_Plaintext,
    );
}
extern "C" {
    ///Creates a SEAL plaintext from a given matrix. This function "batches" a given matrix
    ///of integers modulo the plaintext modulus in-place into a SEAL plaintext ready to be
    ///encrypted. The matrix is given as a plaintext element whose first N/2 coefficients
    ///represent the first row of the matrix, and the second N/2 coefficients represent the
    ///second row, where N denotes the degree of the polynomial modulus. The input plaintext
    ///must have degress less than the polynomial modulus, and coefficients less than the
    ///plaintext modulus, i.e. it must be a valid plaintext for the encryption parameters.
    ///Dynamic memory allocations in the process are allocated from the memory pool pointed
    ///to by the given MemoryPoolHandle.
    ///
    ///@param[in] plain The matrix of integers modulo plaintext modulus to batch
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if plain is not valid for the encryption parameters
    ///@throws std::invalid_argument if plain is in NTT form
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal12BatchEncoder6encodeERNS_9PlaintextENS_16MemoryPoolHandleE"]
    pub fn seal_BatchEncoder_encode2(
        this: *mut seal_BatchEncoder,
        plain: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Inverse of encode. This function "unbatches" a given SEAL plaintext into a matrix
    ///of integers modulo the plaintext modulus, and stores the result in the destination
    ///parameter. The input plaintext must have degress less than the polynomial modulus,
    ///and coefficients less than the plaintext modulus, i.e. it must be a valid plaintext
    ///for the encryption parameters. Dynamic memory allocations in the process are
    ///allocated from the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] plain The plaintext polynomial to unbatch
    ///@param[out] destination The matrix to be overwritten with the values in the slots
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if plain is not valid for the encryption parameters
    ///@throws std::invalid_argument if plain is in NTT form
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal12BatchEncoder6decodeERKNS_9PlaintextERSt6vectorImSaImEENS_16MemoryPoolHandleE"]
    pub fn seal_BatchEncoder_decode(
        this: *mut seal_BatchEncoder,
        plain: *const seal_Plaintext,
        destination: *mut u8,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Inverse of encode. This function "unbatches" a given SEAL plaintext into a matrix
    ///of integers modulo the plaintext modulus, and stores the result in the destination
    ///parameter. The input plaintext must have degress less than the polynomial modulus,
    ///and coefficients less than the plaintext modulus, i.e. it must be a valid plaintext
    ///for the encryption parameters. Dynamic memory allocations in the process are
    ///allocated from the memory pool pointed to by the given MemoryPoolHandle.
    ///
    ///@param[in] plain The plaintext polynomial to unbatch
    ///@param[out] destination The matrix to be overwritten with the values in the slots
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if plain is not valid for the encryption parameters
    ///@throws std::invalid_argument if plain is in NTT form
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal12BatchEncoder6decodeERKNS_9PlaintextERSt6vectorIlSaIlEENS_16MemoryPoolHandleE"]
    pub fn seal_BatchEncoder_decode1(
        this: *mut seal_BatchEncoder,
        plain: *const seal_Plaintext,
        destination: *mut u8,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Inverse of encode. This function "unbatches" a given SEAL plaintext in-place into
    ///a matrix of integers modulo the plaintext modulus. The input plaintext must have
    ///degress less than the polynomial modulus, and coefficients less than the plaintext
    ///modulus, i.e. it must be a valid plaintext for the encryption parameters. Dynamic
    ///memory allocations in the process are allocated from the memory pool pointed to by
    ///the given MemoryPoolHandle.
    ///
    ///@param[in] plain The plaintext polynomial to unbatch
    ///@param[in] pool The MemoryPoolHandle pointing to a valid memory pool
    ///@throws std::invalid_argument if plain is not valid for the encryption parameters
    ///@throws std::invalid_argument if plain is in NTT form
    ///@throws std::invalid_argument if pool is uninitialized
    #[link_name = "\u{1}_ZN4seal12BatchEncoder6decodeERNS_9PlaintextENS_16MemoryPoolHandleE"]
    pub fn seal_BatchEncoder_decode2(
        this: *mut seal_BatchEncoder,
        plain: *mut seal_Plaintext,
        pool: seal_MemoryPoolHandle,
    );
}
extern "C" {
    ///Returns the number of slots.
    #[link_name = "\u{1}_ZNK4seal12BatchEncoder10slot_countEv"]
    pub fn seal_BatchEncoder_slot_count(this: *const seal_BatchEncoder) -> ::std::os::raw::c_ulong;
}
extern "C" {
    ///Creates a BatchEncoder. It is necessary that the encryption parameters
    ///given through the SEALContext object support batching.
    ///
    ///@param[in] context The SEALContext
    ///@throws std::invalid_argument if the context is not set or encryption
    ///parameters are not valid for batching
    ///@throws std::invalid_argument if scheme is not scheme_type::BFV
    #[link_name = "\u{1}_ZN4seal12BatchEncoderC1ESt10shared_ptrINS_11SEALContextEE"]
    pub fn seal_BatchEncoder_BatchEncoder(this: *mut seal_BatchEncoder, context: [u64; 2usize]);
}
impl Default for seal_BatchEncoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl seal_BatchEncoder {
    #[inline]
    pub unsafe fn encode(&mut self, values: *const u8, destination: *mut seal_Plaintext) {
        seal_BatchEncoder_encode(self, values, destination)
    }
    #[inline]
    pub unsafe fn encode1(&mut self, values: *const u8, destination: *mut seal_Plaintext) {
        seal_BatchEncoder_encode1(self, values, destination)
    }
    #[inline]
    pub unsafe fn encode2(&mut self, plain: *mut seal_Plaintext, pool: seal_MemoryPoolHandle) {
        seal_BatchEncoder_encode2(self, plain, pool)
    }
    #[inline]
    pub unsafe fn decode(
        &mut self,
        plain: *const seal_Plaintext,
        destination: *mut u8,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_BatchEncoder_decode(self, plain, destination, pool)
    }
    #[inline]
    pub unsafe fn decode1(
        &mut self,
        plain: *const seal_Plaintext,
        destination: *mut u8,
        pool: seal_MemoryPoolHandle,
    ) {
        seal_BatchEncoder_decode1(self, plain, destination, pool)
    }
    #[inline]
    pub unsafe fn decode2(&mut self, plain: *mut seal_Plaintext, pool: seal_MemoryPoolHandle) {
        seal_BatchEncoder_decode2(self, plain, pool)
    }
    #[inline]
    pub unsafe fn slot_count(&self) -> ::std::os::raw::c_ulong {
        seal_BatchEncoder_slot_count(self)
    }
    #[inline]
    pub unsafe fn new(context: [u64; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        seal_BatchEncoder_BatchEncoder(&mut __bindgen_tmp, context);
        __bindgen_tmp
    }
}
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
extern "C" {
    #[link_name = "\u{1}SEALContext_Create"]
    pub fn bindings_SEALContext_Create(
        parms: *const seal_EncryptionParameters,
        expand_mod_chain: bool,
    ) -> *mut seal_SEALContext;
}
extern "C" {
    #[link_name = "\u{1}KeyGenerator_Create"]
    pub fn bindings_KeyGenerator_Create(ctx: *mut seal_SEALContext) -> *mut seal_KeyGenerator;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_57 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_SEAL_BYTE>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_SEAL_BYTE>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_ConstPointer_open0_unsigned_long_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ConstPointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_ConstPointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ConstPointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_ConstPointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
pub type seal_FastPRNG_const_iterator = *const value_type;
pub use self::seal_SEAL_BYTE as value_type;
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_global_variables_internal_mods_SmallModulus_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_SmallNTTTables_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_global_variables_internal_mods_SmallModulus_void_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_global_variables_internal_mods_SmallModulus_void_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_global_variables_internal_mods_SmallModulus_void_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_global_variables_internal_mods_SmallModulus_void_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_global_variables_internal_mods_SmallModulus_void_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_global_variables_internal_mods_SmallModulus>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_Pointer_open1_uint64_t_void_close1_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_util_Pointer<u64>>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_Pointer<u64>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_util_Pointer<u64>>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_Pointer<u64>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_Pointer_open1_uint64_t_void_close1_void_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_util_Pointer<u64>>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_Pointer<u64>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_util_Pointer<u64>>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_Pointer<u64>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_Pointer_open1_uint64_t_void_close1_void_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_util_Pointer<u64>>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_Pointer<u64>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_util_Pointer<u64>>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_Pointer<u64>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_SmallNTTTables_void_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_BaseConverter_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_util_BaseConverter>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_BaseConverter>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_util_BaseConverter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_BaseConverter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_SmallNTTTables_void_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_SmallNTTTables_void_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_BaseConverter_void_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_util_BaseConverter>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_BaseConverter>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_util_BaseConverter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_BaseConverter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_SmallNTTTables_void_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_SmallNTTTables_void_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<seal_util_SmallNTTTables>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<seal_util_SmallNTTTables>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_17() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_18() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_19() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_20() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_21() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
pub type size_type = usize;
#[test]
fn __bindgen_test_layout_seal_IntArray_open0_seal_Ciphertext_ct_coeff_type_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_IntArray>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_IntArray)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_IntArray>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_IntArray)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_ConstPointer_open0_unsigned_long_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_ConstPointer<::std::os::raw::c_ulong>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_ConstPointer<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_ConstPointer<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_ConstPointer<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_IntArray_open0_seal_Plaintext_pt_coeff_type_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<seal_IntArray>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_IntArray)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_IntArray>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_IntArray)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_std_complex_open1_double_close1_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<[u64; 4usize]>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u64; 4usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u64; 4usize]>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u64; 4usize])
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_std_complex_open1_double_close1_void_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<[u64; 4usize]>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u64; 4usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u64; 4usize]>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u64; 4usize])
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_22() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_23() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_24() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_25() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_26() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_27() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_28() {
    assert_eq!(
        ::std::mem::size_of::<seal_util_Pointer<u64>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<seal_util_Pointer<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(seal_util_Pointer<u64>)
        )
    );
}
