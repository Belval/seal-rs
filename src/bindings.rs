/* automatically generated by rust-bindgen */

# [ repr ( C ) ] pub struct __BindgenUnionField < T > ( :: std :: marker :: PhantomData < T > ) ; impl < T > __BindgenUnionField < T > { # [ inline ] pub fn new ( ) -> Self { __BindgenUnionField ( :: std :: marker :: PhantomData ) } # [ inline ] pub unsafe fn as_ref ( & self ) -> & T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut ( & mut self ) -> & mut T { :: std :: mem :: transmute ( self ) } } impl < T > :: std :: default :: Default for __BindgenUnionField < T > { # [ inline ] fn default ( ) -> Self { Self :: new ( ) } } impl < T > :: std :: clone :: Clone for __BindgenUnionField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } impl < T > :: std :: marker :: Copy for __BindgenUnionField < T > { } impl < T > :: std :: fmt :: Debug for __BindgenUnionField < T > { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter < '_ > ) -> :: std :: fmt :: Result { fmt . write_str ( "__BindgenUnionField" ) } } impl < T > :: std :: hash :: Hash for __BindgenUnionField < T > { fn hash < H : :: std :: hash :: Hasher > ( & self , _state : & mut H ) { } } impl < T > :: std :: cmp :: PartialEq for __BindgenUnionField < T > { fn eq ( & self , _other : & __BindgenUnionField < T > ) -> bool { true } } impl < T > :: std :: cmp :: Eq for __BindgenUnionField < T > { } pub type std_string = std_basic_string < :: std :: os :: raw :: c_char > ; # [ repr ( C ) ] pub struct std_basic_string < _CharT > { pub _M_dataplus : std_basic_string__Alloc_hider , pub _M_string_length : std_basic_string_size_type , pub __bindgen_anon_1 : std_basic_string__bindgen_ty_2 < _CharT > , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , } pub type std_basic_string__Char_alloc_type = [ u8 ; 0usize ] ; pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits ; pub type std_basic_string_traits_type < _Traits > = _Traits ; pub type std_basic_string_value_type = [ u8 ; 0usize ] ; pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type ; pub type std_basic_string_size_type = [ u8 ; 0usize ] ; pub type std_basic_string_difference_type = [ u8 ; 0usize ] ; pub type std_basic_string_reference = [ u8 ; 0usize ] ; pub type std_basic_string_const_reference = [ u8 ; 0usize ] ; pub type std_basic_string_pointer = [ u8 ; 0usize ] ; pub type std_basic_string_const_pointer = [ u8 ; 0usize ] ; pub type std_basic_string_iterator = __gnu_cxx___normal_iterator < std_basic_string_pointer > ; pub type std_basic_string_const_iterator = __gnu_cxx___normal_iterator < std_basic_string_const_pointer > ; pub type std_basic_string_const_reverse_iterator = std_reverse_iterator < std_basic_string_const_iterator > ; pub type std_basic_string_reverse_iterator = std_reverse_iterator < std_basic_string_iterator > ; pub type std_basic_string___const_iterator = std_basic_string_const_iterator ; pub type std_basic_string___sv_type < _CharT > = std_basic_string_view < _CharT > ; pub type std_basic_string__If_sv = std_enable_if_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_basic_string___sv_wrapper < _CharT > { pub _M_sv : std_basic_string___sv_type < _CharT > , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , } # [ repr ( C ) ] pub struct std_basic_string__Alloc_hider { pub _M_p : std_basic_string_pointer , } pub const std_basic_string__S_local_capacity : std_basic_string__bindgen_ty_1 = 0 ; pub type std_basic_string__bindgen_ty_1 = i32 ; # [ repr ( C ) ] pub struct std_basic_string__bindgen_ty_2 < _CharT > { pub _M_local_buf : __BindgenUnionField < * mut _CharT > , pub _M_allocated_capacity : __BindgenUnionField < std_basic_string_size_type > , pub bindgen_union_field : u64 , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , } pub type std_streamoff = :: std :: os :: raw :: c_long ; pub type std_streamsize = isize ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_fpos < _StateT > { pub _M_off : std_streamoff , pub _M_state : _StateT , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _StateT > > , } pub type std_streampos = std_fpos < mbstate_t > ; pub type std_istream = std_basic_istream < :: std :: os :: raw :: c_char > ; pub type std_ostream = std_basic_ostream < :: std :: os :: raw :: c_char > ; # [ repr ( C ) ] pub struct std_exception__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_exception { pub vtable_ : * const std_exception__bindgen_vtable , } # [ test ] fn bindgen_test_layout_std_exception ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_exception > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( std_exception ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_exception > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_exception ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt9exceptionD1Ev" ] pub fn std_exception_exception_destructor ( this : * mut std_exception ) ; } extern "C" { # [ link_name = "\u{1}_ZNKSt9exception4whatEv" ] pub fn std_exception_what ( this : * mut :: std :: os :: raw :: c_void ) -> * const :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_nothrow_t { pub _address : u8 , } # [ test ] fn bindgen_test_layout_std_nothrow_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_nothrow_t > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( std_nothrow_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_nothrow_t > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( std_nothrow_t ) ) ) ; } pub type std_integral_constant_value_type < _Tp > = _Tp ; pub type std_integral_constant_type = u8 ; pub type std_true_type = u8 ; pub type std_false_type = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___or_ { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___and_ { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_is_empty { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_remove_reference { pub _address : u8 , } pub type std_remove_reference_type < _Tp > = _Tp ; pub type std_remove_reference_t = std_remove_reference ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_make_unsigned { pub _address : u8 , } pub type std_make_unsigned_type = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_remove_extent { pub _address : u8 , } pub type std_remove_extent_type < _Tp > = _Tp ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union std_aligned_storage_type { pub __data : * mut :: std :: os :: raw :: c_uchar , pub __align : std_aligned_storage_type__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_aligned_storage_type__bindgen_ty_1 { pub _address : u8 , } # [ test ] fn bindgen_test_layout_std_aligned_storage_type ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_aligned_storage_type > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( std_aligned_storage_type ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_aligned_storage_type > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_aligned_storage_type ) ) ) ; } pub type std_conditional_type < _Iftrue > = _Iftrue ; pub type std_enable_if_t = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___detector { pub _address : u8 , } pub type std___detector_value_t = std_false_type ; pub type std___detector_type < _Default > = _Default ; pub type std___detected_or = std___detector ; pub type std___detected_or_t = std___detected_or ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___is_swappable { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___is_nothrow_swappable { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std___pair_base { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_pair < _T1 , _T2 > { pub first : _T1 , pub second : _T2 , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _T1 > > , pub _phantom_1 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _T2 > > , } pub type std_pair_first_type < _T1 > = _T1 ; pub type std_pair_second_type < _T2 > = _T2 ; pub type std_pair__PCCP = u8 ; pub type std_pair__PCCFP = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_input_iterator_tag { pub _address : u8 , } # [ test ] fn bindgen_test_layout_std_input_iterator_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_input_iterator_tag > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( std_input_iterator_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_input_iterator_tag > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( std_input_iterator_tag ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_output_iterator_tag { pub _address : u8 , } # [ test ] fn bindgen_test_layout_std_output_iterator_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_output_iterator_tag > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( std_output_iterator_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_output_iterator_tag > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( std_output_iterator_tag ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_forward_iterator_tag { pub _address : u8 , } # [ test ] fn bindgen_test_layout_std_forward_iterator_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_forward_iterator_tag > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( std_forward_iterator_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_forward_iterator_tag > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( std_forward_iterator_tag ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_iterator { pub _address : u8 , } pub type std_iterator_iterator_category < _Category > = _Category ; pub type std_iterator_value_type < _Tp > = _Tp ; pub type std_iterator_difference_type < _Distance > = _Distance ; pub type std_iterator_pointer < _Pointer > = _Pointer ; pub type std_iterator_reference < _Reference > = _Reference ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___iterator_traits { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_iterator_traits { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___undefined { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___get_first_arg { pub _address : u8 , } pub type std___get_first_arg_type = std___undefined ; pub type std___get_first_arg_t = std___get_first_arg ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___replace_first_arg { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_pointer_traits { pub _address : u8 , } pub type std_pointer_traits___element_type = [ u8 ; 0usize ] ; pub type std_pointer_traits___difference_type = [ u8 ; 0usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_pointer_traits___rebind { pub _address : u8 , } pub type std_pointer_traits_pointer < _Ptr > = _Ptr ; pub type std_pointer_traits_element_type = std___detected_or_t ; pub type std_pointer_traits_difference_type = std___detected_or_t ; pub type std_pointer_traits_rebind = std_pointer_traits___rebind ; pub type std___ptr_rebind = std_pointer_traits ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_reverse_iterator < _Iterator > { pub current : _Iterator , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _Iterator > > , } pub type std_reverse_iterator___traits_type = std_iterator_traits ; pub type std_reverse_iterator_iterator_type < _Iterator > = _Iterator ; pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type ; pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type ; pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_char_traits { pub _address : u8 , } pub type std___c_locale = __locale_t ; pub type std___allocator_base = __gnu_cxx_new_allocator ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_allocator { pub _address : u8 , } pub type std_allocator_size_type = usize ; pub type std_allocator_difference_type = isize ; pub type std_allocator_pointer < _Tp > = * mut _Tp ; pub type std_allocator_const_pointer < _Tp > = * const _Tp ; pub type std_allocator_reference < _Tp > = * mut _Tp ; pub type std_allocator_const_reference < _Tp > = * const _Tp ; pub type std_allocator_value_type < _Tp > = _Tp ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_allocator_rebind { pub _address : u8 , } pub type std_allocator_rebind_other = std_allocator ; pub type std_allocator_propagate_on_container_move_assignment = std_true_type ; pub type std_allocator_is_always_equal = std_true_type ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_binary_function { pub _address : u8 , } pub type std_binary_function_first_argument_type < _Arg1 > = _Arg1 ; pub type std_binary_function_second_argument_type < _Arg2 > = _Arg2 ; pub type std_binary_function_result_type < _Result > = _Result ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_equal_to { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___allocator_traits_base { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___allocator_traits_base___rebind { pub _address : u8 , } pub type std___allocator_traits_base___pointer = [ u8 ; 0usize ] ; pub type std___allocator_traits_base___c_pointer = [ u8 ; 0usize ] ; pub type std___allocator_traits_base___v_pointer = [ u8 ; 0usize ] ; pub type std___allocator_traits_base___cv_pointer = [ u8 ; 0usize ] ; pub type std___allocator_traits_base___pocca = [ u8 ; 0usize ] ; pub type std___allocator_traits_base___pocma = [ u8 ; 0usize ] ; pub type std___allocator_traits_base___pocs = [ u8 ; 0usize ] ; pub type std___allocator_traits_base___equal = [ u8 ; 0usize ] ; # [ test ] fn bindgen_test_layout_std___allocator_traits_base ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std___allocator_traits_base > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( std___allocator_traits_base ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std___allocator_traits_base > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( std___allocator_traits_base ) ) ) ; } pub type std___alloc_rebind = std___allocator_traits_base ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_allocator_traits { pub _address : u8 , } pub type std_allocator_traits_allocator_type < _Alloc > = _Alloc ; pub type std_allocator_traits_value_type = [ u8 ; 0usize ] ; pub type std_allocator_traits_pointer = std___detected_or_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_allocator_traits__Ptr { pub _address : u8 , } pub type std_allocator_traits__Ptr_type = [ u8 ; 0usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_allocator_traits__Diff { pub _address : u8 , } pub type std_allocator_traits__Diff_type = std_pointer_traits ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_allocator_traits__Size { pub _address : u8 , } pub type std_allocator_traits_const_pointer = [ u8 ; 0usize ] ; pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr ; pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr ; pub type std_allocator_traits_difference_type = [ u8 ; 0usize ] ; pub type std_allocator_traits_size_type = [ u8 ; 0usize ] ; pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t ; pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t ; pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t ; pub type std_allocator_traits_is_always_equal = std___detected_or_t ; pub type std_allocator_traits_rebind_alloc = std___alloc_rebind ; pub type std_allocator_traits_rebind_traits = std_allocator_traits ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_allocator_traits___construct_helper { pub _address : u8 , } pub type std_allocator_traits___construct_helper_type < _Alloc > = _Alloc ; pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_hash { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_basic_string_view < _CharT > { pub _M_len : usize , pub _M_str : * const _CharT , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , } pub type std_basic_string_view_traits_type < _Traits > = _Traits ; pub type std_basic_string_view_value_type < _CharT > = _CharT ; pub type std_basic_string_view_pointer < _CharT > = * const _CharT ; pub type std_basic_string_view_const_pointer < _CharT > = * const _CharT ; pub type std_basic_string_view_reference < _CharT > = * const _CharT ; pub type std_basic_string_view_const_reference < _CharT > = * const _CharT ; pub type std_basic_string_view_const_iterator < _CharT > = * const _CharT ; pub type std_basic_string_view_iterator < _CharT > = std_basic_string_view_const_iterator < _CharT > ; pub type std_basic_string_view_const_reverse_iterator < _CharT > = std_reverse_iterator < std_basic_string_view_const_iterator < _CharT > > ; pub type std_basic_string_view_reverse_iterator < _CharT > = std_basic_string_view_const_reverse_iterator < _CharT > ; pub type std_basic_string_view_size_type = usize ; pub type std_basic_string_view_difference_type = isize ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std___detail__ReuseOrAllocNode { pub _M_nodes : * mut std___detail__ReuseOrAllocNode___node_type , pub _M_h : * mut std___detail__ReuseOrAllocNode___hashtable_alloc , } pub type std___detail__ReuseOrAllocNode___node_alloc_type < _NodeAlloc > = _NodeAlloc ; pub type std___detail__ReuseOrAllocNode___hashtable_alloc = std___detail__Hashtable_alloc ; pub type std___detail__ReuseOrAllocNode___node_alloc_traits = std___detail__ReuseOrAllocNode___hashtable_alloc ; pub type std___detail__ReuseOrAllocNode___node_type = std___detail__ReuseOrAllocNode___hashtable_alloc ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___detail__Hash_node_base { pub _M_nxt : * mut std___detail__Hash_node_base , } # [ test ] fn bindgen_test_layout_std___detail__Hash_node_base ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std___detail__Hash_node_base > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( std___detail__Hash_node_base ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std___detail__Hash_node_base > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std___detail__Hash_node_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std___detail__Hash_node_base > ( ) ) ) . _M_nxt as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( std___detail__Hash_node_base ) , "::" , stringify ! ( _M_nxt ) ) ) ; } pub type std___detail__Node_iterator_base___node_type = u8 ; pub type std___detail__Node_iterator___base_type = u8 ; pub type std___detail__Node_iterator___node_type = std___detail__Node_iterator___base_type ; pub type std___detail__Node_iterator_value_type < _Value > = _Value ; pub type std___detail__Node_iterator_difference_type = isize ; pub type std___detail__Node_iterator_iterator_category = std_forward_iterator_tag ; pub type std___detail__Node_iterator_pointer = u8 ; pub type std___detail__Node_iterator_reference = u8 ; pub type std___detail__Node_const_iterator___base_type = u8 ; pub type std___detail__Node_const_iterator___node_type = std___detail__Node_const_iterator___base_type ; pub type std___detail__Node_const_iterator_value_type < _Value > = _Value ; pub type std___detail__Node_const_iterator_difference_type = isize ; pub type std___detail__Node_const_iterator_iterator_category = std_forward_iterator_tag ; pub type std___detail__Node_const_iterator_pointer < _Value > = * const _Value ; pub type std___detail__Node_const_iterator_reference < _Value > = * const _Value ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___detail__Rehash_base { pub _address : u8 , } pub type std___detail__Local_iterator___base_type = u8 ; pub type std___detail__Local_iterator___hash_code_base = std___detail__Local_iterator___base_type ; pub type std___detail__Local_iterator_value_type < _Value > = _Value ; pub type std___detail__Local_iterator_pointer = u8 ; pub type std___detail__Local_iterator_reference = u8 ; pub type std___detail__Local_iterator_difference_type = isize ; pub type std___detail__Local_iterator_iterator_category = std_forward_iterator_tag ; pub type std___detail__Local_const_iterator___base_type = u8 ; pub type std___detail__Local_const_iterator___hash_code_base = std___detail__Local_const_iterator___base_type ; pub type std___detail__Local_const_iterator_value_type < _Value > = _Value ; pub type std___detail__Local_const_iterator_pointer < _Value > = * const _Value ; pub type std___detail__Local_const_iterator_reference < _Value > = * const _Value ; pub type std___detail__Local_const_iterator_difference_type = isize ; pub type std___detail__Local_const_iterator_iterator_category = std_forward_iterator_tag ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___detail__Hashtable_base { pub _address : u8 , } pub type std___detail__Hashtable_base_key_type < _Key > = _Key ; pub type std___detail__Hashtable_base_value_type < _Value > = _Value ; pub type std___detail__Hashtable_base_key_equal < _Equal > = _Equal ; pub type std___detail__Hashtable_base_size_type = usize ; pub type std___detail__Hashtable_base_difference_type = isize ; pub type std___detail__Hashtable_base___traits_type < _Traits > = _Traits ; pub type std___detail__Hashtable_base___hash_cached = [ u8 ; 0usize ] ; pub type std___detail__Hashtable_base___constant_iterators = [ u8 ; 0usize ] ; pub type std___detail__Hashtable_base___unique_keys = [ u8 ; 0usize ] ; pub type std___detail__Hashtable_base___hash_code_base = u8 ; pub type std___detail__Hashtable_base___hash_code = std___detail__Hashtable_base___hash_code_base ; pub type std___detail__Hashtable_base___node_type = std___detail__Hashtable_base___hash_code_base ; pub type std___detail__Hashtable_base_iterator = u8 ; pub type std___detail__Hashtable_base_const_iterator = u8 ; pub type std___detail__Hashtable_base_local_iterator = u8 ; pub type std___detail__Hashtable_base_const_local_iterator = u8 ; pub type std___detail__Hashtable_base___ireturn_type = u8 ; pub type std___detail__Hashtable_base__EqualEBO = u8 ; pub type std___detail__Hashtable_base__EqualHelper = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___detail__Hashtable_alloc { pub _address : u8 , } pub type std___detail__Hashtable_alloc___ebo_node_alloc = u8 ; pub type std___detail__Hashtable_alloc___node_type = [ u8 ; 0usize ] ; pub type std___detail__Hashtable_alloc___node_alloc_type < _NodeAlloc > = _NodeAlloc ; pub type std___detail__Hashtable_alloc___node_alloc_traits = __gnu_cxx___alloc_traits ; pub type std___detail__Hashtable_alloc___value_alloc_traits = [ u8 ; 0usize ] ; pub type std___detail__Hashtable_alloc___node_base = std___detail__Hash_node_base ; pub type std___detail__Hashtable_alloc___bucket_type = * mut std___detail__Hashtable_alloc___node_base ; pub type std___detail__Hashtable_alloc___bucket_alloc_type = std___alloc_rebind ; pub type std___detail__Hashtable_alloc___bucket_alloc_traits = std_allocator_traits ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_locale { pub _M_impl : * mut std_locale__Impl , } pub type std_locale_category = :: std :: os :: raw :: c_int ; pub const std_locale__S_categories_size : std_locale__bindgen_ty_1 = 12 ; pub type std_locale__bindgen_ty_1 = u32 ; pub const std_locale_none : std_locale_category = 0 ; pub const std_locale_ctype : std_locale_category = 1 ; pub const std_locale_numeric : std_locale_category = 2 ; pub const std_locale_collate : std_locale_category = 4 ; pub const std_locale_time : std_locale_category = 8 ; pub const std_locale_monetary : std_locale_category = 16 ; pub const std_locale_messages : std_locale_category = 32 ; pub const std_locale_all : std_locale_category = 63 ; extern "C" { # [ link_name = "\u{1}_ZNSt6locale10_S_classicE" ] pub static mut std_locale__S_classic : * mut std_locale__Impl ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale9_S_globalE" ] pub static mut std_locale__S_global : * mut std_locale__Impl ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale13_S_categoriesE" ] pub static mut std_locale__S_categories : * const * const :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale7_S_onceE" ] pub static mut std_locale__S_once : __gthread_once_t ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale17_S_twinned_facetsE" ] pub static mut std_locale__S_twinned_facets : [ * const std_locale_id ; 0usize ] ; } # [ test ] fn bindgen_test_layout_std_locale ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_locale > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( std_locale ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_locale > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_locale ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_locale > ( ) ) ) . _M_impl as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( std_locale ) , "::" , stringify ! ( _M_impl ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNKSt6locale4nameB5cxx11Ev" ] pub fn std_locale_name ( this : * const std_locale ) -> std_string ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale6globalERKS_" ] pub fn std_locale_global ( __loc : * const std_locale ) -> std_locale ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale7classicEv" ] pub fn std_locale_classic ( ) -> * const std_locale ; } extern "C" { # [ link_name = "\u{1}_ZNSt6localeC1Ev" ] pub fn std_locale_locale ( this : * mut std_locale ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt6localeC1ERKS_" ] pub fn std_locale_locale1 ( this : * mut std_locale , __other : * const std_locale ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt6localeC1EPKc" ] pub fn std_locale_locale2 ( this : * mut std_locale , __s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt6localeC1ERKS_PKci" ] pub fn std_locale_locale3 ( this : * mut std_locale , __base : * const std_locale , __s : * const :: std :: os :: raw :: c_char , __cat : std_locale_category ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt6localeC1ERKS_S1_i" ] pub fn std_locale_locale4 ( this : * mut std_locale , __base : * const std_locale , __add : * const std_locale , __cat : std_locale_category ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt6localeD1Ev" ] pub fn std_locale_locale_destructor ( this : * mut std_locale ) ; } impl std_locale { # [ inline ] pub unsafe fn name ( & self ) -> std_string { std_locale_name ( self ) } # [ inline ] pub unsafe fn global ( __loc : * const std_locale ) -> std_locale { std_locale_global ( __loc ) } # [ inline ] pub unsafe fn classic ( ) -> * const std_locale { std_locale_classic ( ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_locale_locale ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( __other : * const std_locale ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_locale_locale1 ( & mut __bindgen_tmp , __other ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( __s : * const :: std :: os :: raw :: c_char ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_locale_locale2 ( & mut __bindgen_tmp , __s ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new3 ( __base : * const std_locale , __s : * const :: std :: os :: raw :: c_char , __cat : std_locale_category ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_locale_locale3 ( & mut __bindgen_tmp , __base , __s , __cat ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new4 ( __base : * const std_locale , __add : * const std_locale , __cat : std_locale_category ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_locale_locale4 ( & mut __bindgen_tmp , __base , __add , __cat ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { std_locale_locale_destructor ( self ) } } # [ repr ( C ) ] pub struct std_locale_facet__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_locale_facet { pub vtable_ : * const std_locale_facet__bindgen_vtable , pub _M_refcount : _Atomic_word , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_locale_facet___shim { _unused : [ u8 ; 0 ] , } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5facet11_S_c_localeE" ] pub static mut std_locale_facet__S_c_locale : std___c_locale ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5facet9_S_c_nameE" ] pub static mut std_locale_facet__S_c_name : [ :: std :: os :: raw :: c_char ; 2usize ] ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5facet7_S_onceE" ] pub static mut std_locale_facet__S_once : __gthread_once_t ; } # [ test ] fn bindgen_test_layout_std_locale_facet ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_locale_facet > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( std_locale_facet ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_locale_facet > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_locale_facet ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_locale_facet > ( ) ) ) . _M_refcount as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( std_locale_facet ) , "::" , stringify ! ( _M_refcount ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5facet18_S_create_c_localeERP15__locale_structPKcS2_" ] pub fn std_locale_facet__S_create_c_locale ( __cloc : * mut std___c_locale , __s : * const :: std :: os :: raw :: c_char , __old : std___c_locale ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5facet17_S_clone_c_localeERP15__locale_struct" ] pub fn std_locale_facet__S_clone_c_locale ( __cloc : * mut std___c_locale ) -> std___c_locale ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5facet19_S_destroy_c_localeERP15__locale_struct" ] pub fn std_locale_facet__S_destroy_c_locale ( __cloc : * mut std___c_locale ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5facet20_S_lc_ctype_c_localeEP15__locale_structPKc" ] pub fn std_locale_facet__S_lc_ctype_c_locale ( __cloc : std___c_locale , __s : * const :: std :: os :: raw :: c_char ) -> std___c_locale ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5facet15_S_get_c_localeEv" ] pub fn std_locale_facet__S_get_c_locale ( ) -> std___c_locale ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5facet13_S_get_c_nameEv" ] pub fn std_locale_facet__S_get_c_name ( ) -> * const :: std :: os :: raw :: c_char ; } impl std_locale_facet { # [ inline ] pub unsafe fn _S_create_c_locale ( __cloc : * mut std___c_locale , __s : * const :: std :: os :: raw :: c_char , __old : std___c_locale ) { std_locale_facet__S_create_c_locale ( __cloc , __s , __old ) } # [ inline ] pub unsafe fn _S_clone_c_locale ( __cloc : * mut std___c_locale ) -> std___c_locale { std_locale_facet__S_clone_c_locale ( __cloc ) } # [ inline ] pub unsafe fn _S_destroy_c_locale ( __cloc : * mut std___c_locale ) { std_locale_facet__S_destroy_c_locale ( __cloc ) } # [ inline ] pub unsafe fn _S_lc_ctype_c_locale ( __cloc : std___c_locale , __s : * const :: std :: os :: raw :: c_char ) -> std___c_locale { std_locale_facet__S_lc_ctype_c_locale ( __cloc , __s ) } # [ inline ] pub unsafe fn _S_get_c_locale ( ) -> std___c_locale { std_locale_facet__S_get_c_locale ( ) } # [ inline ] pub unsafe fn _S_get_c_name ( ) -> * const :: std :: os :: raw :: c_char { std_locale_facet__S_get_c_name ( ) } } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5facetD1Ev" ] pub fn std_locale_facet_facet_destructor ( this : * mut std_locale_facet ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_locale_id { pub _M_index : usize , } extern "C" { # [ link_name = "\u{1}_ZNSt6locale2id11_S_refcountE" ] pub static mut std_locale_id__S_refcount : _Atomic_word ; } # [ test ] fn bindgen_test_layout_std_locale_id ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_locale_id > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( std_locale_id ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_locale_id > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_locale_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_locale_id > ( ) ) ) . _M_index as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( std_locale_id ) , "::" , stringify ! ( _M_index ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNKSt6locale2id5_M_idEv" ] pub fn std_locale_id__M_id ( this : * const std_locale_id ) -> usize ; } impl std_locale_id { # [ inline ] pub unsafe fn _M_id ( & self ) -> usize { std_locale_id__M_id ( self ) } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_locale__Impl { pub _M_refcount : _Atomic_word , pub _M_facets : * mut * const std_locale_facet , pub _M_facets_size : usize , pub _M_caches : * mut * const std_locale_facet , pub _M_names : * mut * mut :: std :: os :: raw :: c_char , } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5_Impl11_S_id_ctypeE" ] pub static mut std_locale__Impl__S_id_ctype : [ * const std_locale_id ; 0usize ] ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_numericE" ] pub static mut std_locale__Impl__S_id_numeric : [ * const std_locale_id ; 0usize ] ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_collateE" ] pub static mut std_locale__Impl__S_id_collate : [ * const std_locale_id ; 0usize ] ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5_Impl10_S_id_timeE" ] pub static mut std_locale__Impl__S_id_time : [ * const std_locale_id ; 0usize ] ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_monetaryE" ] pub static mut std_locale__Impl__S_id_monetary : [ * const std_locale_id ; 0usize ] ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_messagesE" ] pub static mut std_locale__Impl__S_id_messages : [ * const std_locale_id ; 0usize ] ; } extern "C" { # [ link_name = "\u{1}_ZNSt6locale5_Impl19_S_facet_categoriesE" ] pub static mut std_locale__Impl__S_facet_categories : [ * const * const std_locale_id ; 0usize ] ; } # [ test ] fn bindgen_test_layout_std_locale__Impl ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_locale__Impl > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( std_locale__Impl ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_locale__Impl > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_locale__Impl ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_locale__Impl > ( ) ) ) . _M_refcount as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( std_locale__Impl ) , "::" , stringify ! ( _M_refcount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_locale__Impl > ( ) ) ) . _M_facets as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( std_locale__Impl ) , "::" , stringify ! ( _M_facets ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_locale__Impl > ( ) ) ) . _M_facets_size as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( std_locale__Impl ) , "::" , stringify ! ( _M_facets_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_locale__Impl > ( ) ) ) . _M_caches as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( std_locale__Impl ) , "::" , stringify ! ( _M_caches ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_locale__Impl > ( ) ) ) . _M_names as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( std_locale__Impl ) , "::" , stringify ! ( _M_names ) ) ) ; } # [ repr ( C ) ] pub struct std___cow_string { pub __bindgen_anon_1 : std___cow_string__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union std___cow_string__bindgen_ty_1 { pub _M_p : * const :: std :: os :: raw :: c_char , pub _M_bytes : [ :: std :: os :: raw :: c_char ; 8usize ] , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_std___cow_string__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std___cow_string__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( std___cow_string__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std___cow_string__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std___cow_string__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std___cow_string__bindgen_ty_1 > ( ) ) ) . _M_p as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( std___cow_string__bindgen_ty_1 ) , "::" , stringify ! ( _M_p ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std___cow_string__bindgen_ty_1 > ( ) ) ) . _M_bytes as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( std___cow_string__bindgen_ty_1 ) , "::" , stringify ! ( _M_bytes ) ) ) ; } # [ test ] fn bindgen_test_layout_std___cow_string ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std___cow_string > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( std___cow_string ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std___cow_string > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std___cow_string ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt12__cow_stringC1Ev" ] pub fn std___cow_string___cow_string ( this : * mut std___cow_string ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt12__cow_stringC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" ] pub fn std___cow_string___cow_string1 ( this : * mut std___cow_string , arg1 : * const std_string ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt12__cow_stringC1EPKcm" ] pub fn std___cow_string___cow_string2 ( this : * mut std___cow_string , arg1 : * const :: std :: os :: raw :: c_char , arg2 : usize ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt12__cow_stringC1ERKS_" ] pub fn std___cow_string___cow_string3 ( this : * mut std___cow_string , arg1 : * const std___cow_string ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt12__cow_stringC1EOS_" ] pub fn std___cow_string___cow_string4 ( this : * mut std___cow_string , arg1 : * mut std___cow_string ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt12__cow_stringD1Ev" ] pub fn std___cow_string___cow_string_destructor ( this : * mut std___cow_string ) ; } impl std___cow_string { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std___cow_string___cow_string ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( arg1 : * const std_string ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std___cow_string___cow_string1 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : usize ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std___cow_string___cow_string2 ( & mut __bindgen_tmp , arg1 , arg2 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new3 ( arg1 : * const std___cow_string ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std___cow_string___cow_string3 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new4 ( arg1 : * mut std___cow_string ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std___cow_string___cow_string4 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { std___cow_string___cow_string_destructor ( self ) } } # [ repr ( C ) ] pub struct std_runtime_error { pub _base : std_exception , pub _M_msg : std___cow_string , } # [ test ] fn bindgen_test_layout_std_runtime_error ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_runtime_error > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( std_runtime_error ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_runtime_error > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_runtime_error ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_runtime_error > ( ) ) ) . _M_msg as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( std_runtime_error ) , "::" , stringify ! ( _M_msg ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt13runtime_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" ] pub fn std_runtime_error_runtime_error ( this : * mut std_runtime_error , __arg : * const std_string ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt13runtime_errorC1EPKc" ] pub fn std_runtime_error_runtime_error1 ( this : * mut std_runtime_error , arg1 : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt13runtime_errorC1ERKS_" ] pub fn std_runtime_error_runtime_error2 ( this : * mut std_runtime_error , arg1 : * const std_runtime_error ) ; } impl std_runtime_error { # [ inline ] pub unsafe fn new ( __arg : * const std_string ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_runtime_error_runtime_error ( & mut __bindgen_tmp , __arg ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( arg1 : * const :: std :: os :: raw :: c_char ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_runtime_error_runtime_error1 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( arg1 : * const std_runtime_error ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_runtime_error_runtime_error2 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}_ZNSt13runtime_errorD1Ev" ] pub fn std_runtime_error_runtime_error_destructor ( this : * mut std_runtime_error ) ; } extern "C" { # [ link_name = "\u{1}_ZNKSt13runtime_error4whatEv" ] pub fn std_runtime_error_what ( this : * mut :: std :: os :: raw :: c_void ) -> * const :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] pub struct std_error_category__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_error_category { pub vtable_ : * const std_error_category__bindgen_vtable , } # [ test ] fn bindgen_test_layout_std_error_category ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_error_category > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( std_error_category ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_error_category > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_error_category ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt3_V214error_categoryD1Ev" ] pub fn std_error_category_error_category_destructor ( this : * mut std_error_category ) ; } extern "C" { # [ link_name = "\u{1}_ZNKSt3_V214error_category23default_error_conditionEi" ] pub fn std_error_category_default_error_condition ( this : * mut :: std :: os :: raw :: c_void , __i : :: std :: os :: raw :: c_int ) -> std_error_condition ; } extern "C" { # [ link_name = "\u{1}_ZNKSt3_V214error_category10equivalentEiRKSt15error_condition" ] pub fn std_error_category_equivalent ( this : * mut :: std :: os :: raw :: c_void , __i : :: std :: os :: raw :: c_int , __cond : * const std_error_condition ) -> bool ; } extern "C" { # [ link_name = "\u{1}_ZNKSt3_V214error_category10equivalentERKSt10error_codei" ] pub fn std_error_category_equivalent1 ( this : * mut :: std :: os :: raw :: c_void , __code : * const std_error_code , __i : :: std :: os :: raw :: c_int ) -> bool ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_error_code { pub _M_value : :: std :: os :: raw :: c_int , pub _M_cat : * const std_error_category , } # [ test ] fn bindgen_test_layout_std_error_code ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_error_code > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( std_error_code ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_error_code > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_error_code ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_error_code > ( ) ) ) . _M_value as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( std_error_code ) , "::" , stringify ! ( _M_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_error_code > ( ) ) ) . _M_cat as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( std_error_code ) , "::" , stringify ! ( _M_cat ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNKSt10error_code23default_error_conditionEv" ] pub fn std_error_code_default_error_condition ( this : * const std_error_code ) -> std_error_condition ; } impl std_error_code { # [ inline ] pub unsafe fn default_error_condition ( & self ) -> std_error_condition { std_error_code_default_error_condition ( self ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_error_condition { pub _M_value : :: std :: os :: raw :: c_int , pub _M_cat : * const std_error_category , } # [ test ] fn bindgen_test_layout_std_error_condition ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_error_condition > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( std_error_condition ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_error_condition > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_error_condition ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_error_condition > ( ) ) ) . _M_value as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( std_error_condition ) , "::" , stringify ! ( _M_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_error_condition > ( ) ) ) . _M_cat as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( std_error_condition ) , "::" , stringify ! ( _M_cat ) ) ) ; } # [ repr ( C ) ] pub struct std_system_error { pub _base : std_runtime_error , pub _M_code : std_error_code , } # [ test ] fn bindgen_test_layout_std_system_error ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_system_error > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( std_system_error ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_system_error > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_system_error ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_system_error > ( ) ) ) . _M_code as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( std_system_error ) , "::" , stringify ! ( _M_code ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt12system_errorD1Ev" ] pub fn std_system_error_system_error_destructor ( this : * mut std_system_error ) ; } pub const std__Ios_Fmtflags__S_boolalpha : std__Ios_Fmtflags = 1 ; pub const std__Ios_Fmtflags__S_dec : std__Ios_Fmtflags = 2 ; pub const std__Ios_Fmtflags__S_fixed : std__Ios_Fmtflags = 4 ; pub const std__Ios_Fmtflags__S_hex : std__Ios_Fmtflags = 8 ; pub const std__Ios_Fmtflags__S_internal : std__Ios_Fmtflags = 16 ; pub const std__Ios_Fmtflags__S_left : std__Ios_Fmtflags = 32 ; pub const std__Ios_Fmtflags__S_oct : std__Ios_Fmtflags = 64 ; pub const std__Ios_Fmtflags__S_right : std__Ios_Fmtflags = 128 ; pub const std__Ios_Fmtflags__S_scientific : std__Ios_Fmtflags = 256 ; pub const std__Ios_Fmtflags__S_showbase : std__Ios_Fmtflags = 512 ; pub const std__Ios_Fmtflags__S_showpoint : std__Ios_Fmtflags = 1024 ; pub const std__Ios_Fmtflags__S_showpos : std__Ios_Fmtflags = 2048 ; pub const std__Ios_Fmtflags__S_skipws : std__Ios_Fmtflags = 4096 ; pub const std__Ios_Fmtflags__S_unitbuf : std__Ios_Fmtflags = 8192 ; pub const std__Ios_Fmtflags__S_uppercase : std__Ios_Fmtflags = 16384 ; pub const std__Ios_Fmtflags__S_adjustfield : std__Ios_Fmtflags = 176 ; pub const std__Ios_Fmtflags__S_basefield : std__Ios_Fmtflags = 74 ; pub const std__Ios_Fmtflags__S_floatfield : std__Ios_Fmtflags = 260 ; pub const std__Ios_Fmtflags__S_ios_fmtflags_end : std__Ios_Fmtflags = 65536 ; pub const std__Ios_Fmtflags__S_ios_fmtflags_max : std__Ios_Fmtflags = 2147483647 ; pub const std__Ios_Fmtflags__S_ios_fmtflags_min : std__Ios_Fmtflags = -2147483648 ; pub type std__Ios_Fmtflags = i32 ; pub const std__Ios_Openmode__S_app : std__Ios_Openmode = 1 ; pub const std__Ios_Openmode__S_ate : std__Ios_Openmode = 2 ; pub const std__Ios_Openmode__S_bin : std__Ios_Openmode = 4 ; pub const std__Ios_Openmode__S_in : std__Ios_Openmode = 8 ; pub const std__Ios_Openmode__S_out : std__Ios_Openmode = 16 ; pub const std__Ios_Openmode__S_trunc : std__Ios_Openmode = 32 ; pub const std__Ios_Openmode__S_ios_openmode_end : std__Ios_Openmode = 65536 ; pub const std__Ios_Openmode__S_ios_openmode_max : std__Ios_Openmode = 2147483647 ; pub const std__Ios_Openmode__S_ios_openmode_min : std__Ios_Openmode = -2147483648 ; pub type std__Ios_Openmode = i32 ; pub const std__Ios_Iostate__S_goodbit : std__Ios_Iostate = 0 ; pub const std__Ios_Iostate__S_badbit : std__Ios_Iostate = 1 ; pub const std__Ios_Iostate__S_eofbit : std__Ios_Iostate = 2 ; pub const std__Ios_Iostate__S_failbit : std__Ios_Iostate = 4 ; pub const std__Ios_Iostate__S_ios_iostate_end : std__Ios_Iostate = 65536 ; pub const std__Ios_Iostate__S_ios_iostate_max : std__Ios_Iostate = 2147483647 ; pub const std__Ios_Iostate__S_ios_iostate_min : std__Ios_Iostate = -2147483648 ; pub type std__Ios_Iostate = i32 ; pub const std__Ios_Seekdir__S_beg : std__Ios_Seekdir = 0 ; pub const std__Ios_Seekdir__S_cur : std__Ios_Seekdir = 1 ; pub const std__Ios_Seekdir__S_end : std__Ios_Seekdir = 2 ; pub const std__Ios_Seekdir__S_ios_seekdir_end : std__Ios_Seekdir = 65536 ; pub type std__Ios_Seekdir = u32 ; # [ repr ( C ) ] pub struct std_ios_base__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_ios_base { pub vtable_ : * const std_ios_base__bindgen_vtable , pub _M_precision : std_streamsize , pub _M_width : std_streamsize , pub _M_flags : std_ios_base_fmtflags , pub _M_exception : std_ios_base_iostate , pub _M_streambuf_state : std_ios_base_iostate , pub _M_callbacks : * mut std_ios_base__Callback_list , pub _M_word_zero : std_ios_base__Words , pub _M_local_word : [ std_ios_base__Words ; 8usize ] , pub _M_word_size : :: std :: os :: raw :: c_int , pub _M_word : * mut std_ios_base__Words , pub _M_ios_locale : std_locale , } # [ repr ( C ) ] pub struct std_ios_base_failure { pub _base : std_system_error , } # [ test ] fn bindgen_test_layout_std_ios_base_failure ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_ios_base_failure > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( std_ios_base_failure ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_ios_base_failure > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_ios_base_failure ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" ] pub fn std_ios_base_failure_failure ( this : * mut std_ios_base_failure , __str : * const std_string ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt10error_code" ] pub fn std_ios_base_failure_failure1 ( this : * mut std_ios_base_failure , arg1 : * const std_string , arg2 : * const std_error_code ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1EPKcRKSt10error_code" ] pub fn std_ios_base_failure_failure2 ( this : * mut std_ios_base_failure , arg1 : * const :: std :: os :: raw :: c_char , arg2 : * const std_error_code ) ; } impl std_ios_base_failure { # [ inline ] pub unsafe fn new ( __str : * const std_string ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_ios_base_failure_failure ( & mut __bindgen_tmp , __str ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( arg1 : * const std_string , arg2 : * const std_error_code ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_ios_base_failure_failure1 ( & mut __bindgen_tmp , arg1 , arg2 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * const std_error_code ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_ios_base_failure_failure2 ( & mut __bindgen_tmp , arg1 , arg2 ) ; __bindgen_tmp } } pub use self :: std__Ios_Fmtflags as std_ios_base_fmtflags ; pub use self :: std__Ios_Iostate as std_ios_base_iostate ; pub use self :: std__Ios_Openmode as std_ios_base_openmode ; pub use self :: std__Ios_Seekdir as std_ios_base_seekdir ; pub const std_ios_base_event_erase_event : std_ios_base_event = 0 ; pub const std_ios_base_event_imbue_event : std_ios_base_event = 1 ; pub const std_ios_base_event_copyfmt_event : std_ios_base_event = 2 ; pub type std_ios_base_event = u32 ; pub type std_ios_base_event_callback = :: std :: option :: Option < unsafe extern "C" fn ( __e : std_ios_base_event , __b : * mut std_ios_base , __i : :: std :: os :: raw :: c_int ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_ios_base__Callback_list { pub _M_next : * mut std_ios_base__Callback_list , pub _M_fn : std_ios_base_event_callback , pub _M_index : :: std :: os :: raw :: c_int , pub _M_refcount : _Atomic_word , } # [ test ] fn bindgen_test_layout_std_ios_base__Callback_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_ios_base__Callback_list > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( std_ios_base__Callback_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_ios_base__Callback_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_ios_base__Callback_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base__Callback_list > ( ) ) ) . _M_next as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base__Callback_list ) , "::" , stringify ! ( _M_next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base__Callback_list > ( ) ) ) . _M_fn as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base__Callback_list ) , "::" , stringify ! ( _M_fn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base__Callback_list > ( ) ) ) . _M_index as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base__Callback_list ) , "::" , stringify ! ( _M_index ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base__Callback_list > ( ) ) ) . _M_refcount as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base__Callback_list ) , "::" , stringify ! ( _M_refcount ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_ios_base__Words { pub _M_pword : * mut :: std :: os :: raw :: c_void , pub _M_iword : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_std_ios_base__Words ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_ios_base__Words > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( std_ios_base__Words ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_ios_base__Words > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_ios_base__Words ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base__Words > ( ) ) ) . _M_pword as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base__Words ) , "::" , stringify ! ( _M_pword ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base__Words > ( ) ) ) . _M_iword as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base__Words ) , "::" , stringify ! ( _M_iword ) ) ) ; } pub const std_ios_base__S_local_word_size : std_ios_base__bindgen_ty_1 = 8 ; pub type std_ios_base__bindgen_ty_1 = u32 ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_ios_base_Init { pub _address : u8 , } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base4Init11_S_refcountE" ] pub static mut std_ios_base_Init__S_refcount : _Atomic_word ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base4Init20_S_synced_with_stdioE" ] pub static mut std_ios_base_Init__S_synced_with_stdio : bool ; } # [ test ] fn bindgen_test_layout_std_ios_base_Init ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_ios_base_Init > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( std_ios_base_Init ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_ios_base_Init > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( std_ios_base_Init ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base4InitC1Ev" ] pub fn std_ios_base_Init_Init ( this : * mut std_ios_base_Init ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base4InitD1Ev" ] pub fn std_ios_base_Init_Init_destructor ( this : * mut std_ios_base_Init ) ; } impl std_ios_base_Init { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_ios_base_Init_Init ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { std_ios_base_Init_Init_destructor ( self ) } } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base9boolalphaE" ] pub static mut std_ios_base_boolalpha : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base3decE" ] pub static mut std_ios_base_dec : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base5fixedE" ] pub static mut std_ios_base_fixed : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base3hexE" ] pub static mut std_ios_base_hex : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base8internalE" ] pub static mut std_ios_base_internal : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base4leftE" ] pub static mut std_ios_base_left : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base3octE" ] pub static mut std_ios_base_oct : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base5rightE" ] pub static mut std_ios_base_right : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base10scientificE" ] pub static mut std_ios_base_scientific : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base8showbaseE" ] pub static mut std_ios_base_showbase : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base9showpointE" ] pub static mut std_ios_base_showpoint : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base7showposE" ] pub static mut std_ios_base_showpos : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base6skipwsE" ] pub static mut std_ios_base_skipws : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base7unitbufE" ] pub static mut std_ios_base_unitbuf : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base9uppercaseE" ] pub static mut std_ios_base_uppercase : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base11adjustfieldE" ] pub static mut std_ios_base_adjustfield : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base9basefieldE" ] pub static mut std_ios_base_basefield : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base10floatfieldE" ] pub static mut std_ios_base_floatfield : std_ios_base_fmtflags ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base6badbitE" ] pub static mut std_ios_base_badbit : std_ios_base_iostate ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base6eofbitE" ] pub static mut std_ios_base_eofbit : std_ios_base_iostate ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base7failbitE" ] pub static mut std_ios_base_failbit : std_ios_base_iostate ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base7goodbitE" ] pub static mut std_ios_base_goodbit : std_ios_base_iostate ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base3appE" ] pub static mut std_ios_base_app : std_ios_base_openmode ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base3ateE" ] pub static mut std_ios_base_ate : std_ios_base_openmode ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base6binaryE" ] pub static mut std_ios_base_binary : std_ios_base_openmode ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base2inE" ] pub static mut std_ios_base_in : std_ios_base_openmode ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base3outE" ] pub static mut std_ios_base_out : std_ios_base_openmode ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base5truncE" ] pub static mut std_ios_base_trunc : std_ios_base_openmode ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base3begE" ] pub static mut std_ios_base_beg : std_ios_base_seekdir ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base3curE" ] pub static mut std_ios_base_cur : std_ios_base_seekdir ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base3endE" ] pub static mut std_ios_base_end : std_ios_base_seekdir ; } # [ test ] fn bindgen_test_layout_std_ios_base ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_ios_base > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( std_ios_base ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_ios_base > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( std_ios_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base > ( ) ) ) . _M_precision as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base ) , "::" , stringify ! ( _M_precision ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base > ( ) ) ) . _M_width as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base ) , "::" , stringify ! ( _M_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base > ( ) ) ) . _M_flags as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base ) , "::" , stringify ! ( _M_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base > ( ) ) ) . _M_exception as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base ) , "::" , stringify ! ( _M_exception ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base > ( ) ) ) . _M_streambuf_state as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base ) , "::" , stringify ! ( _M_streambuf_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base > ( ) ) ) . _M_callbacks as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base ) , "::" , stringify ! ( _M_callbacks ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base > ( ) ) ) . _M_word_zero as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base ) , "::" , stringify ! ( _M_word_zero ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base > ( ) ) ) . _M_local_word as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base ) , "::" , stringify ! ( _M_local_word ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base > ( ) ) ) . _M_word_size as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base ) , "::" , stringify ! ( _M_word_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base > ( ) ) ) . _M_word as * const _ as usize } , 200usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base ) , "::" , stringify ! ( _M_word ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < std_ios_base > ( ) ) ) . _M_ios_locale as * const _ as usize } , 208usize , concat ! ( "Offset of field: " , stringify ! ( std_ios_base ) , "::" , stringify ! ( _M_ios_locale ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi" ] pub fn std_ios_base_register_callback ( this : * mut std_ios_base , __fn : std_ios_base_event_callback , __index : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base17_M_call_callbacksENS_5eventE" ] pub fn std_ios_base__M_call_callbacks ( this : * mut std_ios_base , __ev : std_ios_base_event ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base20_M_dispose_callbacksEv" ] pub fn std_ios_base__M_dispose_callbacks ( this : * mut std_ios_base ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base13_M_grow_wordsEib" ] pub fn std_ios_base__M_grow_words ( this : * mut std_ios_base , __index : :: std :: os :: raw :: c_int , __iword : bool ) -> * mut std_ios_base__Words ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base7_M_initEv" ] pub fn std_ios_base__M_init ( this : * mut std_ios_base ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base15sync_with_stdioEb" ] pub fn std_ios_base_sync_with_stdio ( __sync : bool ) -> bool ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base5imbueERKSt6locale" ] pub fn std_ios_base_imbue ( this : * mut std_ios_base , __loc : * const std_locale ) -> std_locale ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base6xallocEv" ] pub fn std_ios_base_xalloc ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base7_M_moveERS_" ] pub fn std_ios_base__M_move ( this : * mut std_ios_base , arg1 : * mut std_ios_base ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base7_M_swapERS_" ] pub fn std_ios_base__M_swap ( this : * mut std_ios_base , __rhs : * mut std_ios_base ) ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_baseC1Ev" ] pub fn std_ios_base_ios_base ( this : * mut std_ios_base ) ; } impl std_ios_base { # [ inline ] pub unsafe fn register_callback ( & mut self , __fn : std_ios_base_event_callback , __index : :: std :: os :: raw :: c_int ) { std_ios_base_register_callback ( self , __fn , __index ) } # [ inline ] pub unsafe fn _M_call_callbacks ( & mut self , __ev : std_ios_base_event ) { std_ios_base__M_call_callbacks ( self , __ev ) } # [ inline ] pub unsafe fn _M_dispose_callbacks ( & mut self ) { std_ios_base__M_dispose_callbacks ( self ) } # [ inline ] pub unsafe fn _M_grow_words ( & mut self , __index : :: std :: os :: raw :: c_int , __iword : bool ) -> * mut std_ios_base__Words { std_ios_base__M_grow_words ( self , __index , __iword ) } # [ inline ] pub unsafe fn _M_init ( & mut self ) { std_ios_base__M_init ( self ) } # [ inline ] pub unsafe fn sync_with_stdio ( __sync : bool ) -> bool { std_ios_base_sync_with_stdio ( __sync ) } # [ inline ] pub unsafe fn imbue ( & mut self , __loc : * const std_locale ) -> std_locale { std_ios_base_imbue ( self , __loc ) } # [ inline ] pub unsafe fn xalloc ( ) -> :: std :: os :: raw :: c_int { std_ios_base_xalloc ( ) } # [ inline ] pub unsafe fn _M_move ( & mut self , arg1 : * mut std_ios_base ) { std_ios_base__M_move ( self , arg1 ) } # [ inline ] pub unsafe fn _M_swap ( & mut self , __rhs : * mut std_ios_base ) { std_ios_base__M_swap ( self , __rhs ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; std_ios_base_ios_base ( & mut __bindgen_tmp ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11D1Ev" ] pub fn std_ios_base_failure_failure_destructor ( this : * mut std_ios_base_failure ) ; } extern "C" { # [ link_name = "\u{1}_ZNKSt8ios_base7failureB5cxx114whatEv" ] pub fn std_ios_base_failure_what ( this : * mut :: std :: os :: raw :: c_void ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_ZNSt8ios_baseD1Ev" ] pub fn std_ios_base_ios_base_destructor ( this : * mut std_ios_base ) ; } # [ repr ( C ) ] pub struct std_basic_streambuf__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_basic_streambuf < _CharT > { pub vtable_ : * const std_basic_streambuf__bindgen_vtable , pub _M_in_beg : * mut std_basic_streambuf_char_type < _CharT > , pub _M_in_cur : * mut std_basic_streambuf_char_type < _CharT > , pub _M_in_end : * mut std_basic_streambuf_char_type < _CharT > , pub _M_out_beg : * mut std_basic_streambuf_char_type < _CharT > , pub _M_out_cur : * mut std_basic_streambuf_char_type < _CharT > , pub _M_out_end : * mut std_basic_streambuf_char_type < _CharT > , pub _M_buf_locale : std_locale , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , } pub type std_basic_streambuf_char_type < _CharT > = _CharT ; pub type std_basic_streambuf_traits_type < _Traits > = _Traits ; pub type std_basic_streambuf_int_type = [ u8 ; 0usize ] ; pub type std_basic_streambuf_pos_type = [ u8 ; 0usize ] ; pub type std_basic_streambuf_off_type = [ u8 ; 0usize ] ; pub type std_basic_streambuf___streambuf_type < _CharT > = std_basic_streambuf < std_basic_streambuf_char_type < _CharT > > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_ctype_base { pub _address : u8 , } pub type std_ctype_base___to_type = * const :: std :: os :: raw :: c_int ; pub type std_ctype_base_mask = :: std :: os :: raw :: c_ushort ; pub const std_ctype_base_upper : std_ctype_base_mask = 256 ; pub const std_ctype_base_lower : std_ctype_base_mask = 512 ; pub const std_ctype_base_alpha : std_ctype_base_mask = 1024 ; pub const std_ctype_base_digit : std_ctype_base_mask = 2048 ; pub const std_ctype_base_xdigit : std_ctype_base_mask = 4096 ; pub const std_ctype_base_space : std_ctype_base_mask = 8192 ; pub const std_ctype_base_print : std_ctype_base_mask = 16384 ; pub const std_ctype_base_graph : std_ctype_base_mask = 3076 ; pub const std_ctype_base_cntrl : std_ctype_base_mask = 2 ; pub const std_ctype_base_punct : std_ctype_base_mask = 4 ; pub const std_ctype_base_alnum : std_ctype_base_mask = 3072 ; pub const std_ctype_base_blank : std_ctype_base_mask = 1 ; # [ test ] fn bindgen_test_layout_std_ctype_base ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_ctype_base > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( std_ctype_base ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_ctype_base > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( std_ctype_base ) ) ) ; } # [ repr ( C ) ] pub struct std_istreambuf_iterator < _CharT > { pub _M_sbuf : * mut std_istreambuf_iterator_streambuf_type < _CharT > , pub _M_c : std_istreambuf_iterator_int_type , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , } pub type std_istreambuf_iterator_char_type < _CharT > = _CharT ; pub type std_istreambuf_iterator_traits_type < _Traits > = _Traits ; pub type std_istreambuf_iterator_int_type = [ u8 ; 0usize ] ; pub type std_istreambuf_iterator_streambuf_type < _CharT > = std_basic_streambuf < _CharT > ; pub type std_istreambuf_iterator_istream_type < _CharT > = std_basic_istream < _CharT > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_ostreambuf_iterator < _CharT > { pub _M_sbuf : * mut std_ostreambuf_iterator_streambuf_type < _CharT > , pub _M_failed : bool , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , } pub type std_ostreambuf_iterator_char_type < _CharT > = _CharT ; pub type std_ostreambuf_iterator_traits_type < _Traits > = _Traits ; pub type std_ostreambuf_iterator_streambuf_type < _CharT > = std_basic_streambuf < _CharT > ; pub type std_ostreambuf_iterator_ostream_type < _CharT > = std_basic_ostream < _CharT > ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std___ctype_abstract_base { pub _base : std_locale_facet , } pub type std___ctype_abstract_base_char_type < _CharT > = _CharT ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_ctype { pub _base : std___ctype_abstract_base , } pub type std_ctype_char_type < _CharT > = _CharT ; pub type std_ctype_mask = std___ctype_abstract_base ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_num_get { pub _base : std_locale_facet , } pub type std_num_get_char_type < _CharT > = _CharT ; pub type std_num_get_iter_type < _InIter > = _InIter ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_num_put { pub _base : std_locale_facet , } pub type std_num_put_char_type < _CharT > = _CharT ; pub type std_num_put_iter_type < _OutIter > = _OutIter ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_basic_ios < _CharT > { pub _base : std_ios_base , pub _M_tie : * mut std_basic_ostream < _CharT > , pub _M_fill : std_basic_ios_char_type < _CharT > , pub _M_fill_init : bool , pub _M_streambuf : * mut std_basic_streambuf < _CharT > , pub _M_ctype : * const std_basic_ios___ctype_type , pub _M_num_put : * const std_basic_ios___num_put_type , pub _M_num_get : * const std_basic_ios___num_get_type , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , } pub type std_basic_ios_char_type < _CharT > = _CharT ; pub type std_basic_ios_int_type = [ u8 ; 0usize ] ; pub type std_basic_ios_pos_type = [ u8 ; 0usize ] ; pub type std_basic_ios_off_type = [ u8 ; 0usize ] ; pub type std_basic_ios_traits_type < _Traits > = _Traits ; pub type std_basic_ios___ctype_type = std_ctype ; pub type std_basic_ios___num_put_type = std_num_put ; pub type std_basic_ios___num_get_type = std_num_get ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_basic_ostream < _CharT > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , } pub type std_basic_ostream_char_type < _CharT > = _CharT ; pub type std_basic_ostream_int_type = [ u8 ; 0usize ] ; pub type std_basic_ostream_pos_type = [ u8 ; 0usize ] ; pub type std_basic_ostream_off_type = [ u8 ; 0usize ] ; pub type std_basic_ostream_traits_type < _Traits > = _Traits ; pub type std_basic_ostream___streambuf_type < _CharT > = std_basic_streambuf < _CharT > ; pub type std_basic_ostream___ios_type < _CharT > = std_basic_ios < _CharT > ; pub type std_basic_ostream___ostream_type < _CharT > = std_basic_ostream < _CharT > ; pub type std_basic_ostream___num_put_type = std_num_put ; pub type std_basic_ostream___ctype_type = std_ctype ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_basic_ostream_sentry { pub _M_ok : bool , pub _M_os : * mut std_basic_ostream < _CharT > , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_basic_istream < _CharT > { pub _M_gcount : std_streamsize , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , } pub type std_basic_istream_char_type < _CharT > = _CharT ; pub type std_basic_istream_int_type = [ u8 ; 0usize ] ; pub type std_basic_istream_pos_type = [ u8 ; 0usize ] ; pub type std_basic_istream_off_type = [ u8 ; 0usize ] ; pub type std_basic_istream_traits_type < _Traits > = _Traits ; pub type std_basic_istream___streambuf_type < _CharT > = std_basic_streambuf < _CharT > ; pub type std_basic_istream___ios_type < _CharT > = std_basic_ios < _CharT > ; pub type std_basic_istream___istream_type < _CharT > = std_basic_istream < _CharT > ; pub type std_basic_istream___num_get_type = std_num_get ; pub type std_basic_istream___ctype_type = std_ctype ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_basic_istream_sentry { pub _M_ok : bool , } pub type std_basic_istream_sentry_traits_type = _Traits ; pub type std_basic_istream_sentry___streambuf_type = std_basic_streambuf < _CharT > ; pub type std_basic_istream_sentry___istream_type = std_basic_istream < _CharT > ; pub type std_basic_istream_sentry___ctype_type = std_basic_istream___ctype_type ; pub type std_basic_istream_sentry___int_type = [ u8 ; 0usize ] ; pub type std___array_traits__Type < _Tp > = * mut _Tp ; pub type std___array_traits__Is_swappable = std___is_swappable ; pub type std___array_traits__Is_nothrow_swappable = std___is_nothrow_swappable ; pub type std_array_value_type < _Tp > = _Tp ; pub type std_array_pointer < _Tp > = * mut std_array_value_type < _Tp > ; pub type std_array_const_pointer < _Tp > = * const std_array_value_type < _Tp > ; pub type std_array_reference < _Tp > = * mut std_array_value_type < _Tp > ; pub type std_array_const_reference < _Tp > = * const std_array_value_type < _Tp > ; pub type std_array_iterator < _Tp > = * mut std_array_value_type < _Tp > ; pub type std_array_const_iterator < _Tp > = * const std_array_value_type < _Tp > ; pub type std_array_size_type = usize ; pub type std_array_difference_type = isize ; pub type std_array_reverse_iterator < _Tp > = std_reverse_iterator < std_array_iterator < _Tp > > ; pub type std_array_const_reverse_iterator < _Tp > = std_reverse_iterator < std_array_const_iterator < _Tp > > ; pub type std_array__AT_Type = u8 ; extern "C" { # [ link_name = "\u{1}__shared_count<_Lp>" ] pub fn std___shared_count___shared_count<_Lp> ( this : * mut u8 , __r : * mut u8 ) ; } extern "C" { # [ link_name = "\u{1}__shared_count<_Lp>" ] pub fn std___shared_count___shared_count<_Lp>1 ( this : * mut u8 , __r : * mut u8 , arg1 : std_nothrow_t ) ; } pub type std___shared_ptr_element_type = std_remove_extent ; pub type std___shared_ptr__SafeConv = u8 ; pub type std___shared_ptr__Compatible = u8 ; pub type std___shared_ptr__Assignable = std___shared_ptr__Compatible ; pub type std___shared_ptr__UniqCompatible = u8 ; pub type std___shared_ptr__UniqAssignable = std___shared_ptr__UniqCompatible ; pub type std___shared_ptr_weak_type = u8 ; pub type std___shared_ptr___esft_base_t = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___shared_ptr___has_esft_base { pub _base : std_false_type , } pub type std___weak_ptr__Compatible = u8 ; pub type std___weak_ptr__Assignable = std___weak_ptr__Compatible ; pub type std___weak_ptr_element_type = std_remove_extent ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_shared_ptr { pub _address : u8 , } pub type std_shared_ptr__Constructible = u8 ; pub type std_shared_ptr__Assignable = u8 ; pub type std_shared_ptr_element_type = u8 ; pub type std_shared_ptr_weak_type = std_weak_ptr ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_weak_ptr { pub _address : u8 , } pub type std_weak_ptr__Constructible = u8 ; pub type std_weak_ptr__Assignable = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_optional { pub _address : u8 , } pub type std_optional__Base = u8 ; pub type std_optional_value_type < _Tp > = _Tp ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std__Node_handle_common { pub _M_ptr : std__Node_handle_common__AllocTraits , pub _M_alloc : std_optional , } pub type std__Node_handle_common__AllocTraits = std_allocator_traits ; pub type std__Node_handle_common_allocator_type = std___alloc_rebind ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std__Node_handle { pub _base : std__Node_handle_common , pub _M_pkey : std__Node_handle___pointer , pub _M_pmapped : std__Node_handle___pointer , } pub type std__Node_handle_key_type < _Key > = _Key ; pub type std__Node_handle_mapped_type = [ u8 ; 0usize ] ; pub type std__Node_handle__AllocTraits = std_allocator_traits ; pub type std__Node_handle___pointer = std___ptr_rebind ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std__Node_insert_return < _Iterator , _NodeHandle > { pub position : _Iterator , pub inserted : bool , pub node : _NodeHandle , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _Iterator > > , pub _phantom_1 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _NodeHandle > > , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std__Hashtable < _RehashPolicy > { pub _M_buckets : * mut std__Hashtable___bucket_type , pub _M_bucket_count : std__Hashtable_size_type , pub _M_before_begin : std__Hashtable___node_base , pub _M_element_count : std__Hashtable_size_type , pub _M_rehash_policy : _RehashPolicy , pub _M_single_bucket : std__Hashtable___bucket_type , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _RehashPolicy > > , } pub type std__Hashtable___traits_type < _Traits > = _Traits ; pub type std__Hashtable___hash_cached = [ u8 ; 0usize ] ; pub type std__Hashtable___node_type = u8 ; pub type std__Hashtable___node_alloc_type = std___alloc_rebind ; pub type std__Hashtable___hashtable_alloc = std___detail__Hashtable_alloc ; pub type std__Hashtable___value_alloc_traits = std__Hashtable___hashtable_alloc ; pub type std__Hashtable___node_alloc_traits = std__Hashtable___hashtable_alloc ; pub type std__Hashtable___node_base = std__Hashtable___hashtable_alloc ; pub type std__Hashtable___bucket_type = std__Hashtable___hashtable_alloc ; pub type std__Hashtable_key_type < _Key > = _Key ; pub type std__Hashtable_value_type < _Value > = _Value ; pub type std__Hashtable_allocator_type < _Alloc > = _Alloc ; pub type std__Hashtable_key_equal < _Equal > = _Equal ; pub type std__Hashtable_pointer = std__Hashtable___value_alloc_traits ; pub type std__Hashtable_const_pointer = std__Hashtable___value_alloc_traits ; pub type std__Hashtable_reference < _Value > = * mut std__Hashtable_value_type < _Value > ; pub type std__Hashtable_const_reference < _Value > = * const std__Hashtable_value_type < _Value > ; pub type std__Hashtable___rehash_type < _RehashPolicy > = _RehashPolicy ; pub type std__Hashtable___rehash_state = [ u8 ; 0usize ] ; pub type std__Hashtable___constant_iterators = [ u8 ; 0usize ] ; pub type std__Hashtable___unique_keys = [ u8 ; 0usize ] ; pub type std__Hashtable___key_extract = u8 ; pub type std__Hashtable___hashtable_base = std___detail__Hashtable_base ; pub type std__Hashtable___hash_code_base = std__Hashtable___hashtable_base ; pub type std__Hashtable___hash_code = std__Hashtable___hashtable_base ; pub type std__Hashtable___ireturn_type = std__Hashtable___hashtable_base ; pub type std__Hashtable___map_base = u8 ; pub type std__Hashtable___rehash_base = std___detail__Rehash_base ; pub type std__Hashtable___eq_base = u8 ; pub type std__Hashtable___reuse_or_alloc_node_type = std___detail__ReuseOrAllocNode ; pub type std__Hashtable___if_hash_cached = std___or_ ; pub type std__Hashtable___if_hash_not_cached = std___or_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std__Hashtable___hash_code_base_access { pub _address : u8 , } pub type std__Hashtable_size_type = std__Hashtable___hashtable_base ; pub type std__Hashtable_difference_type = std__Hashtable___hashtable_base ; pub type std__Hashtable_iterator = std__Hashtable___hashtable_base ; pub type std__Hashtable_const_iterator = std__Hashtable___hashtable_base ; pub type std__Hashtable_local_iterator = std__Hashtable___hashtable_base ; pub type std__Hashtable_const_local_iterator = std__Hashtable___hashtable_base ; pub type std__Hashtable_node_type = std__Node_handle ; pub type std__Hashtable_insert_return_type = std__Node_insert_return < std__Hashtable_iterator , std__Hashtable_node_type > ; pub type std___umap_hashtable = std__Hashtable < _RehashPolicy > ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_unordered_map { pub _M_h : std_unordered_map__Hashtable , } pub type std_unordered_map__Hashtable = std___umap_hashtable ; pub type std_unordered_map_key_type = std_unordered_map__Hashtable ; pub type std_unordered_map_value_type = std_unordered_map__Hashtable ; pub type std_unordered_map_mapped_type = std_unordered_map__Hashtable ; pub type std_unordered_map_hasher = std_unordered_map__Hashtable ; pub type std_unordered_map_key_equal = std_unordered_map__Hashtable ; pub type std_unordered_map_allocator_type = std_unordered_map__Hashtable ; pub type std_unordered_map_pointer = std_unordered_map__Hashtable ; pub type std_unordered_map_const_pointer = std_unordered_map__Hashtable ; pub type std_unordered_map_reference = std_unordered_map__Hashtable ; pub type std_unordered_map_const_reference = std_unordered_map__Hashtable ; pub type std_unordered_map_iterator = std_unordered_map__Hashtable ; pub type std_unordered_map_const_iterator = std_unordered_map__Hashtable ; pub type std_unordered_map_local_iterator = std_unordered_map__Hashtable ; pub type std_unordered_map_const_local_iterator = std_unordered_map__Hashtable ; pub type std_unordered_map_size_type = std_unordered_map__Hashtable ; pub type std_unordered_map_difference_type = std_unordered_map__Hashtable ; pub type std_unordered_map_node_type = std_unordered_map__Hashtable ; pub type std_unordered_map_insert_return_type = std_unordered_map__Hashtable ; # [ repr ( C ) ] pub struct std__Vector_base { pub _M_impl : std__Vector_base__Vector_impl , } pub type std__Vector_base__Tp_alloc_type = [ u8 ; 0usize ] ; pub type std__Vector_base_pointer = [ u8 ; 0usize ] ; # [ repr ( C ) ] pub struct std__Vector_base__Vector_impl { pub _M_start : std__Vector_base_pointer , pub _M_finish : std__Vector_base_pointer , pub _M_end_of_storage : std__Vector_base_pointer , } pub type std__Vector_base_allocator_type < _Alloc > = _Alloc ; # [ repr ( C ) ] pub struct std_vector { pub _base : std__Vector_base , } pub type std_vector__Base = std__Vector_base ; pub type std_vector__Tp_alloc_type = std_vector__Base ; pub type std_vector__Alloc_traits = __gnu_cxx___alloc_traits ; pub type std_vector_value_type < _Tp > = _Tp ; pub type std_vector_pointer = std_vector__Base ; pub type std_vector_const_pointer = std_vector__Alloc_traits ; pub type std_vector_reference = std_vector__Alloc_traits ; pub type std_vector_const_reference = std_vector__Alloc_traits ; pub type std_vector_iterator = __gnu_cxx___normal_iterator < std_vector_pointer > ; pub type std_vector_const_iterator = __gnu_cxx___normal_iterator < std_vector_const_pointer > ; pub type std_vector_const_reverse_iterator = std_reverse_iterator < std_vector_const_iterator > ; pub type std_vector_reverse_iterator = std_reverse_iterator < std_vector_iterator > ; pub type std_vector_size_type = usize ; pub type std_vector_difference_type = isize ; pub type std_vector_allocator_type < _Alloc > = _Alloc ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_vector__Temporary_value { pub _M_this : * mut std_vector , pub __buf : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __gnu_cxx___normal_iterator < _Iterator > { pub _M_current : _Iterator , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _Iterator > > , } pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits ; pub type __gnu_cxx___normal_iterator_iterator_type < _Iterator > = _Iterator ; pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type ; pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type ; pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type ; pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type ; pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __gnu_cxx__Char_types { pub _address : u8 , } pub type __gnu_cxx__Char_types_int_type = :: std :: os :: raw :: c_ulong ; pub type __gnu_cxx__Char_types_pos_type = std_streampos ; pub type __gnu_cxx__Char_types_off_type = std_streamoff ; pub type __gnu_cxx__Char_types_state_type = mbstate_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __gnu_cxx_char_traits { pub _address : u8 , } pub type __gnu_cxx_char_traits_char_type < _CharT > = _CharT ; pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types ; pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types ; pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types ; pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct __gnu_cxx_new_allocator { pub _address : u8 , } pub type __gnu_cxx_new_allocator_size_type = usize ; pub type __gnu_cxx_new_allocator_difference_type = isize ; pub type __gnu_cxx_new_allocator_pointer < _Tp > = * mut _Tp ; pub type __gnu_cxx_new_allocator_const_pointer < _Tp > = * const _Tp ; pub type __gnu_cxx_new_allocator_reference < _Tp > = * mut _Tp ; pub type __gnu_cxx_new_allocator_const_reference < _Tp > = * const _Tp ; pub type __gnu_cxx_new_allocator_value_type < _Tp > = _Tp ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __gnu_cxx_new_allocator_rebind { pub _address : u8 , } pub type __gnu_cxx_new_allocator_rebind_other = __gnu_cxx_new_allocator ; pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __gnu_cxx___alloc_traits { pub _address : u8 , } pub type __gnu_cxx___alloc_traits_allocator_type < _Alloc > = _Alloc ; pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits ; pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type ; pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type ; pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type ; pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type ; pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type ; pub type __gnu_cxx___alloc_traits_reference = * mut __gnu_cxx___alloc_traits_value_type ; pub type __gnu_cxx___alloc_traits_const_reference = * const __gnu_cxx___alloc_traits_value_type ; pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __gnu_cxx___alloc_traits_rebind { pub _address : u8 , } pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __mbstate_t { pub __count : :: std :: os :: raw :: c_int , pub __value : __mbstate_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __mbstate_t__bindgen_ty_1 { pub __wch : :: std :: os :: raw :: c_uint , pub __wchb : [ :: std :: os :: raw :: c_char ; 4usize ] , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout___mbstate_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t__bindgen_ty_1 > ( ) ) ) . __wch as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t__bindgen_ty_1 > ( ) ) ) . __wchb as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb ) ) ) ; } # [ test ] fn bindgen_test_layout___mbstate_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t > ( ) ) ) . __count as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t > ( ) ) ) . __value as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __value ) ) ) ; } pub type mbstate_t = __mbstate_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_struct { pub __locales : [ * mut __locale_data ; 13usize ] , pub __ctype_b : * const :: std :: os :: raw :: c_ushort , pub __ctype_tolower : * const :: std :: os :: raw :: c_int , pub __ctype_toupper : * const :: std :: os :: raw :: c_int , pub __names : [ * const :: std :: os :: raw :: c_char ; 13usize ] , } # [ test ] fn bindgen_test_layout___locale_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __locale_struct > ( ) , 232usize , concat ! ( "Size of: " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __locale_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __locales as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __locales ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_b as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_b ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_tolower as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_tolower ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_toupper as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_toupper ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __names as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __names ) ) ) ; } pub type __locale_t = * mut __locale_struct ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; pub type __gthread_once_t = pthread_once_t ; pub type _Atomic_word = :: std :: os :: raw :: c_int ; pub type seal_SEAL_BYTE = u8 ; 
 ///Represent an integer modulus of up to 62 bits. An instance of the SmallModulus
///class represents a non-negative integer modulus up to 62 bits. In particular,
///the encryption parameter plain_modulus, and the primes in coeff_modulus, are
///represented by instances of SmallModulus. The purpose of this class is to
///perform and store the pre-computation required by Barrett reduction.
///
///@par Thread Safety
///In general, reading from SmallModulus is thread-safe as long as no other thread
///is concurrently mutating it.
///
///@see EncryptionParameters for a description of the encryption parameters. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct seal_util_global_variables_internal_mods_SmallModulus { pub value_ : u64 , pub const_ratio_ : [ u64 ; 3usize ] , pub bit_count_ : :: std :: os :: raw :: c_int , pub uint64_count_ : usize , } # [ test ] fn bindgen_test_layout_seal_util_global_variables_internal_mods_SmallModulus ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_global_variables_internal_mods_SmallModulus > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( seal_util_global_variables_internal_mods_SmallModulus ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_global_variables_internal_mods_SmallModulus > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_util_global_variables_internal_mods_SmallModulus ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_global_variables_internal_mods_SmallModulus > ( ) ) ) . value_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_global_variables_internal_mods_SmallModulus ) , "::" , stringify ! ( value_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_global_variables_internal_mods_SmallModulus > ( ) ) ) . const_ratio_ as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_global_variables_internal_mods_SmallModulus ) , "::" , stringify ! ( const_ratio_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_global_variables_internal_mods_SmallModulus > ( ) ) ) . bit_count_ as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_global_variables_internal_mods_SmallModulus ) , "::" , stringify ! ( bit_count_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_global_variables_internal_mods_SmallModulus > ( ) ) ) . uint64_count_ as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_global_variables_internal_mods_SmallModulus ) , "::" , stringify ! ( uint64_count_ ) ) ) ; } extern "C" { 
 ///Saves the SmallModulus to an output stream. The full state of the modulus is
///serialized. The output is in binary format and not human-readable. The output
///stream must have the "binary" flag set.
///
///@param[in] stream The stream to save the SmallModulus to
///@throws std::exception if the SmallModulus could not be written to stream 
 # [ link_name = "\u{1}_ZNK4seal12SmallModulus4saveERSo" ] pub fn seal_util_global_variables_internal_mods_SmallModulus_save ( this : * const seal_util_global_variables_internal_mods_SmallModulus , stream : * mut std_ostream ) ; } extern "C" { 
 ///Loads a SmallModulus from an input stream overwriting the current SmallModulus.
///
///@param[in] stream The stream to load the SmallModulus from
///@throws std::exception if a valid SmallModulus could not be read from stream 
 # [ link_name = "\u{1}_ZN4seal12SmallModulus4loadERSi" ] pub fn seal_util_global_variables_internal_mods_SmallModulus_load ( this : * const seal_util_global_variables_internal_mods_SmallModulus , stream : * mut std_istream ) ; } impl seal_util_global_variables_internal_mods_SmallModulus { # [ inline ] pub unsafe fn save ( & self , stream : * mut std_ostream ) { seal_util_global_variables_internal_mods_SmallModulus_save ( self , stream ) } # [ inline ] pub unsafe fn load ( & mut self , stream : * mut std_istream ) { seal_util_global_variables_internal_mods_SmallModulus_load ( self , stream ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct seal_util_MemoryPoolItem { pub data_ : * mut seal_SEAL_BYTE , pub next_ : * mut seal_util_MemoryPoolItem , } # [ test ] fn bindgen_test_layout_seal_util_MemoryPoolItem ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_MemoryPoolItem > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( seal_util_MemoryPoolItem ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_MemoryPoolItem > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_util_MemoryPoolItem ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_MemoryPoolItem > ( ) ) ) . data_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_MemoryPoolItem ) , "::" , stringify ! ( data_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_MemoryPoolItem > ( ) ) ) . next_ as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_MemoryPoolItem ) , "::" , stringify ! ( next_ ) ) ) ; } # [ repr ( C ) ] pub struct seal_util_MemoryPoolHead__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct seal_util_MemoryPoolHead { pub vtable_ : * const seal_util_MemoryPoolHead__bindgen_vtable , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct seal_util_MemoryPoolHead_allocation { pub size : usize , pub data_ptr : * mut seal_SEAL_BYTE , pub free : usize , pub head_ptr : * mut seal_SEAL_BYTE , } # [ test ] fn bindgen_test_layout_seal_util_MemoryPoolHead_allocation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_MemoryPoolHead_allocation > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( seal_util_MemoryPoolHead_allocation ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_MemoryPoolHead_allocation > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_util_MemoryPoolHead_allocation ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_MemoryPoolHead_allocation > ( ) ) ) . size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_MemoryPoolHead_allocation ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_MemoryPoolHead_allocation > ( ) ) ) . data_ptr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_MemoryPoolHead_allocation ) , "::" , stringify ! ( data_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_MemoryPoolHead_allocation > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_MemoryPoolHead_allocation ) , "::" , stringify ! ( free ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_MemoryPoolHead_allocation > ( ) ) ) . head_ptr as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_MemoryPoolHead_allocation ) , "::" , stringify ! ( head_ptr ) ) ) ; } # [ test ] fn bindgen_test_layout_seal_util_MemoryPoolHead ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_MemoryPoolHead > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( seal_util_MemoryPoolHead ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_MemoryPoolHead > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_util_MemoryPoolHead ) ) ) ; } # [ repr ( C ) ] pub struct seal_util_MemoryPool__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct seal_util_MemoryPool { pub vtable_ : * const seal_util_MemoryPool__bindgen_vtable , } pub const seal_util_MemoryPool_alloc_size_multiplier : f64 = 1.05 ; extern "C" { # [ link_name = "\u{1}_ZN4seal4util10MemoryPool27max_single_alloc_byte_countE" ] pub static mut seal_util_MemoryPool_max_single_alloc_byte_count : usize ; } extern "C" { # [ link_name = "\u{1}_ZN4seal4util10MemoryPool19max_pool_head_countE" ] pub static mut seal_util_MemoryPool_max_pool_head_count : usize ; } extern "C" { # [ link_name = "\u{1}_ZN4seal4util10MemoryPool26max_batch_alloc_byte_countE" ] pub static mut seal_util_MemoryPool_max_batch_alloc_byte_count : usize ; } pub const seal_util_MemoryPool_first_alloc_count : usize = 1 ; # [ test ] fn bindgen_test_layout_seal_util_MemoryPool ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_MemoryPool > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( seal_util_MemoryPool ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_MemoryPool > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_util_MemoryPool ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct seal_util_Pointer < T > { pub data_ : * mut T , pub head_ : * mut seal_util_MemoryPoolHead , pub item_ : * mut seal_util_MemoryPoolItem , pub alias_ : bool , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub type seal_util_HashFunction_sha3_block_type = [ u64 ; 4usize ] ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct seal_util_SmallNTTTables { pub pool_ : seal_MemoryPoolHandle , pub generated_ : bool , pub root_ : u64 , pub root_powers_ : seal_util_Pointer < :: std :: os :: raw :: c_ulong > , pub scaled_root_powers_ : seal_util_Pointer < :: std :: os :: raw :: c_ulong > , pub inv_root_powers_div_two_ : seal_util_Pointer < :: std :: os :: raw :: c_ulong > , pub scaled_inv_root_powers_div_two_ : seal_util_Pointer < :: std :: os :: raw :: c_ulong > , pub coeff_count_power_ : :: std :: os :: raw :: c_int , pub coeff_count_ : usize , pub modulus_ : seal_util_global_variables_internal_mods_SmallModulus , pub inv_root_powers_ : seal_util_Pointer < :: std :: os :: raw :: c_ulong > , pub scaled_inv_root_powers_ : seal_util_Pointer < :: std :: os :: raw :: c_ulong > , pub inv_degree_modulo_ : u64 , } # [ test ] fn bindgen_test_layout_seal_util_SmallNTTTables ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_SmallNTTTables > ( ) , 296usize , concat ! ( "Size of: " , stringify ! ( seal_util_SmallNTTTables ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_SmallNTTTables > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_util_SmallNTTTables ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . pool_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( pool_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . generated_ as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( generated_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . root_ as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( root_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . root_powers_ as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( root_powers_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . scaled_root_powers_ as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( scaled_root_powers_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . inv_root_powers_div_two_ as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( inv_root_powers_div_two_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . scaled_inv_root_powers_div_two_ as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( scaled_inv_root_powers_div_two_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . coeff_count_power_ as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( coeff_count_power_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . coeff_count_ as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( coeff_count_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . modulus_ as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( modulus_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . inv_root_powers_ as * const _ as usize } , 224usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( inv_root_powers_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . scaled_inv_root_powers_ as * const _ as usize } , 256usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( scaled_inv_root_powers_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_SmallNTTTables > ( ) ) ) . inv_degree_modulo_ as * const _ as usize } , 288usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_SmallNTTTables ) , "::" , stringify ! ( inv_degree_modulo_ ) ) ) ; } extern "C" { # [ link_name = "\u{1}_ZN4seal4util14SmallNTTTables8generateEiRKNS_12SmallModulusE" ] pub fn seal_util_SmallNTTTables_generate ( this : * mut seal_util_SmallNTTTables , coeff_count_power : :: std :: os :: raw :: c_int , modulus : * const seal_util_global_variables_internal_mods_SmallModulus ) -> bool ; } extern "C" { # [ link_name = "\u{1}_ZN4seal4util14SmallNTTTables5resetEv" ] pub fn seal_util_SmallNTTTables_reset ( this : * mut seal_util_SmallNTTTables ) ; } extern "C" { # [ link_name = "\u{1}_ZN4seal4util14SmallNTTTablesC1EiRKNS_12SmallModulusENS_16MemoryPoolHandleE" ] pub fn seal_util_SmallNTTTables_SmallNTTTables ( this : * mut seal_util_SmallNTTTables , coeff_count_power : :: std :: os :: raw :: c_int , modulus : * const seal_util_global_variables_internal_mods_SmallModulus , pool : seal_MemoryPoolHandle ) ; } impl seal_util_SmallNTTTables { # [ inline ] pub unsafe fn generate ( & mut self , coeff_count_power : :: std :: os :: raw :: c_int , modulus : * const seal_util_global_variables_internal_mods_SmallModulus ) -> bool { seal_util_SmallNTTTables_generate ( self , coeff_count_power , modulus ) } # [ inline ] pub unsafe fn reset ( & mut self ) { seal_util_SmallNTTTables_reset ( self ) } # [ inline ] pub unsafe fn new ( coeff_count_power : :: std :: os :: raw :: c_int , modulus : * const seal_util_global_variables_internal_mods_SmallModulus , pool : seal_MemoryPoolHandle ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; seal_util_SmallNTTTables_SmallNTTTables ( & mut __bindgen_tmp , coeff_count_power , modulus , pool ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct seal_util_BaseConverter { pub pool_ : seal_MemoryPoolHandle , pub generated_ : bool , pub coeff_base_mod_count_ : usize , pub aux_base_mod_count_ : usize , pub bsk_base_mod_count_ : usize , pub coeff_count_ : usize , pub plain_gamma_count_ : usize , pub coeff_base_array_ : seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > , pub aux_base_array_ : seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > , pub bsk_base_array_ : seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > , pub plain_gamma_array_ : seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > , pub coeff_products_array_ : seal_util_Pointer < u64 > , pub coeff_base_products_mod_aux_bsk_array_ : seal_util_Pointer < seal_util_Pointer < u64 > > , pub inv_coeff_base_products_mod_coeff_array_ : seal_util_Pointer < u64 > , pub coeff_base_products_mod_mtilde_array_ : seal_util_Pointer < u64 > , pub mtilde_inv_coeff_base_products_mod_coeff_array_ : seal_util_Pointer < u64 > , pub inv_coeff_products_all_mod_aux_bsk_array_ : seal_util_Pointer < u64 > , pub aux_base_products_mod_coeff_array_ : seal_util_Pointer < seal_util_Pointer < u64 > > , pub inv_aux_base_products_mod_aux_array_ : seal_util_Pointer < u64 > , pub aux_base_products_mod_msk_array_ : seal_util_Pointer < u64 > , pub inv_coeff_products_mod_mtilde_ : u64 , pub inv_aux_products_mod_msk_ : u64 , pub inv_gamma_mod_plain_ : u64 , pub aux_products_all_mod_coeff_array_ : seal_util_Pointer < u64 > , pub inv_mtilde_mod_bsk_array_ : seal_util_Pointer < u64 > , pub coeff_products_all_mod_bsk_array_ : seal_util_Pointer < u64 > , pub coeff_products_mod_plain_gamma_array_ : seal_util_Pointer < seal_util_Pointer < u64 > > , pub neg_inv_coeff_products_all_mod_plain_gamma_array_ : seal_util_Pointer < u64 > , pub plain_gamma_product_mod_coeff_array_ : seal_util_Pointer < u64 > , pub bsk_small_ntt_tables_ : seal_util_Pointer < seal_util_SmallNTTTables > , pub inv_last_coeff_mod_array_ : seal_util_Pointer < u64 > , pub m_tilde_ : seal_util_global_variables_internal_mods_SmallModulus , pub m_sk_ : seal_util_global_variables_internal_mods_SmallModulus , pub small_plain_mod_ : seal_util_global_variables_internal_mods_SmallModulus , pub gamma_ : seal_util_global_variables_internal_mods_SmallModulus , } # [ test ] fn bindgen_test_layout_seal_util_BaseConverter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_BaseConverter > ( ) , 952usize , concat ! ( "Size of: " , stringify ! ( seal_util_BaseConverter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_BaseConverter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_util_BaseConverter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . pool_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( pool_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . generated_ as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( generated_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . coeff_base_mod_count_ as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( coeff_base_mod_count_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . aux_base_mod_count_ as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( aux_base_mod_count_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . bsk_base_mod_count_ as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( bsk_base_mod_count_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . coeff_count_ as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( coeff_count_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . plain_gamma_count_ as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( plain_gamma_count_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . coeff_base_array_ as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( coeff_base_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . aux_base_array_ as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( aux_base_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . bsk_base_array_ as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( bsk_base_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . plain_gamma_array_ as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( plain_gamma_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . coeff_products_array_ as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( coeff_products_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . coeff_base_products_mod_aux_bsk_array_ as * const _ as usize } , 224usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( coeff_base_products_mod_aux_bsk_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . inv_coeff_base_products_mod_coeff_array_ as * const _ as usize } , 256usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( inv_coeff_base_products_mod_coeff_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . coeff_base_products_mod_mtilde_array_ as * const _ as usize } , 288usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( coeff_base_products_mod_mtilde_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . mtilde_inv_coeff_base_products_mod_coeff_array_ as * const _ as usize } , 320usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( mtilde_inv_coeff_base_products_mod_coeff_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . inv_coeff_products_all_mod_aux_bsk_array_ as * const _ as usize } , 352usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( inv_coeff_products_all_mod_aux_bsk_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . aux_base_products_mod_coeff_array_ as * const _ as usize } , 384usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( aux_base_products_mod_coeff_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . inv_aux_base_products_mod_aux_array_ as * const _ as usize } , 416usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( inv_aux_base_products_mod_aux_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . aux_base_products_mod_msk_array_ as * const _ as usize } , 448usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( aux_base_products_mod_msk_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . inv_coeff_products_mod_mtilde_ as * const _ as usize } , 480usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( inv_coeff_products_mod_mtilde_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . inv_aux_products_mod_msk_ as * const _ as usize } , 488usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( inv_aux_products_mod_msk_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . inv_gamma_mod_plain_ as * const _ as usize } , 496usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( inv_gamma_mod_plain_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . aux_products_all_mod_coeff_array_ as * const _ as usize } , 504usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( aux_products_all_mod_coeff_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . inv_mtilde_mod_bsk_array_ as * const _ as usize } , 536usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( inv_mtilde_mod_bsk_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . coeff_products_all_mod_bsk_array_ as * const _ as usize } , 568usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( coeff_products_all_mod_bsk_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . coeff_products_mod_plain_gamma_array_ as * const _ as usize } , 600usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( coeff_products_mod_plain_gamma_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . neg_inv_coeff_products_all_mod_plain_gamma_array_ as * const _ as usize } , 632usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( neg_inv_coeff_products_all_mod_plain_gamma_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . plain_gamma_product_mod_coeff_array_ as * const _ as usize } , 664usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( plain_gamma_product_mod_coeff_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . bsk_small_ntt_tables_ as * const _ as usize } , 696usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( bsk_small_ntt_tables_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . inv_last_coeff_mod_array_ as * const _ as usize } , 728usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( inv_last_coeff_mod_array_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . m_tilde_ as * const _ as usize } , 760usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( m_tilde_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . m_sk_ as * const _ as usize } , 808usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( m_sk_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . small_plain_mod_ as * const _ as usize } , 856usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( small_plain_mod_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_util_BaseConverter > ( ) ) ) . gamma_ as * const _ as usize } , 904usize , concat ! ( "Offset of field: " , stringify ! ( seal_util_BaseConverter ) , "::" , stringify ! ( gamma_ ) ) ) ; } extern "C" { 
 ///Generates the pre-computations for the given parameters. 
 # [ link_name = "\u{1}_ZN4seal4util13BaseConverter8generateERKSt6vectorINS_12SmallModulusESaIS3_EEmRKS3_" ] pub fn seal_util_BaseConverter_generate ( this : * mut seal_util_BaseConverter , coeff_base : * const std_vector , coeff_count : usize , small_plain_mod : * const seal_util_global_variables_internal_mods_SmallModulus ) ; } extern "C" { 
 ///Fast base converter from q to Bsk 
 # [ link_name = "\u{1}_ZNK4seal4util13BaseConverter9fastbconvEPKmPmNS_16MemoryPoolHandleE" ] pub fn seal_util_BaseConverter_fastbconv ( this : * const seal_util_BaseConverter , input : * const u64 , destination : * mut u64 , pool : seal_MemoryPoolHandle ) ; } extern "C" { 
 ///Fast base converter from Bsk to q 
 # [ link_name = "\u{1}_ZNK4seal4util13BaseConverter12fastbconv_skEPKmPmNS_16MemoryPoolHandleE" ] pub fn seal_util_BaseConverter_fastbconv_sk ( this : * const seal_util_BaseConverter , input : * const u64 , destination : * mut u64 , pool : seal_MemoryPoolHandle ) ; } extern "C" { 
 ///Reduction from Bsk U {m_tilde} to Bsk 
 # [ link_name = "\u{1}_ZNK4seal4util13BaseConverter7mont_rqEPKmPm" ] pub fn seal_util_BaseConverter_mont_rq ( this : * const seal_util_BaseConverter , input : * const u64 , destination : * mut u64 ) ; } extern "C" { 
 ///Fast base converter from q U Bsk to Bsk 
 # [ link_name = "\u{1}_ZNK4seal4util13BaseConverter10fast_floorEPKmPmNS_16MemoryPoolHandleE" ] pub fn seal_util_BaseConverter_fast_floor ( this : * const seal_util_BaseConverter , input : * const u64 , destination : * mut u64 , pool : seal_MemoryPoolHandle ) ; } extern "C" { 
 ///Fast base converter from q to Bsk U {m_tilde} 
 # [ link_name = "\u{1}_ZNK4seal4util13BaseConverter16fastbconv_mtildeEPKmPmNS_16MemoryPoolHandleE" ] pub fn seal_util_BaseConverter_fastbconv_mtilde ( this : * const seal_util_BaseConverter , input : * const u64 , destination : * mut u64 , pool : seal_MemoryPoolHandle ) ; } extern "C" { 
 ///Fast base converter from q to plain_modulus U {gamma} 
 # [ link_name = "\u{1}_ZNK4seal4util13BaseConverter21fastbconv_plain_gammaEPKmPmNS_16MemoryPoolHandleE" ] pub fn seal_util_BaseConverter_fastbconv_plain_gamma ( this : * const seal_util_BaseConverter , input : * const u64 , destination : * mut u64 , pool : seal_MemoryPoolHandle ) ; } extern "C" { # [ link_name = "\u{1}_ZN4seal4util13BaseConverter5resetEv" ] pub fn seal_util_BaseConverter_reset ( this : * mut seal_util_BaseConverter ) ; } extern "C" { # [ link_name = "\u{1}_ZN4seal4util13BaseConverterC1ERKSt6vectorINS_12SmallModulusESaIS3_EEmRKS3_NS_16MemoryPoolHandleE" ] pub fn seal_util_BaseConverter_BaseConverter ( this : * mut seal_util_BaseConverter , coeff_base : * const std_vector , coeff_count : usize , small_plain_mod : * const seal_util_global_variables_internal_mods_SmallModulus , pool : seal_MemoryPoolHandle ) ; } impl seal_util_BaseConverter { # [ inline ] pub unsafe fn generate ( & mut self , coeff_base : * const std_vector , coeff_count : usize , small_plain_mod : * const seal_util_global_variables_internal_mods_SmallModulus ) { seal_util_BaseConverter_generate ( self , coeff_base , coeff_count , small_plain_mod ) } # [ inline ] pub unsafe fn fastbconv ( & self , input : * const u64 , destination : * mut u64 , pool : seal_MemoryPoolHandle ) { seal_util_BaseConverter_fastbconv ( self , input , destination , pool ) } # [ inline ] pub unsafe fn fastbconv_sk ( & self , input : * const u64 , destination : * mut u64 , pool : seal_MemoryPoolHandle ) { seal_util_BaseConverter_fastbconv_sk ( self , input , destination , pool ) } # [ inline ] pub unsafe fn mont_rq ( & self , input : * const u64 , destination : * mut u64 ) { seal_util_BaseConverter_mont_rq ( self , input , destination ) } # [ inline ] pub unsafe fn fast_floor ( & self , input : * const u64 , destination : * mut u64 , pool : seal_MemoryPoolHandle ) { seal_util_BaseConverter_fast_floor ( self , input , destination , pool ) } # [ inline ] pub unsafe fn fastbconv_mtilde ( & self , input : * const u64 , destination : * mut u64 , pool : seal_MemoryPoolHandle ) { seal_util_BaseConverter_fastbconv_mtilde ( self , input , destination , pool ) } # [ inline ] pub unsafe fn fastbconv_plain_gamma ( & self , input : * const u64 , destination : * mut u64 , pool : seal_MemoryPoolHandle ) { seal_util_BaseConverter_fastbconv_plain_gamma ( self , input , destination , pool ) } # [ inline ] pub unsafe fn reset ( & mut self ) { seal_util_BaseConverter_reset ( self ) } # [ inline ] pub unsafe fn new ( coeff_base : * const std_vector , coeff_count : usize , small_plain_mod : * const seal_util_global_variables_internal_mods_SmallModulus , pool : seal_MemoryPoolHandle ) -> Self { let mut __bindgen_tmp = :: std :: mem :: uninitialized ( ) ; seal_util_BaseConverter_BaseConverter ( & mut __bindgen_tmp , coeff_base , coeff_count , small_plain_mod , pool ) ; __bindgen_tmp } } 
 ///Manages a shared pointer to a memory pool. SEAL uses memory pools for
///improved performance due to the large number of memory allocations needed
///by the homomorphic encryption operations, and the underlying polynomial
///arithmetic. The library automatically creates a shared global memory pool
///that is used for all dynamic allocations by default, and the user can
///optionally create any number of custom memory pools to be used instead.
///
///@Uses in Multi-Threaded Applications
///Sometimes the user might want to use specific memory pools for dynamic
///allocations in certain functions. For example, in heavily multi-threaded
///applications allocating concurrently from a shared memory pool might lead
///to significant performance issues due to thread contention. For these cases
///SEAL provides overloads of the functions that take a MemoryPoolHandle as an
///additional argument, and uses the associated memory pool for all dynamic
///allocations inside the function. Whenever these functions are called, the
///user can then simply pass a thread-local MemoryPoolHandle to be used.
///
///@Thread-Unsafe Memory Pools
///While memory pools are by default thread-safe, in some cases it suffices
///to have a memory pool be thread-unsafe. To get a little extra performance,
///the user can optionally create such thread-unsafe memory pools and use them
///just as they would use thread-safe memory pools.
///
///@Initialized and Uninitialized Handles
///A MemoryPoolHandle has to be set to point either to the global memory pool,
///or to a new memory pool. If this is not done, the MemoryPoolHandle is
///said to be uninitialized, and cannot be used. Initialization simple means
///assigning MemoryPoolHandle::Global() or MemoryPoolHandle::New() to it.
///
///@Managing Lifetime
///Internally, the MemoryPoolHandle wraps an std::shared_ptr pointing to
///a SEAL memory pool class. Thus, as long as a MemoryPoolHandle pointing to
///a particular memory pool exists, the pool stays alive. Classes such as
///Evaluator and Ciphertext store their own local copies of a MemoryPoolHandle
///to guarantee that the pool stays alive as long as the managing object
///itself stays alive. The global memory pool is implemented as a global
///std::shared_ptr to a memory pool class, and is thus expected to stay
///alive for the entire duration of the program execution. Note that it can
///be problematic to create other global objects that use the memory pool
///e.g. in their constructor, as one would have to ensure the initialization
///order of these global variables to be correct (i.e. global memory pool
///first). 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct seal_MemoryPoolHandle { pub pool_ : std_shared_ptr , } # [ test ] fn bindgen_test_layout_seal_MemoryPoolHandle ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_MemoryPoolHandle > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( seal_MemoryPoolHandle ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_MemoryPoolHandle > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_MemoryPoolHandle ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_MemoryPoolHandle > ( ) ) ) . pool_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( seal_MemoryPoolHandle ) , "::" , stringify ! ( pool_ ) ) ) ; } # [ repr ( C ) ] pub struct seal_UniformRandomGenerator__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; 
 ///Provides the base-class for a uniform random number generator. Instances of
///this class are typically returned from the UniformRandomGeneratorFactory class.
///This class is meant for users to sub-class to implement their own random number
///generators. The implementation should provide a uniform random unsigned 32-bit
///value for each call to generate(). Note that the library will never make
///concurrent calls to generate() to the same instance (but individual instances
///of the same class may have concurrent calls). The uniformity and unpredictability
///of the numbers generated is essential for making a secure cryptographic system.
///
///@see UniformRandomGeneratorFactory for the base-class of a factory class that
///generates UniformRandomGenerator instances.
///@see StandardRandomAdapter for an implementation of UniformRandomGenerator to
///support the C++ standard library's random number generators. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct seal_UniformRandomGenerator { pub vtable_ : * const seal_UniformRandomGenerator__bindgen_vtable , } # [ test ] fn bindgen_test_layout_seal_UniformRandomGenerator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_UniformRandomGenerator > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( seal_UniformRandomGenerator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_UniformRandomGenerator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_UniformRandomGenerator ) ) ) ; } # [ repr ( C ) ] pub struct seal_UniformRandomGeneratorFactory__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; 
 ///Provides the base-class for a factory instance that creates instances of
///UniformRandomGenerator. This class is meant for users to sub-class to implement
///their own random number generators. Note that each instance returned may be
///used concurrently across separate threads, but each individual instance does
///not need to be thread-safe.
///
///@see UniformRandomGenerator for details relating to the random number generator
///instances.
///@see StandardRandomAdapterFactory for an implementation of
///UniformRandomGeneratorFactory that supports the standard C++ library's
///random number generators. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct seal_UniformRandomGeneratorFactory { pub vtable_ : * const seal_UniformRandomGeneratorFactory__bindgen_vtable , } # [ test ] fn bindgen_test_layout_seal_UniformRandomGeneratorFactory ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_UniformRandomGeneratorFactory > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( seal_UniformRandomGeneratorFactory ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_UniformRandomGeneratorFactory > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_UniformRandomGeneratorFactory ) ) ) ; } extern "C" { 
 ///Returns the default random number generator factory. This instance should
///not be destroyed. 
 # [ link_name = "\u{1}_ZN4seal29UniformRandomGeneratorFactory15default_factoryEv" ] pub fn seal_UniformRandomGeneratorFactory_default_factory ( ) -> std_shared_ptr ; } impl seal_UniformRandomGeneratorFactory { # [ inline ] pub unsafe fn default_factory ( ) -> std_shared_ptr { seal_UniformRandomGeneratorFactory_default_factory ( ) } } pub const seal_scheme_type_BFV : seal_scheme_type = 1 ; pub const seal_scheme_type_CKKS : seal_scheme_type = 2 ; pub type seal_scheme_type = u8 ; 
 ///The data type to store unique identifiers of encryption parameters. 
 pub type seal_parms_id_type = seal_util_HashFunction_sha3_block_type ; 
 ///Represents user-customizable encryption scheme settings. The parameters (most
///importantly poly_modulus, coeff_modulus, plain_modulus) significantly affect
///the performance, capabilities, and security of the encryption scheme. Once
///an instance of EncryptionParameters is populated with appropriate parameters,
///it can be used to create an instance of the SEALContext class, which verifies
///the validity of the parameters, and performs necessary pre-computations.
///
///Picking appropriate encryption parameters is essential to enable a particular
///application while balancing performance and security. Some encryption settings
///will not allow some inputs (e.g. attempting to encrypt a polynomial with more
///coefficients than poly_modulus or larger coefficients than plain_modulus) or,
///support the desired computations (with noise growing too fast due to too large
///plain_modulus and too small coeff_modulus).
///
///@par parms_id
///The EncryptionParameters class maintains at all times a 256-bit SHA-3 hash of
///the currently set encryption parameters. This hash acts as a unique identifier
///of the encryption parameters and is used by all further objects created for
///these encryption parameters. The parms_id is not intended to be directly modified
///by the user but is used internally for pre-computation data lookup and input
///validity checks. In modulus switching the user can use the parms_id to map the
///chain of encryption parameters.
///
///@par Thread Safety
///In general, reading from EncryptionParameters is thread-safe, while mutating
///is not.
///
///@warning Choosing inappropriate encryption parameters may lead to an encryption
///scheme that is not secure, does not perform well, and/or does not support the
///input and computation of the desired application. We highly recommend consulting
///an expert in RLWE-based encryption when selecting parameters, as this is where
///inexperienced users seem to most often make critical mistakes. 
 # [ repr ( C ) ] pub struct seal_EncryptionParameters { pub pool_ : seal_MemoryPoolHandle , pub scheme_ : seal_scheme_type , pub poly_modulus_degree_ : usize , pub coeff_modulus_ : std_vector , pub noise_standard_deviation_ : f64 , pub noise_max_deviation_ : f64 , pub random_generator_ : std_shared_ptr , pub plain_modulus_ : seal_util_global_variables_internal_mods_SmallModulus , pub parms_id_ : seal_parms_id_type , } # [ test ] fn bindgen_test_layout_seal_EncryptionParameters ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_EncryptionParameters > ( ) , 168usize , concat ! ( "Size of: " , stringify ! ( seal_EncryptionParameters ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_EncryptionParameters > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_EncryptionParameters ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameters > ( ) ) ) . pool_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameters ) , "::" , stringify ! ( pool_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameters > ( ) ) ) . scheme_ as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameters ) , "::" , stringify ! ( scheme_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameters > ( ) ) ) . poly_modulus_degree_ as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameters ) , "::" , stringify ! ( poly_modulus_degree_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameters > ( ) ) ) . coeff_modulus_ as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameters ) , "::" , stringify ! ( coeff_modulus_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameters > ( ) ) ) . noise_standard_deviation_ as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameters ) , "::" , stringify ! ( noise_standard_deviation_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameters > ( ) ) ) . noise_max_deviation_ as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameters ) , "::" , stringify ! ( noise_max_deviation_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameters > ( ) ) ) . random_generator_ as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameters ) , "::" , stringify ! ( random_generator_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameters > ( ) ) ) . plain_modulus_ as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameters ) , "::" , stringify ! ( plain_modulus_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameters > ( ) ) ) . parms_id_ as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameters ) , "::" , stringify ! ( parms_id_ ) ) ) ; } extern "C" { 
 ///Saves EncryptionParameters to an output stream. The output is in binary
///format and is not human-readable. The output stream must have the "binary"
///flag set.
///
///@param[in] stream The stream to save the EncryptionParameters to
///@throws std::exception if the EncryptionParameters could not be written
///to stream 
 # [ link_name = "\u{1}_ZN4seal20EncryptionParameters4SaveERKS0_RSo" ] pub fn seal_EncryptionParameters_Save ( parms : * const seal_EncryptionParameters , stream : * mut std_ostream ) ; } extern "C" { 
 ///Loads EncryptionParameters from an input stream.
///
///@param[in] stream The stream to load the EncryptionParameters from
///@throws std::exception if valid EncryptionParameters could not be read
///from stream 
 # [ link_name = "\u{1}_ZN4seal20EncryptionParameters4LoadERSi" ] pub fn seal_EncryptionParameters_Load ( stream : * mut std_istream ) -> seal_EncryptionParameters ; } impl seal_EncryptionParameters { # [ inline ] pub unsafe fn Save ( parms : * const seal_EncryptionParameters , stream : * mut std_ostream ) { seal_EncryptionParameters_Save ( parms , stream ) } # [ inline ] pub unsafe fn Load ( stream : * mut std_istream ) -> seal_EncryptionParameters { seal_EncryptionParameters_Load ( stream ) } } 
 ///Stores a set of attributes (qualifiers) of a set of encryption parameters.
///These parameters are mainly used internally in various parts of the library, e.g.
///to determine which algorithmic optimizations the current support. The qualifiers
///are automatically created by the SEALContext class, silently passed on to classes
///such as Encryptor, Evaluator, and Decryptor, and the only way to change them is by
///changing the encryption parameters themselves. In other words, a user will never
///have to create their own instance of EncryptionParameterQualifiers, and in most
///cases never have to worry about them at all.
///
///@see EncryptionParameters::GetQualifiers for obtaining the EncryptionParameterQualifiers
///corresponding to the current parameter set. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct seal_EncryptionParameterQualifiers { 
 ///If the encryption parameters are set in a way that is considered valid by SEAL, the
    ///variable parameters_set is set to true. 
 pub parameters_set : bool , 
 ///Tells whether FFT can be used for polynomial multiplication. If the polynomial modulus
    ///is of the form X^N+1, where N is a power of two, then FFT can be used for fast
    ///multiplication of polynomials modulo the polynomial modulus. In this case the
    ///variable using_fft will be set to true. However, currently SEAL requires this
    ///to be the case for the parameters to be valid. Therefore, parameters_set can only
    ///be true if using_fft is true. 
 pub using_fft : bool , 
 ///Tells whether NTT can be used for polynomial multiplication. If the primes in the
    ///coefficient modulus are congruent to 1 modulo 2N, where X^N+1 is the polynomial
    ///modulus and N is a power of two, then the number-theoretic transform (NTT) can be
    ///used for fast multiplications of polynomials modulo the polynomial modulus and
    ///coefficient modulus. In this case the variable using_ntt will be set to true. However,
    ///currently SEAL requires this to be the case for the parameters to be valid. Therefore,
    ///parameters_set can only be true if using_ntt is true. 
 pub using_ntt : bool , 
 ///Tells whether batching is supported by the encryption parameters. If the plaintext
    ///modulus is congruent to 1 modulo 2N, where X^N+1 is the polynomial modulus and N is
    ///a power of two, then it is possible to use the BatchEncoder class to view plaintext
    ///elements as 2-by-(N/2) matrices of integers modulo the plaintext modulus. This is
    ///called batching, and allows the user to operate on the matrix elements (slots) in
    ///a SIMD fashion, and rotate the matrix rows and columns. When the computation is
    ///easily vectorizable, using batching can yield a huge performance boost. If the
    ///encryption parameters support batching, the variable using_batching is set to true. 
 pub using_batching : bool , 
 ///Tells whether fast plain lift is supported by the encryption parameters. A certain
    ///performance optimization in multiplication of a ciphertext by a plaintext
    ///(Evaluator::multiply_plain) and in transforming a plaintext element to NTT domain
    ///(Evaluator::transform_to_ntt) can be used when the plaintext modulus is smaller than
    ///each prime in the coefficient modulus. In this case the variable using_fast_plain_lift
    ///is set to true. 
 pub using_fast_plain_lift : bool , 
 ///Tells whether the encryption parameters are secure based on the standard parameters
    ///from HomomorphicEncryption.org security standard. 
 pub using_he_std_security : bool , } # [ test ] fn bindgen_test_layout_seal_EncryptionParameterQualifiers ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_EncryptionParameterQualifiers > ( ) , 6usize , concat ! ( "Size of: " , stringify ! ( seal_EncryptionParameterQualifiers ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_EncryptionParameterQualifiers > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( seal_EncryptionParameterQualifiers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameterQualifiers > ( ) ) ) . parameters_set as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameterQualifiers ) , "::" , stringify ! ( parameters_set ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameterQualifiers > ( ) ) ) . using_fft as * const _ as usize } , 1usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameterQualifiers ) , "::" , stringify ! ( using_fft ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameterQualifiers > ( ) ) ) . using_ntt as * const _ as usize } , 2usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameterQualifiers ) , "::" , stringify ! ( using_ntt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameterQualifiers > ( ) ) ) . using_batching as * const _ as usize } , 3usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameterQualifiers ) , "::" , stringify ! ( using_batching ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameterQualifiers > ( ) ) ) . using_fast_plain_lift as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameterQualifiers ) , "::" , stringify ! ( using_fast_plain_lift ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_EncryptionParameterQualifiers > ( ) ) ) . using_he_std_security as * const _ as usize } , 5usize , concat ! ( "Offset of field: " , stringify ! ( seal_EncryptionParameterQualifiers ) , "::" , stringify ! ( using_he_std_security ) ) ) ; } 
 ///Performs sanity checks (validation) and pre-computations for a given set of encryption
///parameters. While the EncryptionParameters class is intended to be a light-weight class
///to store the encryption parameters, the SEALContext class is a heavy-weight class that
///is constructed from a given set of encryption parameters. It validates the parameters
///for correctness, evaluates their properties, and performs and stores the results of
///several costly pre-computations.
///
///After the user has set at least the poly_modulus, coeff_modulus, and plain_modulus
///parameters in a given EncryptionParameters instance, the parameters can be validated
///for correctness and functionality by constructing an instance of SEALContext. The
///constructor of SEALContext does all of its work automatically, and concludes by
///constructing and storing an instance of the EncryptionParameterQualifiers class, with
///its flags set according to the properties of the given parameters. If the created
///instance of EncryptionParameterQualifiers has the parameters_set flag set to true, the
///given parameter set has been deemed valid and is ready to be used. If the parameters
///were for some reason not appropriately set, the parameters_set flag will be false,
///and a new SEALContext will have to be created after the parameters are corrected.
///
///@see EncryptionParameters for more details on the parameters.
///@see EncryptionParameterQualifiers for more details on the qualifiers. 
 # [ repr ( C ) ] pub struct seal_SEALContext { pub pool_ : seal_MemoryPoolHandle , pub first_parms_id_ : seal_parms_id_type , pub last_parms_id_ : seal_parms_id_type , pub context_data_map_ : std_unordered_map , } # [ repr ( C ) ] pub struct seal_SEALContext_ContextData { pub pool_ : seal_MemoryPoolHandle , pub parms_ : seal_EncryptionParameters , pub qualifiers_ : seal_EncryptionParameterQualifiers , pub base_converter_ : seal_util_Pointer < seal_util_BaseConverter > , pub small_ntt_tables_ : seal_util_Pointer < seal_util_SmallNTTTables > , pub plain_ntt_tables_ : seal_util_Pointer < seal_util_SmallNTTTables > , pub total_coeff_modulus_ : seal_util_Pointer < u64 > , pub total_coeff_modulus_bit_count_ : :: std :: os :: raw :: c_int , pub coeff_div_plain_modulus_ : seal_util_Pointer < u64 > , pub plain_upper_half_threshold_ : u64 , pub plain_upper_half_increment_ : seal_util_Pointer < u64 > , pub upper_half_threshold_ : seal_util_Pointer < u64 > , pub upper_half_increment_ : seal_util_Pointer < u64 > , pub next_context_data_ : std_shared_ptr , pub chain_index_ : usize , } # [ test ] fn bindgen_test_layout_seal_SEALContext_ContextData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_SEALContext_ContextData > ( ) , 488usize , concat ! ( "Size of: " , stringify ! ( seal_SEALContext_ContextData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_SEALContext_ContextData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_SEALContext_ContextData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . pool_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( pool_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . parms_ as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( parms_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . qualifiers_ as * const _ as usize } , 184usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( qualifiers_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . base_converter_ as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( base_converter_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . small_ntt_tables_ as * const _ as usize } , 224usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( small_ntt_tables_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . plain_ntt_tables_ as * const _ as usize } , 256usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( plain_ntt_tables_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . total_coeff_modulus_ as * const _ as usize } , 288usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( total_coeff_modulus_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . total_coeff_modulus_bit_count_ as * const _ as usize } , 320usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( total_coeff_modulus_bit_count_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . coeff_div_plain_modulus_ as * const _ as usize } , 328usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( coeff_div_plain_modulus_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . plain_upper_half_threshold_ as * const _ as usize } , 360usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( plain_upper_half_threshold_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . plain_upper_half_increment_ as * const _ as usize } , 368usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( plain_upper_half_increment_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . upper_half_threshold_ as * const _ as usize } , 400usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( upper_half_threshold_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . upper_half_increment_ as * const _ as usize } , 432usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( upper_half_increment_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . next_context_data_ as * const _ as usize } , 464usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( next_context_data_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext_ContextData > ( ) ) ) . chain_index_ as * const _ as usize } , 480usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext_ContextData ) , "::" , stringify ! ( chain_index_ ) ) ) ; } # [ test ] fn bindgen_test_layout_seal_SEALContext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_SEALContext > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( seal_SEALContext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_SEALContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( seal_SEALContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext > ( ) ) ) . pool_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext ) , "::" , stringify ! ( pool_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext > ( ) ) ) . first_parms_id_ as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext ) , "::" , stringify ! ( first_parms_id_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext > ( ) ) ) . last_parms_id_ as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext ) , "::" , stringify ! ( last_parms_id_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < seal_SEALContext > ( ) ) ) . context_data_map_ as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( seal_SEALContext ) , "::" , stringify ! ( context_data_map_ ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_basic_string < :: std :: os :: raw :: c_char > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( std_basic_string < :: std :: os :: raw :: c_char > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_basic_string < :: std :: os :: raw :: c_char > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_basic_string < :: std :: os :: raw :: c_char > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_char_traits > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_char_traits ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_char_traits > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_char_traits ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_allocator > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_allocator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_allocator > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_allocator ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_data { pub _address : u8 , } # [ test ] fn __bindgen_test_layout_std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_basic_istream < :: std :: os :: raw :: c_char > > ( ) , 280usize , concat ! ( "Size of template specialization: " , stringify ! ( std_basic_istream < :: std :: os :: raw :: c_char > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_basic_istream < :: std :: os :: raw :: c_char > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_basic_istream < :: std :: os :: raw :: c_char > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_char_traits > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_char_traits ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_char_traits > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_char_traits ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_basic_ostream_open0_char_std_char_traits_open1_char_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_basic_ostream < :: std :: os :: raw :: c_char > > ( ) , 272usize , concat ! ( "Size of template specialization: " , stringify ! ( std_basic_ostream < :: std :: os :: raw :: c_char > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_basic_ostream < :: std :: os :: raw :: c_char > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_basic_ostream < :: std :: os :: raw :: c_char > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_char_traits > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_char_traits ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_char_traits > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_char_traits ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _bindgen_ty_25 { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _bindgen_ty_26 { pub _address : u8 , } # [ test ] fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_iterator > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_iterator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_iterator > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_iterator ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_SEAL_BYTE_void_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_SEAL_BYTE > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_SEAL_BYTE > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_SEAL_BYTE > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_SEAL_BYTE > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_shared_ptr_open0_seal_util_MemoryPool_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_shared_ptr > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_shared_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_shared_ptr_open0_seal_UniformRandomGenerator_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_shared_ptr > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_shared_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_shared_ptr_open0_seal_UniformRandomGeneratorFactory_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_shared_ptr > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_shared_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_vector_open0_seal_util_global_variables_internal_mods_SmallModulus_std_allocator_open1_seal_util_global_variables_internal_mods_SmallModulus_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_vector > ( ) , 24usize , concat ! ( "Size of template specialization: " , stringify ! ( std_vector ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_vector > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_vector ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_allocator_open0_seal_util_global_variables_internal_mods_SmallModulus_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_allocator > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_allocator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_allocator > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_allocator ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_shared_ptr_open0_seal_UniformRandomGeneratorFactory_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_shared_ptr > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_shared_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_unsigned_long_void_close0_instantiation_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < :: std :: os :: raw :: c_ulong > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < :: std :: os :: raw :: c_ulong > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_vector_open0_seal_util_global_variables_internal_mods_SmallModulus_std_allocator_open1_seal_util_global_variables_internal_mods_SmallModulus_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_vector > ( ) , 24usize , concat ! ( "Size of template specialization: " , stringify ! ( std_vector ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_vector > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_vector ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_allocator_open0_seal_util_global_variables_internal_mods_SmallModulus_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_allocator > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_allocator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_allocator > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_allocator ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_vector_open0_seal_util_global_variables_internal_mods_SmallModulus_std_allocator_open1_seal_util_global_variables_internal_mods_SmallModulus_close1_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_vector > ( ) , 24usize , concat ! ( "Size of template specialization: " , stringify ! ( std_vector ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_vector > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_vector ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_allocator_open0_seal_util_global_variables_internal_mods_SmallModulus_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_allocator > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_allocator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_allocator > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_allocator ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_global_variables_internal_mods_SmallModulus_void_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_global_variables_internal_mods_SmallModulus_void_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_global_variables_internal_mods_SmallModulus_void_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_global_variables_internal_mods_SmallModulus_void_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_global_variables_internal_mods_SmallModulus > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_Pointer_open1_uint64_t_void_close1_void_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_util_Pointer < u64 > > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_Pointer < u64 > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_util_Pointer < u64 > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_Pointer < u64 > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_Pointer_open1_uint64_t_void_close1_void_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_util_Pointer < u64 > > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_Pointer < u64 > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_util_Pointer < u64 > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_Pointer < u64 > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_8 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_9 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_10 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_11 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_Pointer_open1_uint64_t_void_close1_void_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_util_Pointer < u64 > > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_Pointer < u64 > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_util_Pointer < u64 > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_Pointer < u64 > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_12 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_13 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_14 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_SmallNTTTables_void_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_util_SmallNTTTables > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_SmallNTTTables > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_util_SmallNTTTables > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_SmallNTTTables > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_15 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_BaseConverter_void_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_util_BaseConverter > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_BaseConverter > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_util_BaseConverter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_BaseConverter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_SmallNTTTables_void_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_util_SmallNTTTables > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_SmallNTTTables > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_util_SmallNTTTables > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_SmallNTTTables > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_seal_util_SmallNTTTables_void_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < seal_util_SmallNTTTables > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_SmallNTTTables > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < seal_util_SmallNTTTables > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < seal_util_SmallNTTTables > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_16 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_17 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_18 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_19 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_seal_util_Pointer_open0_uint64_t_void_close0_instantiation_20 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < seal_util_Pointer < u64 > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < seal_util_Pointer < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( seal_util_Pointer < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_shared_ptr_open0_seal_SEALContext_ContextData_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_shared_ptr > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_shared_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unordered_map_open0_seal_parms_id_type_std_shared_ptr_open1_seal_SEALContext_ContextData_close1_std_hash_open1_std_array_open2_unsigned_long_close2_close1_std_equal_to_open1_std_array_open2_unsigned_long_close2_close1_std_allocator_open1_std_pair_open2_std_array_open3_unsigned_long_close3_std_shared_ptr_open3_seal_SEALContext_ContextData_close3_close2_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_unordered_map > ( ) , 56usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unordered_map ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_unordered_map > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unordered_map ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_shared_ptr_open0_seal_SEALContext_ContextData_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_shared_ptr > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_shared_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_hash_open0_std_array_open1_unsigned_long_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_hash > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_hash ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_hash > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_hash ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_equal_to_open0_std_array_open1_unsigned_long_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_equal_to > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_equal_to ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_equal_to > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_equal_to ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_allocator_open0_std_pair_open1_std_array_open2_unsigned_long_close2_std_shared_ptr_open2_seal_SEALContext_ContextData_close2_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_allocator > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_allocator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_allocator > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_allocator ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_pair_open0_std_array_open1_unsigned_long_close1_std_shared_ptr_open1_seal_SEALContext_ContextData_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < [ u64 ; 6usize ] > ( ) , 48usize , concat ! ( "Size of template specialization: " , stringify ! ( [ u64 ; 6usize ] ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < [ u64 ; 6usize ] > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( [ u64 ; 6usize ] ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_shared_ptr_open0_seal_SEALContext_ContextData_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < std_shared_ptr > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < std_shared_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_shared_ptr ) ) ) ; }